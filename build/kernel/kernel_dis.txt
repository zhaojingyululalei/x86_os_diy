
kernel.elf：     文件格式 elf32-i386
kernel.elf
体系结构：i386， 标志 0x00000112：
EXEC_P, HAS_SYMS, D_PAGED
起始地址 0x00010000

程序头：
    LOAD off    0x00000000 vaddr 0x0000f000 paddr 0x0000f000 align 2**12
         filesz 0x000000d4 memsz 0x000000d4 flags r--
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x00000c1f memsz 0x00000c1f flags r-x
    LOAD off    0x00002000 vaddr 0x00011000 paddr 0x00011000 align 2**12
         filesz 0x000000d0 memsz 0x000000d0 flags r--
    LOAD off    0x000020d0 vaddr 0x000120d0 paddr 0x000120d0 align 2**12
         filesz 0x00000010 memsz 0x00000018 flags rw-
   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4
         filesz 0x00000000 memsz 0x00000000 flags rwx

节：
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000c1f  00010000  00010000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       000000d0  00011000  00011000  00002000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000010  000120d0  000120d0  000020d0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000008  000120e0  000120e0  000020e0  2**2
                  ALLOC
  4 .comment      0000002b  00000000  00000000  000020e0  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000100  00000000  00000000  00002110  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_info   00000f4e  00000000  00000000  00002210  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_abbrev 000007eb  00000000  00000000  0000315e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   00000957  00000000  00000000  00003949  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_frame  000004a4  00000000  00000000  000042a0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_str    00000440  00000000  00000000  00004744  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line_str 00000152  00000000  00000000  00004b84  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 start.o
00010007 l       .text	00000000 entry_kernel
00000000 l    df *ABS*	00000000 init.c
0001101c l     O .rodata	0000000c __FUNCTION__.1
00011028 l     O .rodata	0000000c __func__.0
00000000 l    df *ABS*	00000000 cpu.c
00010076 l     F .text	00000010 read_eflags
00010086 l     F .text	0000000b write_eflags
00010091 l     F .text	00000007 cli
00010098 l     F .text	00000007 sti
00000000 l    df *ABS*	00000000 rtc.c
000100de l     F .text	0000001d inb
000100fb l     F .text	00000021 outb
0001011c l     F .text	00000027 read_cmos
00000000 l    df *ABS*	00000000 serial.c
00010295 l     F .text	0000001d inb
000102b2 l     F .text	00000021 outb
00000000 l    df *ABS*	00000000 debug.c
000103b4 l     F .text	00000007 hlt
000120d0 l     O .data	00000010 title.0
00000000 l    df *ABS*	00000000 string.c
00000000 l    df *ABS*	00000000 time.c
000110a0 l     O .rodata	00000030 days_in_month
000108c6 l     F .text	00000064 is_leap_year
000104ad g     F .text	00000026 strcpy
000100aa g     F .text	0000000b irq_enable_global
0001079e g     F .text	00000128 vsprintf
000120e4 g     O .bss	00000004 startup_time
000103bb g     F .text	000000ad dbg_print
000105c8 g     F .text	00000040 memcpy
00010348 g     F .text	0000006c serial_printf
000106a9 g     F .text	000000d1 itoa
000102d3 g     F .text	00000075 rs232_init
000120e0 g     O .bss	00000004 boot_inform
0001009f g     F .text	0000000b irq_disable_global
0001001e g     F .text	00000058 kernel_init
00010000 g       .text	00000000 _start
0001052f g     F .text	00000072 strncmp
000104d3 g     F .text	0000005c strncpy
00010468 g     F .text	00000045 panic
00010641 g     F .text	00000068 memcmp
000100b5 g     F .text	00000018 irq_enter_protection
000120e0 g       .bss	00000000 __bss_start
000109f9 g     F .text	00000226 localtime
00010608 g     F .text	00000039 memset
0001077a g     F .text	00000024 sprintf
000100cd g     F .text	00000011 irq_leave_protection
000120e0 g       .data	00000000 _edata
000120e8 g       .bss	00000000 _end
0001092a g     F .text	000000cf kernel_mktime
000105a1 g     F .text	00000027 strlen
00010143 g     F .text	00000152 time_init



Disassembly of section .text:

00010000 <_start>:
	#include "cpu_cfg.h"
    .extern kernel_init
    .global _start

_start:
    ljmpl $SELECTOR_KERNEL_CODE_SEG,$entry_kernel
   10000:	ea 07 00 01 00       	ljmp   $0x1,$0x7
   10005:	18 00                	sbb    %al,(%bx,%si)

00010007 <entry_kernel>:
entry_kernel:
    mov $SELECTOR_KERNEL_DATA_SEG,%ax
   10007:	66 b8 20 00 8e d8    	mov    $0xd88e0020,%eax
    mov %ax, %ds
	mov %ax, %ss
   1000d:	8e d0                	mov    %ax,%ss
	mov %ax, %es
   1000f:	8e c0                	mov    %ax,%es
	mov %ax, %fs
   10011:	8e e0                	mov    %ax,%fs
	mov %ax, %gs
   10013:	8e e8                	mov    %ax,%gs


    push 4(%esp) # 将boot_info入栈
   10015:	ff 74 24             	push   0x24(%si)
   10018:	04 e8                	add    $0xe8,%al

   1001a:	00 00                	add    %al,(%bx,%si)
	...

0001001e <kernel_init>:
#include "boot_info.h"
#include "debug.h"
#include "rtc.h"
boot_info_t* boot_inform;
void kernel_init(boot_info_t *boot_info)
{
   1001e:	55                   	push   %bp
   1001f:	89 e5                	mov    %sp,%bp
   10021:	83 ec 18             	sub    $0x18,%sp
    rs232_init();
   10024:	e8 aa 02             	call   102d1 <outb+0x1f>
   10027:	00 00                	add    %al,(%bx,%si)
    time_init();
   10029:	e8 15 01             	call   10141 <read_cmos+0x25>
   1002c:	00 00                	add    %al,(%bx,%si)
    boot_inform = boot_info;
   1002e:	8b 45 08             	mov    0x8(%di),%ax
   10031:	a3 e0 20             	mov    %ax,0x20e0
   10034:	01 00                	add    %ax,(%bx,%si)
    dbg_info("hello world\r\n");
   10036:	83 ec 0c             	sub    $0xc,%sp
   10039:	68 00 10             	push   $0x1000
   1003c:	01 00                	add    %ax,(%bx,%si)
   1003e:	6a 0b                	push   $0xb
   10040:	68 1c 10             	push   $0x101c
   10043:	01 00                	add    %ax,(%bx,%si)
   10045:	68 0e 10             	push   $0x100e
   10048:	01 00                	add    %ax,(%bx,%si)
   1004a:	6a 03                	push   $0x3
   1004c:	e8 6a 03             	call   103b9 <hlt+0x5>
   1004f:	00 00                	add    %al,(%bx,%si)
   10051:	83 c4 20             	add    $0x20,%sp
    ASSERT(1==2);
   10054:	68 15 10             	push   $0x1015
   10057:	01 00                	add    %ax,(%bx,%si)
   10059:	68 28 10             	push   $0x1028
   1005c:	01 00                	add    %ax,(%bx,%si)
   1005e:	6a 0c                	push   $0xc
   10060:	68 0e 10             	push   $0x100e
   10063:	01 00                	add    %ax,(%bx,%si)
   10065:	e8 fe 03             	call   10466 <dbg_print+0xab>
   10068:	00 00                	add    %al,(%bx,%si)
   1006a:	83 c4 10             	add    $0x10,%sp
    int a = 1;
   1006d:	c7 45 f4 01 00       	movw   $0x1,-0xc(%di)
   10072:	00 00                	add    %al,(%bx,%si)
    while (1)
   10074:	eb fe                	jmp    10074 <kernel_init+0x56>

00010076 <read_eflags>:

static inline void hlt(void) {
    __asm__ __volatile__("hlt");
}

static inline uint32_t read_eflags (void) {
   10076:	55                   	push   %bp
   10077:	89 e5                	mov    %sp,%bp
   10079:	83 ec 10             	sub    $0x10,%sp
    uint32_t eflags;

    __asm__ __volatile__("pushfl\n\tpopl %%eax":"=a"(eflags));
   1007c:	9c                   	pushf  
   1007d:	58                   	pop    %ax
   1007e:	89 45 fc             	mov    %ax,-0x4(%di)
    return eflags;
   10081:	8b 45 fc             	mov    -0x4(%di),%ax
}
   10084:	c9                   	leave  
   10085:	c3                   	ret    

00010086 <write_eflags>:

static inline void write_eflags (uint32_t eflags) {
   10086:	55                   	push   %bp
   10087:	89 e5                	mov    %sp,%bp
    __asm__ __volatile__("pushl %%eax\n\tpopfl"::"a"(eflags));
   10089:	8b 45 08             	mov    0x8(%di),%ax
   1008c:	50                   	push   %ax
   1008d:	9d                   	popf   
}
   1008e:	90                   	nop
   1008f:	5d                   	pop    %bp
   10090:	c3                   	ret    

00010091 <cli>:

static inline void cli() {
   10091:	55                   	push   %bp
   10092:	89 e5                	mov    %sp,%bp
	__asm__ __volatile__("cli");
   10094:	fa                   	cli    
}
   10095:	90                   	nop
   10096:	5d                   	pop    %bp
   10097:	c3                   	ret    

00010098 <sti>:

static inline void sti() {
   10098:	55                   	push   %bp
   10099:	89 e5                	mov    %sp,%bp
	__asm__ __volatile__("sti");
   1009b:	fb                   	sti    
}
   1009c:	90                   	nop
   1009d:	5d                   	pop    %bp
   1009e:	c3                   	ret    

0001009f <irq_disable_global>:
#include "cpu.h"
#include "types.h"
#include "cpu_instr.h"


void irq_disable_global(void) {
   1009f:	55                   	push   %bp
   100a0:	89 e5                	mov    %sp,%bp
    cli();
   100a2:	e8 ea ff             	call   1008f <write_eflags+0x9>
   100a5:	ff                   	(bad)  
   100a6:	ff 90 5d c3          	call   *-0x3ca3(%bx,%si)

000100aa <irq_enable_global>:
}

void irq_enable_global(void) {
   100aa:	55                   	push   %bp
   100ab:	89 e5                	mov    %sp,%bp
    sti();
   100ad:	e8 e6 ff             	call   10096 <cli+0x5>
   100b0:	ff                   	(bad)  
   100b1:	ff 90 5d c3          	call   *-0x3ca3(%bx,%si)

000100b5 <irq_enter_protection>:
}

/**
 * @brief 进入中断保护
 */
irq_state_t irq_enter_protection (void) {
   100b5:	55                   	push   %bp
   100b6:	89 e5                	mov    %sp,%bp
   100b8:	83 ec 10             	sub    $0x10,%sp
    irq_state_t state = read_eflags();
   100bb:	e8 b6 ff             	call   10074 <kernel_init+0x56>
   100be:	ff                   	(bad)  
   100bf:	ff 89 45 fc          	decw   -0x3bb(%bx,%di)
    irq_disable_global();
   100c3:	e8 d7 ff             	call   1009d <sti+0x5>
   100c6:	ff                   	(bad)  
   100c7:	ff 8b 45 fc          	decw   -0x3bb(%bp,%di)
    return state;
}
   100cb:	c9                   	leave  
   100cc:	c3                   	ret    

000100cd <irq_leave_protection>:

/**
 * @brief 退出中断保护
 */
void irq_leave_protection (irq_state_t state) {
   100cd:	55                   	push   %bp
   100ce:	89 e5                	mov    %sp,%bp
    write_eflags(state);
   100d0:	ff 75 08             	push   0x8(%di)
   100d3:	e8 ae ff             	call   10084 <read_eflags+0xe>
   100d6:	ff                   	(bad)  
   100d7:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   100db:	90                   	nop
   100dc:	c9                   	leave  
   100dd:	c3                   	ret    

000100de <inb>:
static inline uint8_t inb(uint16_t  port) {
   100de:	55                   	push   %bp
   100df:	89 e5                	mov    %sp,%bp
   100e1:	83 ec 14             	sub    $0x14,%sp
   100e4:	8b 45 08             	mov    0x8(%di),%ax
   100e7:	66 89 45 ec          	mov    %eax,-0x14(%di)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
   100eb:	0f b7 45 ec          	movzww -0x14(%di),%ax
   100ef:	89 c2                	mov    %ax,%dx
   100f1:	ec                   	in     (%dx),%al
   100f2:	88 45 ff             	mov    %al,-0x1(%di)
	return rv;
   100f5:	0f b6 45 ff          	movzbw -0x1(%di),%ax
}
   100f9:	c9                   	leave  
   100fa:	c3                   	ret    

000100fb <outb>:
static inline void outb(uint16_t port, uint8_t data) {
   100fb:	55                   	push   %bp
   100fc:	89 e5                	mov    %sp,%bp
   100fe:	83 ec 08             	sub    $0x8,%sp
   10101:	8b 45 08             	mov    0x8(%di),%ax
   10104:	8b 55 0c             	mov    0xc(%di),%dx
   10107:	66 89 45 fc          	mov    %eax,-0x4(%di)
   1010b:	89 d0                	mov    %dx,%ax
   1010d:	88 45 f8             	mov    %al,-0x8(%di)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   10110:	0f b7 55 fc          	movzww -0x4(%di),%dx
   10114:	0f b6 45 f8          	movzbw -0x8(%di),%ax
   10118:	ee                   	out    %al,(%dx)
}
   10119:	90                   	nop
   1011a:	c9                   	leave  
   1011b:	c3                   	ret    

0001011c <read_cmos>:
#include "rtc.h"
#define CMOS_ADDRESS 0x70
#define CMOS_DATA    0x71

// 使用 inb 和 outb 函数从 CMOS 读取指定寄存器的值
static inline uint8_t read_cmos(uint8_t reg) {
   1011c:	55                   	push   %bp
   1011d:	89 e5                	mov    %sp,%bp
   1011f:	83 ec 04             	sub    $0x4,%sp
   10122:	8b 45 08             	mov    0x8(%di),%ax
   10125:	88 45 fc             	mov    %al,-0x4(%di)
    outb(CMOS_ADDRESS, reg);          // 设置寄存器地址
   10128:	0f b6 45 fc          	movzbw -0x4(%di),%ax
   1012c:	50                   	push   %ax
   1012d:	6a 70                	push   $0x70
   1012f:	e8 c7 ff             	call   100f9 <inb+0x1b>
   10132:	ff                   	(bad)  
   10133:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    return inb(CMOS_DATA);            // 从 CMOS 数据端口读取数据
   10137:	6a 71                	push   $0x71
   10139:	e8 a0 ff             	call   100dc <irq_leave_protection+0xf>
   1013c:	ff                   	(bad)  
   1013d:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
}
   10141:	c9                   	leave  
   10142:	c3                   	ret    

00010143 <time_init>:
#define BCD_TO_BIN(val) ((val) = ((val) & 0x0F) + ((val) >> 4) * 10)

time_t startup_time;

void time_init(void)
{
   10143:	55                   	push   %bp
   10144:	89 e5                	mov    %sp,%bp
   10146:	53                   	push   %bx
   10147:	83 ec 34             	sub    $0x34,%sp
    tm_t time;

    do {
        time.tm_sec = read_cmos(0x00);    // 秒
   1014a:	6a 00                	push   $0x0
   1014c:	e8 cb ff             	call   1011a <outb+0x1f>
   1014f:	ff                   	(bad)  
   10150:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   10154:	0f b6 c0             	movzbw %al,%ax
   10157:	89 45 d4             	mov    %ax,-0x2c(%di)
        time.tm_min = read_cmos(0x02);    // 分钟
   1015a:	6a 02                	push   $0x2
   1015c:	e8 bb ff             	call   1011a <outb+0x1f>
   1015f:	ff                   	(bad)  
   10160:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   10164:	0f b6 c0             	movzbw %al,%ax
   10167:	89 45 d8             	mov    %ax,-0x28(%di)
        time.tm_hour = read_cmos(0x04);   // 小时
   1016a:	6a 04                	push   $0x4
   1016c:	e8 ab ff             	call   1011a <outb+0x1f>
   1016f:	ff                   	(bad)  
   10170:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   10174:	0f b6 c0             	movzbw %al,%ax
   10177:	89 45 dc             	mov    %ax,-0x24(%di)
        time.tm_mday = read_cmos(0x07);   // 日
   1017a:	6a 07                	push   $0x7
   1017c:	e8 9b ff             	call   1011a <outb+0x1f>
   1017f:	ff                   	(bad)  
   10180:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   10184:	0f b6 c0             	movzbw %al,%ax
   10187:	89 45 e0             	mov    %ax,-0x20(%di)
        time.tm_mon = read_cmos(0x08);    // 月
   1018a:	6a 08                	push   $0x8
   1018c:	e8 8b ff             	call   1011a <outb+0x1f>
   1018f:	ff                   	(bad)  
   10190:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   10194:	0f b6 c0             	movzbw %al,%ax
   10197:	89 45 e4             	mov    %ax,-0x1c(%di)
        time.tm_year = read_cmos(0x09);   // 年
   1019a:	6a 09                	push   $0x9
   1019c:	e8 7b ff             	call   1011a <outb+0x1f>
   1019f:	ff                   	(bad)  
   101a0:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   101a4:	0f b6 c0             	movzbw %al,%ax
   101a7:	89 45 e8             	mov    %ax,-0x18(%di)
    } while (time.tm_sec != read_cmos(0x00));  // 再次读取秒，确保数据一致性
   101aa:	8b 5d d4             	mov    -0x2c(%di),%bx
   101ad:	6a 00                	push   $0x0
   101af:	e8 68 ff             	call   1011a <outb+0x1f>
   101b2:	ff                   	(bad)  
   101b3:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   101b7:	0f b6 c0             	movzbw %al,%ax
   101ba:	39 c3                	cmp    %ax,%bx
   101bc:	75 8c                	jne    1014a <time_init+0x7>

    // 将 BCD 编码转换为二进制
    BCD_TO_BIN(time.tm_sec);
   101be:	8b 45 d4             	mov    -0x2c(%di),%ax
   101c1:	83 e0 0f             	and    $0xf,%ax
   101c4:	89 c1                	mov    %ax,%cx
   101c6:	8b 45 d4             	mov    -0x2c(%di),%ax
   101c9:	c1 f8 04             	sar    $0x4,%ax
   101cc:	89 c2                	mov    %ax,%dx
   101ce:	89 d0                	mov    %dx,%ax
   101d0:	c1 e0 02             	shl    $0x2,%ax
   101d3:	01 d0                	add    %dx,%ax
   101d5:	01 c0                	add    %ax,%ax
   101d7:	01 c8                	add    %cx,%ax
   101d9:	89 45 d4             	mov    %ax,-0x2c(%di)
    BCD_TO_BIN(time.tm_min);
   101dc:	8b 45 d8             	mov    -0x28(%di),%ax
   101df:	83 e0 0f             	and    $0xf,%ax
   101e2:	89 c1                	mov    %ax,%cx
   101e4:	8b 45 d8             	mov    -0x28(%di),%ax
   101e7:	c1 f8 04             	sar    $0x4,%ax
   101ea:	89 c2                	mov    %ax,%dx
   101ec:	89 d0                	mov    %dx,%ax
   101ee:	c1 e0 02             	shl    $0x2,%ax
   101f1:	01 d0                	add    %dx,%ax
   101f3:	01 c0                	add    %ax,%ax
   101f5:	01 c8                	add    %cx,%ax
   101f7:	89 45 d8             	mov    %ax,-0x28(%di)
    BCD_TO_BIN(time.tm_hour);
   101fa:	8b 45 dc             	mov    -0x24(%di),%ax
   101fd:	83 e0 0f             	and    $0xf,%ax
   10200:	89 c1                	mov    %ax,%cx
   10202:	8b 45 dc             	mov    -0x24(%di),%ax
   10205:	c1 f8 04             	sar    $0x4,%ax
   10208:	89 c2                	mov    %ax,%dx
   1020a:	89 d0                	mov    %dx,%ax
   1020c:	c1 e0 02             	shl    $0x2,%ax
   1020f:	01 d0                	add    %dx,%ax
   10211:	01 c0                	add    %ax,%ax
   10213:	01 c8                	add    %cx,%ax
   10215:	89 45 dc             	mov    %ax,-0x24(%di)
    BCD_TO_BIN(time.tm_mday);
   10218:	8b 45 e0             	mov    -0x20(%di),%ax
   1021b:	83 e0 0f             	and    $0xf,%ax
   1021e:	89 c1                	mov    %ax,%cx
   10220:	8b 45 e0             	mov    -0x20(%di),%ax
   10223:	c1 f8 04             	sar    $0x4,%ax
   10226:	89 c2                	mov    %ax,%dx
   10228:	89 d0                	mov    %dx,%ax
   1022a:	c1 e0 02             	shl    $0x2,%ax
   1022d:	01 d0                	add    %dx,%ax
   1022f:	01 c0                	add    %ax,%ax
   10231:	01 c8                	add    %cx,%ax
   10233:	89 45 e0             	mov    %ax,-0x20(%di)
    BCD_TO_BIN(time.tm_mon);
   10236:	8b 45 e4             	mov    -0x1c(%di),%ax
   10239:	83 e0 0f             	and    $0xf,%ax
   1023c:	89 c1                	mov    %ax,%cx
   1023e:	8b 45 e4             	mov    -0x1c(%di),%ax
   10241:	c1 f8 04             	sar    $0x4,%ax
   10244:	89 c2                	mov    %ax,%dx
   10246:	89 d0                	mov    %dx,%ax
   10248:	c1 e0 02             	shl    $0x2,%ax
   1024b:	01 d0                	add    %dx,%ax
   1024d:	01 c0                	add    %ax,%ax
   1024f:	01 c8                	add    %cx,%ax
   10251:	89 45 e4             	mov    %ax,-0x1c(%di)
    BCD_TO_BIN(time.tm_year);
   10254:	8b 45 e8             	mov    -0x18(%di),%ax
   10257:	83 e0 0f             	and    $0xf,%ax
   1025a:	89 c1                	mov    %ax,%cx
   1025c:	8b 45 e8             	mov    -0x18(%di),%ax
   1025f:	c1 f8 04             	sar    $0x4,%ax
   10262:	89 c2                	mov    %ax,%dx
   10264:	89 d0                	mov    %dx,%ax
   10266:	c1 e0 02             	shl    $0x2,%ax
   10269:	01 d0                	add    %dx,%ax
   1026b:	01 c0                	add    %ax,%ax
   1026d:	01 c8                	add    %cx,%ax
   1026f:	89 45 e8             	mov    %ax,-0x18(%di)

    time.tm_mon--;  // 月份从 0 开始
   10272:	8b 45 e4             	mov    -0x1c(%di),%ax
   10275:	83 e8 01             	sub    $0x1,%ax
   10278:	89 45 e4             	mov    %ax,-0x1c(%di)
    startup_time = kernel_mktime(&time);  // 将时间转换为 UNIX 时间戳
   1027b:	83 ec 0c             	sub    $0xc,%sp
   1027e:	8d 45 d4             	lea    -0x2c(%di),%ax
   10281:	50                   	push   %ax
   10282:	e8 a3 06             	call   10928 <is_leap_year+0x62>
   10285:	00 00                	add    %al,(%bx,%si)
   10287:	83 c4 10             	add    $0x10,%sp
   1028a:	a3 e4 20             	mov    %ax,0x20e4
   1028d:	01 00                	add    %ax,(%bx,%si)
    //localtime(&test,startup_time);
    return;
   1028f:	90                   	nop
    
   10290:	8b 5d fc             	mov    -0x4(%di),%bx
   10293:	c9                   	leave  
   10294:	c3                   	ret    

00010295 <inb>:
static inline uint8_t inb(uint16_t  port) {
   10295:	55                   	push   %bp
   10296:	89 e5                	mov    %sp,%bp
   10298:	83 ec 14             	sub    $0x14,%sp
   1029b:	8b 45 08             	mov    0x8(%di),%ax
   1029e:	66 89 45 ec          	mov    %eax,-0x14(%di)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
   102a2:	0f b7 45 ec          	movzww -0x14(%di),%ax
   102a6:	89 c2                	mov    %ax,%dx
   102a8:	ec                   	in     (%dx),%al
   102a9:	88 45 ff             	mov    %al,-0x1(%di)
	return rv;
   102ac:	0f b6 45 ff          	movzbw -0x1(%di),%ax
}
   102b0:	c9                   	leave  
   102b1:	c3                   	ret    

000102b2 <outb>:
static inline void outb(uint16_t port, uint8_t data) {
   102b2:	55                   	push   %bp
   102b3:	89 e5                	mov    %sp,%bp
   102b5:	83 ec 08             	sub    $0x8,%sp
   102b8:	8b 45 08             	mov    0x8(%di),%ax
   102bb:	8b 55 0c             	mov    0xc(%di),%dx
   102be:	66 89 45 fc          	mov    %eax,-0x4(%di)
   102c2:	89 d0                	mov    %dx,%ax
   102c4:	88 45 f8             	mov    %al,-0x8(%di)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   102c7:	0f b7 55 fc          	movzww -0x4(%di),%dx
   102cb:	0f b6 45 f8          	movzbw -0x8(%di),%ax
   102cf:	ee                   	out    %al,(%dx)
}
   102d0:	90                   	nop
   102d1:	c9                   	leave  
   102d2:	c3                   	ret    

000102d3 <rs232_init>:
#include "serial.h"

#define COM1_PORT           0x3F8       // RS232端口0初始化
void rs232_init(void)
{
   102d3:	55                   	push   %bp
   102d4:	89 e5                	mov    %sp,%bp
    outb(COM1_PORT + 1, 0x00);    // Disable all interrupts
   102d6:	6a 00                	push   $0x0
   102d8:	68 f9 03             	push   $0x3f9
   102db:	00 00                	add    %al,(%bx,%si)
   102dd:	e8 d0 ff             	call   102b0 <inb+0x1b>
   102e0:	ff                   	(bad)  
   102e1:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(COM1_PORT + 3, 0x80);    // Enable DLAB (set baud rate divisor)
   102e5:	68 80 00             	push   $0x80
   102e8:	00 00                	add    %al,(%bx,%si)
   102ea:	68 fb 03             	push   $0x3fb
   102ed:	00 00                	add    %al,(%bx,%si)
   102ef:	e8 be ff             	call   102b0 <inb+0x1b>
   102f2:	ff                   	(bad)  
   102f3:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(COM1_PORT + 0, 0x03);    // Set divisor to 3 (lo byte) 38400 baud
   102f7:	6a 03                	push   $0x3
   102f9:	68 f8 03             	push   $0x3f8
   102fc:	00 00                	add    %al,(%bx,%si)
   102fe:	e8 af ff             	call   102b0 <inb+0x1b>
   10301:	ff                   	(bad)  
   10302:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(COM1_PORT + 1, 0x00);    //                  (hi byte)
   10306:	6a 00                	push   $0x0
   10308:	68 f9 03             	push   $0x3f9
   1030b:	00 00                	add    %al,(%bx,%si)
   1030d:	e8 a0 ff             	call   102b0 <inb+0x1b>
   10310:	ff                   	(bad)  
   10311:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(COM1_PORT + 3, 0x03);    // 8 bits, no parity, one stop bit
   10315:	6a 03                	push   $0x3
   10317:	68 fb 03             	push   $0x3fb
   1031a:	00 00                	add    %al,(%bx,%si)
   1031c:	e8 91 ff             	call   102b0 <inb+0x1b>
   1031f:	ff                   	(bad)  
   10320:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(COM1_PORT + 2, 0xC7);    // Enable FIFO, clear them, with 14-byte threshold
   10324:	68 c7 00             	push   $0xc7
   10327:	00 00                	add    %al,(%bx,%si)
   10329:	68 fa 03             	push   $0x3fa
   1032c:	00 00                	add    %al,(%bx,%si)
   1032e:	e8 7f ff             	call   102b0 <inb+0x1b>
   10331:	ff                   	(bad)  
   10332:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
  
    // If serial is not faulty set it in normal operation mode
    // (not-loopback with IRQs enabled and OUT#1 and OUT#2 bits enabled)
    outb(COM1_PORT + 4, 0x0F);
   10336:	6a 0f                	push   $0xf
   10338:	68 fc 03             	push   $0x3fc
   1033b:	00 00                	add    %al,(%bx,%si)
   1033d:	e8 70 ff             	call   102b0 <inb+0x1b>
   10340:	ff                   	(bad)  
   10341:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
}
   10345:	90                   	nop
   10346:	c9                   	leave  
   10347:	c3                   	ret    

00010348 <serial_printf>:


/**
 * @brief 日志打印
 */
void serial_printf(const char * str_buf) {
   10348:	55                   	push   %bp
   10349:	89 e5                	mov    %sp,%bp
   1034b:	83 ec 18             	sub    $0x18,%sp
    const char * p = str_buf;   
   1034e:	8b 45 08             	mov    0x8(%di),%ax
   10351:	89 45 f4             	mov    %ax,-0xc(%di)
    irq_state_t state =  irq_enter_protection(); 
   10354:	e8 5c fd             	call   100b3 <irq_enable_global+0x9>
   10357:	ff                   	(bad)  
   10358:	ff 89 45 f0          	decw   -0xfbb(%bx,%di)
    while (*p != '\0') {
   1035c:	eb 3b                	jmp    10399 <serial_printf+0x51>
        while ((inb(COM1_PORT + 5) & (1 << 6)) == 0);
   1035e:	90                   	nop
   1035f:	83 ec 0c             	sub    $0xc,%sp
   10362:	68 fd 03             	push   $0x3fd
   10365:	00 00                	add    %al,(%bx,%si)
   10367:	e8 29 ff             	call   10293 <time_init+0x150>
   1036a:	ff                   	(bad)  
   1036b:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
   1036f:	0f b6 c0             	movzbw %al,%ax
   10372:	83 e0 40             	and    $0x40,%ax
   10375:	85 c0                	test   %ax,%ax
   10377:	74 e6                	je     1035f <serial_printf+0x17>
        outb(COM1_PORT, *p++);
   10379:	8b 45 f4             	mov    -0xc(%di),%ax
   1037c:	8d 50 01             	lea    0x1(%bx,%si),%dx
   1037f:	89 55 f4             	mov    %dx,-0xc(%di)
   10382:	0f b6 00             	movzbw (%bx,%si),%ax
   10385:	0f b6 c0             	movzbw %al,%ax
   10388:	83 ec 08             	sub    $0x8,%sp
   1038b:	50                   	push   %ax
   1038c:	68 f8 03             	push   $0x3f8
   1038f:	00 00                	add    %al,(%bx,%si)
   10391:	e8 1c ff             	call   102b0 <inb+0x1b>
   10394:	ff                   	(bad)  
   10395:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    while (*p != '\0') {
   10399:	8b 45 f4             	mov    -0xc(%di),%ax
   1039c:	0f b6 00             	movzbw (%bx,%si),%ax
   1039f:	84 c0                	test   %al,%al
   103a1:	75 bb                	jne    1035e <serial_printf+0x16>
    }
    irq_leave_protection(state);
   103a3:	83 ec 0c             	sub    $0xc,%sp
   103a6:	ff 75 f0             	push   -0x10(%di)
   103a9:	e8 1f fd             	call   100cb <irq_enter_protection+0x16>
   103ac:	ff                   	(bad)  
   103ad:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
   103b1:	90                   	nop
   103b2:	c9                   	leave  
   103b3:	c3                   	ret    

000103b4 <hlt>:
static inline void hlt(void) {
   103b4:	55                   	push   %bp
   103b5:	89 e5                	mov    %sp,%bp
    __asm__ __volatile__("hlt");
   103b7:	f4                   	hlt    
}
   103b8:	90                   	nop
   103b9:	5d                   	pop    %bp
   103ba:	c3                   	ret    

000103bb <dbg_print>:

#define MAX_STR_BUF_SIZE 256
/**
 * @brief 格式化日志并打印到串口（使用 sprintf 和 vsprintf）
 */
void dbg_print(int level,const char *file, const char *func, int line, const char *fmt, ...) {
   103bb:	55                   	push   %bp
   103bc:	89 e5                	mov    %sp,%bp
   103be:	81 ec 18 01          	sub    $0x118,%sp
   103c2:	00 00                	add    %al,(%bx,%si)
    if(level > DBG_LEVEL_CTL_SET)
   103c4:	83 7d 08 03          	cmpw   $0x3,0x8(%di)
   103c8:	0f 8f 97 00          	jg     10463 <dbg_print+0xa8>
   103cc:	00 00                	add    %al,(%bx,%si)

    char str_buf[MAX_STR_BUF_SIZE];
    va_list args;

    // 清空缓冲区
    memset(str_buf, '\0', sizeof(str_buf));
   103ce:	83 ec 04             	sub    $0x4,%sp
   103d1:	68 00 01             	push   $0x100
   103d4:	00 00                	add    %al,(%bx,%si)
   103d6:	6a 00                	push   $0x0
   103d8:	8d 85 f4 fe          	lea    -0x10c(%di),%ax
   103dc:	ff                   	(bad)  
   103dd:	ff 50 e8             	call   *-0x18(%bx,%si)
   103e0:	24 02                	and    $0x2,%al
   103e2:	00 00                	add    %al,(%bx,%si)
   103e4:	83 c4 10             	add    $0x10,%sp

    // 组装文件、函数和行号信息
    sprintf(str_buf, "[%s] in file:%s, func:%s, line:%d: ", title[level],file, func, line);
   103e7:	8b 45 08             	mov    0x8(%di),%ax
   103ea:	8b 04                	mov    (%si),%ax
   103ec:	85 d0                	test   %dx,%ax
   103ee:	20 01                	and    %al,(%bx,%di)
   103f0:	00 83 ec 08          	add    %al,0x8ec(%bp,%di)
   103f4:	ff 75 14             	push   0x14(%di)
   103f7:	ff 75 10             	push   0x10(%di)
   103fa:	ff 75 0c             	push   0xc(%di)
   103fd:	50                   	push   %ax
   103fe:	68 34 10             	push   $0x1034
   10401:	01 00                	add    %ax,(%bx,%si)
   10403:	8d 85 f4 fe          	lea    -0x10c(%di),%ax
   10407:	ff                   	(bad)  
   10408:	ff 50 e8             	call   *-0x18(%bx,%si)
   1040b:	6b 03 00             	imul   $0x0,(%bp,%di),%ax
   1040e:	00 83 c4 20          	add    %al,0x20c4(%bp,%di)
    int offset = strlen(str_buf);
   10412:	83 ec 0c             	sub    $0xc,%sp
   10415:	8d 85 f4 fe          	lea    -0x10c(%di),%ax
   10419:	ff                   	(bad)  
   1041a:	ff 50 e8             	call   *-0x18(%bx,%si)
   1041d:	80 01 00             	addb   $0x0,(%bx,%di)
   10420:	00 83 c4 10          	add    %al,0x10c4(%bp,%di)
   10424:	89 45 f4             	mov    %ax,-0xc(%di)

    // 格式化日志信息
    va_start(args, fmt);
   10427:	8d 45 1c             	lea    0x1c(%di),%ax
   1042a:	89 85 f0 fe          	mov    %ax,-0x110(%di)
   1042e:	ff                   	(bad)  
   1042f:	ff 8b 85 f0          	decw   -0xf7b(%bp,%di)
    vsprintf(str_buf + offset, fmt, args);
   10433:	fe                   	(bad)  
   10434:	ff                   	(bad)  
   10435:	ff 8b 55 f4          	decw   -0xbab(%bp,%di)
   10439:	8d 8d f4 fe          	lea    -0x10c(%di),%cx
   1043d:	ff                   	(bad)  
   1043e:	ff 01                	incw   (%bx,%di)
   10440:	ca 83 ec             	lret   $0xec83
   10443:	04 50                	add    $0x50,%al
   10445:	ff 75 18             	push   0x18(%di)
   10448:	52                   	push   %dx
   10449:	e8 50 03             	call   1079c <sprintf+0x22>
   1044c:	00 00                	add    %al,(%bx,%si)
   1044e:	83 c4 10             	add    $0x10,%sp
    va_end(args);

    // 检查调试输出标志是否启用
    #ifdef DBG_OUTPUT_SERIAL
        serial_printf(str_buf);
   10451:	83 ec 0c             	sub    $0xc,%sp
   10454:	8d 85 f4 fe          	lea    -0x10c(%di),%ax
   10458:	ff                   	(bad)  
   10459:	ff 50 e8             	call   *-0x18(%bx,%si)
   1045c:	e8 fe ff             	call   1045d <dbg_print+0xa2>
   1045f:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
   10463:	eb 01                	jmp    10466 <dbg_print+0xab>
        return;
   10465:	90                   	nop
    #elif DBG_OUTPUT_TTY

    #else

    #endif
}
   10466:	c9                   	leave  
   10467:	c3                   	ret    

00010468 <panic>:


void panic (const char * file, int line, const char * func, const char * cond) {
   10468:	55                   	push   %bp
   10469:	89 e5                	mov    %sp,%bp
   1046b:	81 ec 08 01          	sub    $0x108,%sp
   1046f:	00 00                	add    %al,(%bx,%si)
    char str_buf[MAX_STR_BUF_SIZE];

    sprintf(str_buf, "[assert] in file:%s, func:%s, line:%d: %s", file, func, line,cond);
   10471:	83 ec 08             	sub    $0x8,%sp
   10474:	ff 75 14             	push   0x14(%di)
   10477:	ff 75 0c             	push   0xc(%di)
   1047a:	ff 75 10             	push   0x10(%di)
   1047d:	ff 75 08             	push   0x8(%di)
   10480:	68 58 10             	push   $0x1058
   10483:	01 00                	add    %ax,(%bx,%si)
   10485:	8d 85 f8 fe          	lea    -0x108(%di),%ax
   10489:	ff                   	(bad)  
   1048a:	ff 50 e8             	call   *-0x18(%bx,%si)
   1048d:	e9 02 00             	jmp    10492 <panic+0x2a>
   10490:	00 83 c4 20          	add    %al,0x20c4(%bp,%di)
    // 检查调试输出标志是否启用
    #ifdef DBG_OUTPUT_SERIAL
        serial_printf(str_buf);
   10494:	83 ec 0c             	sub    $0xc,%sp
   10497:	8d 85 f8 fe          	lea    -0x108(%di),%ax
   1049b:	ff                   	(bad)  
   1049c:	ff 50 e8             	call   *-0x18(%bx,%si)
   1049f:	a5                   	movsw  %ds:(%si),%es:(%di)
   104a0:	fe                   	(bad)  
   104a1:	ff                   	(bad)  
   104a2:	ff 83 c4 10          	incw   0x10c4(%bp,%di)

    #else

    #endif
    for (;;) {
        hlt();
   104a6:	e8 09 ff             	call   103b2 <serial_printf+0x6a>
   104a9:	ff                   	(bad)  
   104aa:	ff                   	(bad)  
   104ab:	eb f9                	jmp    104a6 <panic+0x3e>

000104ad <strcpy>:
#include "string.h"
#include "types.h"
#include <stdarg.h>

// 字符串拷贝函数 strcpy
void strcpy(char *dest, const char *src) {
   104ad:	55                   	push   %bp
   104ae:	89 e5                	mov    %sp,%bp
    while ((*dest++ = *src++));
   104b0:	90                   	nop
   104b1:	8b 55 0c             	mov    0xc(%di),%dx
   104b4:	8d 42 01             	lea    0x1(%bp,%si),%ax
   104b7:	89 45 0c             	mov    %ax,0xc(%di)
   104ba:	8b 45 08             	mov    0x8(%di),%ax
   104bd:	8d 48 01             	lea    0x1(%bx,%si),%cx
   104c0:	89 4d 08             	mov    %cx,0x8(%di)
   104c3:	0f b6 12             	movzbw (%bp,%si),%dx
   104c6:	88 10                	mov    %dl,(%bx,%si)
   104c8:	0f b6 00             	movzbw (%bx,%si),%ax
   104cb:	84 c0                	test   %al,%al
   104cd:	75 e2                	jne    104b1 <strcpy+0x4>
}
   104cf:	90                   	nop
   104d0:	90                   	nop
   104d1:	5d                   	pop    %bp
   104d2:	c3                   	ret    

000104d3 <strncpy>:

// 有限长度字符串拷贝函数 strncpy
void strncpy(char *dest, const char *src, int size) {
   104d3:	55                   	push   %bp
   104d4:	89 e5                	mov    %sp,%bp
   104d6:	83 ec 10             	sub    $0x10,%sp
    int i;
    for (i = 0; i < size && src[i] != '\0'; i++) {
   104d9:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
   104de:	00 00                	add    %al,(%bx,%si)
   104e0:	eb 19                	jmp    104fb <strncpy+0x28>
        dest[i] = src[i];
   104e2:	8b 55 fc             	mov    -0x4(%di),%dx
   104e5:	8b 45 0c             	mov    0xc(%di),%ax
   104e8:	01 d0                	add    %dx,%ax
   104ea:	8b 4d fc             	mov    -0x4(%di),%cx
   104ed:	8b 55 08             	mov    0x8(%di),%dx
   104f0:	01 ca                	add    %cx,%dx
   104f2:	0f b6 00             	movzbw (%bx,%si),%ax
   104f5:	88 02                	mov    %al,(%bp,%si)
    for (i = 0; i < size && src[i] != '\0'; i++) {
   104f7:	83 45 fc 01          	addw   $0x1,-0x4(%di)
   104fb:	8b 45 fc             	mov    -0x4(%di),%ax
   104fe:	3b 45 10             	cmp    0x10(%di),%ax
   10501:	7d 20                	jge    10523 <strncpy+0x50>
   10503:	8b 55 fc             	mov    -0x4(%di),%dx
   10506:	8b 45 0c             	mov    0xc(%di),%ax
   10509:	01 d0                	add    %dx,%ax
   1050b:	0f b6 00             	movzbw (%bx,%si),%ax
   1050e:	84 c0                	test   %al,%al
   10510:	75 d0                	jne    104e2 <strncpy+0xf>
    }
    for (; i < size; i++) {
   10512:	eb 0f                	jmp    10523 <strncpy+0x50>
        dest[i] = '\0';
   10514:	8b 55 fc             	mov    -0x4(%di),%dx
   10517:	8b 45 08             	mov    0x8(%di),%ax
   1051a:	01 d0                	add    %dx,%ax
   1051c:	c6 00 00             	movb   $0x0,(%bx,%si)
    for (; i < size; i++) {
   1051f:	83 45 fc 01          	addw   $0x1,-0x4(%di)
   10523:	8b 45 fc             	mov    -0x4(%di),%ax
   10526:	3b 45 10             	cmp    0x10(%di),%ax
   10529:	7c e9                	jl     10514 <strncpy+0x41>
    }
}
   1052b:	90                   	nop
   1052c:	90                   	nop
   1052d:	c9                   	leave  
   1052e:	c3                   	ret    

0001052f <strncmp>:

// 有限长度字符串比较函数 strncmp
int strncmp(const char *s1, const char *s2, int size) {
   1052f:	55                   	push   %bp
   10530:	89 e5                	mov    %sp,%bp
   10532:	83 ec 10             	sub    $0x10,%sp
    for (int i = 0; i < size; i++) {
   10535:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
   1053a:	00 00                	add    %al,(%bx,%si)
   1053c:	eb 54                	jmp    10592 <strncmp+0x63>
        if (s1[i] != s2[i]) {
   1053e:	8b 55 fc             	mov    -0x4(%di),%dx
   10541:	8b 45 08             	mov    0x8(%di),%ax
   10544:	01 d0                	add    %dx,%ax
   10546:	0f b6 10             	movzbw (%bx,%si),%dx
   10549:	8b 4d fc             	mov    -0x4(%di),%cx
   1054c:	8b 45 0c             	mov    0xc(%di),%ax
   1054f:	01 c8                	add    %cx,%ax
   10551:	0f b6 00             	movzbw (%bx,%si),%ax
   10554:	38 c2                	cmp    %al,%dl
   10556:	74 20                	je     10578 <strncmp+0x49>
            return (unsigned char)s1[i] - (unsigned char)s2[i];
   10558:	8b 55 fc             	mov    -0x4(%di),%dx
   1055b:	8b 45 08             	mov    0x8(%di),%ax
   1055e:	01 d0                	add    %dx,%ax
   10560:	0f b6 00             	movzbw (%bx,%si),%ax
   10563:	0f b6 c0             	movzbw %al,%ax
   10566:	8b 4d fc             	mov    -0x4(%di),%cx
   10569:	8b 55 0c             	mov    0xc(%di),%dx
   1056c:	01 ca                	add    %cx,%dx
   1056e:	0f b6 12             	movzbw (%bp,%si),%dx
   10571:	0f b6 d2             	movzbw %dl,%dx
   10574:	29 d0                	sub    %dx,%ax
   10576:	eb 27                	jmp    1059f <strncmp+0x70>
        }
        if (s1[i] == '\0') {
   10578:	8b 55 fc             	mov    -0x4(%di),%dx
   1057b:	8b 45 08             	mov    0x8(%di),%ax
   1057e:	01 d0                	add    %dx,%ax
   10580:	0f b6 00             	movzbw (%bx,%si),%ax
   10583:	84 c0                	test   %al,%al
   10585:	75 07                	jne    1058e <strncmp+0x5f>
            return 0;
   10587:	b8 00 00             	mov    $0x0,%ax
   1058a:	00 00                	add    %al,(%bx,%si)
   1058c:	eb 11                	jmp    1059f <strncmp+0x70>
    for (int i = 0; i < size; i++) {
   1058e:	83 45 fc 01          	addw   $0x1,-0x4(%di)
   10592:	8b 45 fc             	mov    -0x4(%di),%ax
   10595:	3b 45 10             	cmp    0x10(%di),%ax
   10598:	7c a4                	jl     1053e <strncmp+0xf>
        }
    }
    return 0;
   1059a:	b8 00 00             	mov    $0x0,%ax
   1059d:	00 00                	add    %al,(%bx,%si)
}
   1059f:	c9                   	leave  
   105a0:	c3                   	ret    

000105a1 <strlen>:

// 字符串长度函数 strlen
int strlen(const char *str) {
   105a1:	55                   	push   %bp
   105a2:	89 e5                	mov    %sp,%bp
   105a4:	83 ec 10             	sub    $0x10,%sp
    int len = 0;
   105a7:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
   105ac:	00 00                	add    %al,(%bx,%si)
    while (str[len] != '\0') {
   105ae:	eb 04                	jmp    105b4 <strlen+0x13>
        len++;
   105b0:	83 45 fc 01          	addw   $0x1,-0x4(%di)
    while (str[len] != '\0') {
   105b4:	8b 55 fc             	mov    -0x4(%di),%dx
   105b7:	8b 45 08             	mov    0x8(%di),%ax
   105ba:	01 d0                	add    %dx,%ax
   105bc:	0f b6 00             	movzbw (%bx,%si),%ax
   105bf:	84 c0                	test   %al,%al
   105c1:	75 ed                	jne    105b0 <strlen+0xf>
    }
    return len;
   105c3:	8b 45 fc             	mov    -0x4(%di),%ax
}
   105c6:	c9                   	leave  
   105c7:	c3                   	ret    

000105c8 <memcpy>:

// 内存拷贝函数 memcpy
void memcpy(void *dest, const void *src, int size) {
   105c8:	55                   	push   %bp
   105c9:	89 e5                	mov    %sp,%bp
   105cb:	83 ec 10             	sub    $0x10,%sp
    uint8_t *d = dest;
   105ce:	8b 45 08             	mov    0x8(%di),%ax
   105d1:	89 45 f8             	mov    %ax,-0x8(%di)
    const uint8_t *s = src;
   105d4:	8b 45 0c             	mov    0xc(%di),%ax
   105d7:	89 45 f4             	mov    %ax,-0xc(%di)
    for (int i = 0; i < size; i++) {
   105da:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
   105df:	00 00                	add    %al,(%bx,%si)
   105e1:	eb 19                	jmp    105fc <memcpy+0x34>
        d[i] = s[i];
   105e3:	8b 55 fc             	mov    -0x4(%di),%dx
   105e6:	8b 45 f4             	mov    -0xc(%di),%ax
   105e9:	01 d0                	add    %dx,%ax
   105eb:	8b 4d fc             	mov    -0x4(%di),%cx
   105ee:	8b 55 f8             	mov    -0x8(%di),%dx
   105f1:	01 ca                	add    %cx,%dx
   105f3:	0f b6 00             	movzbw (%bx,%si),%ax
   105f6:	88 02                	mov    %al,(%bp,%si)
    for (int i = 0; i < size; i++) {
   105f8:	83 45 fc 01          	addw   $0x1,-0x4(%di)
   105fc:	8b 45 fc             	mov    -0x4(%di),%ax
   105ff:	3b 45 10             	cmp    0x10(%di),%ax
   10602:	7c df                	jl     105e3 <memcpy+0x1b>
    }
}
   10604:	90                   	nop
   10605:	90                   	nop
   10606:	c9                   	leave  
   10607:	c3                   	ret    

00010608 <memset>:

// 内存填充函数 memset
void memset(void *dest, uint8_t v, int size) {
   10608:	55                   	push   %bp
   10609:	89 e5                	mov    %sp,%bp
   1060b:	83 ec 14             	sub    $0x14,%sp
   1060e:	8b 45 0c             	mov    0xc(%di),%ax
   10611:	88 45 ec             	mov    %al,-0x14(%di)
    uint8_t *d = dest;
   10614:	8b 45 08             	mov    0x8(%di),%ax
   10617:	89 45 f8             	mov    %ax,-0x8(%di)
    for (int i = 0; i < size; i++) {
   1061a:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
   1061f:	00 00                	add    %al,(%bx,%si)
   10621:	eb 12                	jmp    10635 <memset+0x2d>
        d[i] = v;
   10623:	8b 55 fc             	mov    -0x4(%di),%dx
   10626:	8b 45 f8             	mov    -0x8(%di),%ax
   10629:	01 c2                	add    %ax,%dx
   1062b:	0f b6 45 ec          	movzbw -0x14(%di),%ax
   1062f:	88 02                	mov    %al,(%bp,%si)
    for (int i = 0; i < size; i++) {
   10631:	83 45 fc 01          	addw   $0x1,-0x4(%di)
   10635:	8b 45 fc             	mov    -0x4(%di),%ax
   10638:	3b 45 10             	cmp    0x10(%di),%ax
   1063b:	7c e6                	jl     10623 <memset+0x1b>
    }
}
   1063d:	90                   	nop
   1063e:	90                   	nop
   1063f:	c9                   	leave  
   10640:	c3                   	ret    

00010641 <memcmp>:

// 内存比较函数 memcmp
int memcmp(const void *d1, const void *d2, int size) {
   10641:	55                   	push   %bp
   10642:	89 e5                	mov    %sp,%bp
   10644:	83 ec 10             	sub    $0x10,%sp
    const uint8_t *s1 = d1;
   10647:	8b 45 08             	mov    0x8(%di),%ax
   1064a:	89 45 f8             	mov    %ax,-0x8(%di)
    const uint8_t *s2 = d2;
   1064d:	8b 45 0c             	mov    0xc(%di),%ax
   10650:	89 45 f4             	mov    %ax,-0xc(%di)
    for (int i = 0; i < size; i++) {
   10653:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
   10658:	00 00                	add    %al,(%bx,%si)
   1065a:	eb 3e                	jmp    1069a <memcmp+0x59>
        if (s1[i] != s2[i]) {
   1065c:	8b 55 fc             	mov    -0x4(%di),%dx
   1065f:	8b 45 f8             	mov    -0x8(%di),%ax
   10662:	01 d0                	add    %dx,%ax
   10664:	0f b6 10             	movzbw (%bx,%si),%dx
   10667:	8b 4d fc             	mov    -0x4(%di),%cx
   1066a:	8b 45 f4             	mov    -0xc(%di),%ax
   1066d:	01 c8                	add    %cx,%ax
   1066f:	0f b6 00             	movzbw (%bx,%si),%ax
   10672:	38 c2                	cmp    %al,%dl
   10674:	74 20                	je     10696 <memcmp+0x55>
            return s1[i] - s2[i];
   10676:	8b 55 fc             	mov    -0x4(%di),%dx
   10679:	8b 45 f8             	mov    -0x8(%di),%ax
   1067c:	01 d0                	add    %dx,%ax
   1067e:	0f b6 00             	movzbw (%bx,%si),%ax
   10681:	0f b6 c0             	movzbw %al,%ax
   10684:	8b 4d fc             	mov    -0x4(%di),%cx
   10687:	8b 55 f4             	mov    -0xc(%di),%dx
   1068a:	01 ca                	add    %cx,%dx
   1068c:	0f b6 12             	movzbw (%bp,%si),%dx
   1068f:	0f b6 d2             	movzbw %dl,%dx
   10692:	29 d0                	sub    %dx,%ax
   10694:	eb 11                	jmp    106a7 <memcmp+0x66>
    for (int i = 0; i < size; i++) {
   10696:	83 45 fc 01          	addw   $0x1,-0x4(%di)
   1069a:	8b 45 fc             	mov    -0x4(%di),%ax
   1069d:	3b 45 10             	cmp    0x10(%di),%ax
   106a0:	7c ba                	jl     1065c <memcmp+0x1b>
        }
    }
    return 0;
   106a2:	b8 00 00             	mov    $0x0,%ax
   106a5:	00 00                	add    %al,(%bx,%si)
}
   106a7:	c9                   	leave  
   106a8:	c3                   	ret    

000106a9 <itoa>:

// 整数转字符串函数 itoa
void itoa(char *buf, int num, int base) {
   106a9:	55                   	push   %bp
   106aa:	89 e5                	mov    %sp,%bp
   106ac:	83 ec 20             	sub    $0x20,%sp
    char *ptr = buf;
   106af:	8b 45 08             	mov    0x8(%di),%ax
   106b2:	89 45 fc             	mov    %ax,-0x4(%di)
    int is_negative = (num < 0 && base == 10);
   106b5:	83 7d 0c 00          	cmpw   $0x0,0xc(%di)
   106b9:	79 0d                	jns    106c8 <itoa+0x1f>
   106bb:	83 7d 10 0a          	cmpw   $0xa,0x10(%di)
   106bf:	75 07                	jne    106c8 <itoa+0x1f>
   106c1:	b8 01 00             	mov    $0x1,%ax
   106c4:	00 00                	add    %al,(%bx,%si)
   106c6:	eb 05                	jmp    106cd <itoa+0x24>
   106c8:	b8 00 00             	mov    $0x0,%ax
   106cb:	00 00                	add    %al,(%bx,%si)
   106cd:	89 45 ec             	mov    %ax,-0x14(%di)

    if (is_negative) {
   106d0:	83 7d ec 00          	cmpw   $0x0,-0x14(%di)
   106d4:	74 03                	je     106d9 <itoa+0x30>
        num = -num;
   106d6:	f7 5d 0c             	negw   0xc(%di)
    }

    int temp = num;
   106d9:	8b 45 0c             	mov    0xc(%di),%ax
   106dc:	89 45 f8             	mov    %ax,-0x8(%di)
    do {
        int remainder = temp % base;
   106df:	8b 45 f8             	mov    -0x8(%di),%ax
   106e2:	99                   	cwtd   
   106e3:	f7 7d 10             	idivw  0x10(%di)
   106e6:	89 55 e8             	mov    %dx,-0x18(%di)
        *ptr++ = (remainder > 9) ? (remainder - 10) + 'a' : remainder + '0';
   106e9:	83 7d e8 09          	cmpw   $0x9,-0x18(%di)
   106ed:	7e 0a                	jle    106f9 <itoa+0x50>
   106ef:	8b 45 e8             	mov    -0x18(%di),%ax
   106f2:	83 c0 57             	add    $0x57,%ax
   106f5:	89 c1                	mov    %ax,%cx
   106f7:	eb 08                	jmp    10701 <itoa+0x58>
   106f9:	8b 45 e8             	mov    -0x18(%di),%ax
   106fc:	83 c0 30             	add    $0x30,%ax
   106ff:	89 c1                	mov    %ax,%cx
   10701:	8b 45 fc             	mov    -0x4(%di),%ax
   10704:	8d 50 01             	lea    0x1(%bx,%si),%dx
   10707:	89 55 fc             	mov    %dx,-0x4(%di)
   1070a:	88 08                	mov    %cl,(%bx,%si)
    } while (temp /= base);
   1070c:	8b 45 f8             	mov    -0x8(%di),%ax
   1070f:	99                   	cwtd   
   10710:	f7 7d 10             	idivw  0x10(%di)
   10713:	89 45 f8             	mov    %ax,-0x8(%di)
   10716:	83 7d f8 00          	cmpw   $0x0,-0x8(%di)
   1071a:	75 c3                	jne    106df <itoa+0x36>

    if (is_negative) {
   1071c:	83 7d ec 00          	cmpw   $0x0,-0x14(%di)
   10720:	74 0c                	je     1072e <itoa+0x85>
        *ptr++ = '-';
   10722:	8b 45 fc             	mov    -0x4(%di),%ax
   10725:	8d 50 01             	lea    0x1(%bx,%si),%dx
   10728:	89 55 fc             	mov    %dx,-0x4(%di)
   1072b:	c6 00 2d             	movb   $0x2d,(%bx,%si)
    }

    *ptr = '\0';
   1072e:	8b 45 fc             	mov    -0x4(%di),%ax
   10731:	c6 00 00             	movb   $0x0,(%bx,%si)

    // Reverse the string
    char *start = buf;
   10734:	8b 45 08             	mov    0x8(%di),%ax
   10737:	89 45 f4             	mov    %ax,-0xc(%di)
    char *end = ptr - 1;
   1073a:	8b 45 fc             	mov    -0x4(%di),%ax
   1073d:	83 e8 01             	sub    $0x1,%ax
   10740:	89 45 f0             	mov    %ax,-0x10(%di)
    while (start < end) {
   10743:	eb 29                	jmp    1076e <itoa+0xc5>
        char tmp = *start;
   10745:	8b 45 f4             	mov    -0xc(%di),%ax
   10748:	0f b6 00             	movzbw (%bx,%si),%ax
   1074b:	88 45 e7             	mov    %al,-0x19(%di)
        *start++ = *end;
   1074e:	8b 45 f4             	mov    -0xc(%di),%ax
   10751:	8d 50 01             	lea    0x1(%bx,%si),%dx
   10754:	89 55 f4             	mov    %dx,-0xc(%di)
   10757:	8b 55 f0             	mov    -0x10(%di),%dx
   1075a:	0f b6 12             	movzbw (%bp,%si),%dx
   1075d:	88 10                	mov    %dl,(%bx,%si)
        *end-- = tmp;
   1075f:	8b 45 f0             	mov    -0x10(%di),%ax
   10762:	8d 50 ff             	lea    -0x1(%bx,%si),%dx
   10765:	89 55 f0             	mov    %dx,-0x10(%di)
   10768:	0f b6 55 e7          	movzbw -0x19(%di),%dx
   1076c:	88 10                	mov    %dl,(%bx,%si)
    while (start < end) {
   1076e:	8b 45 f4             	mov    -0xc(%di),%ax
   10771:	3b 45 f0             	cmp    -0x10(%di),%ax
   10774:	72 cf                	jb     10745 <itoa+0x9c>
    }
}
   10776:	90                   	nop
   10777:	90                   	nop
   10778:	c9                   	leave  
   10779:	c3                   	ret    

0001077a <sprintf>:

// 格式化字符串输出函数 sprintf
void sprintf(char *buffer, const char *fmt, ...) {
   1077a:	55                   	push   %bp
   1077b:	89 e5                	mov    %sp,%bp
   1077d:	83 ec 18             	sub    $0x18,%sp
    va_list args;
    va_start(args, fmt);
   10780:	8d 45 10             	lea    0x10(%di),%ax
   10783:	89 45 f4             	mov    %ax,-0xc(%di)
    vsprintf(buffer, fmt, args);
   10786:	8b 45 f4             	mov    -0xc(%di),%ax
   10789:	83 ec 04             	sub    $0x4,%sp
   1078c:	50                   	push   %ax
   1078d:	ff 75 0c             	push   0xc(%di)
   10790:	ff 75 08             	push   0x8(%di)
   10793:	e8 06 00             	call   1079c <sprintf+0x22>
   10796:	00 00                	add    %al,(%bx,%si)
   10798:	83 c4 10             	add    $0x10,%sp
    va_end(args);
}
   1079b:	90                   	nop
   1079c:	c9                   	leave  
   1079d:	c3                   	ret    

0001079e <vsprintf>:

// 格式化字符串输出函数 vsprintf
void vsprintf(char *buffer, const char *fmt, va_list args) {
   1079e:	55                   	push   %bp
   1079f:	89 e5                	mov    %sp,%bp
   107a1:	83 ec 20             	sub    $0x20,%sp
    char *buf_ptr = buffer;
   107a4:	8b 45 08             	mov    0x8(%di),%ax
   107a7:	89 45 fc             	mov    %ax,-0x4(%di)
    const char *fmt_ptr = fmt;
   107aa:	8b 45 0c             	mov    0xc(%di),%ax
   107ad:	89 45 f8             	mov    %ax,-0x8(%di)
    while (*fmt_ptr) {
   107b0:	e9 fa 00             	jmp    108ad <vsprintf+0x10f>
   107b3:	00 00                	add    %al,(%bx,%si)
        if (*fmt_ptr == '%' && *(fmt_ptr + 1) != '%') {
   107b5:	8b 45 f8             	mov    -0x8(%di),%ax
   107b8:	0f b6 00             	movzbw (%bx,%si),%ax
   107bb:	3c 25                	cmp    $0x25,%al
   107bd:	0f 85 d7 00          	jne    10898 <vsprintf+0xfa>
   107c1:	00 00                	add    %al,(%bx,%si)
   107c3:	8b 45 f8             	mov    -0x8(%di),%ax
   107c6:	83 c0 01             	add    $0x1,%ax
   107c9:	0f b6 00             	movzbw (%bx,%si),%ax
   107cc:	3c 25                	cmp    $0x25,%al
   107ce:	0f 84 c6 00          	je     10898 <vsprintf+0xfa>
   107d2:	00 00                	add    %al,(%bx,%si)
            fmt_ptr++;
   107d4:	83 45 f8 01          	addw   $0x1,-0x8(%di)
            switch (*fmt_ptr) {
   107d8:	8b 45 f8             	mov    -0x8(%di),%ax
   107db:	0f b6 00             	movzbw (%bx,%si),%ax
   107de:	0f be c0             	movsbw %al,%ax
   107e1:	83 f8 78             	cmp    $0x78,%ax
   107e4:	74 46                	je     1082c <vsprintf+0x8e>
   107e6:	83 f8 78             	cmp    $0x78,%ax
   107e9:	0f 8f 97 00          	jg     10884 <vsprintf+0xe6>
   107ed:	00 00                	add    %al,(%bx,%si)
   107ef:	83 f8 64             	cmp    $0x64,%ax
   107f2:	74 0a                	je     107fe <vsprintf+0x60>
   107f4:	83 f8 73             	cmp    $0x73,%ax
   107f7:	74 61                	je     1085a <vsprintf+0xbc>
   107f9:	e9 88 00             	jmp    10884 <vsprintf+0xe6>
   107fc:	00 00                	add    %al,(%bx,%si)
                case 'd': {
                    int num = va_arg(args, int);
   107fe:	8b 45 10             	mov    0x10(%di),%ax
   10801:	8d 50 04             	lea    0x4(%bx,%si),%dx
   10804:	89 55 10             	mov    %dx,0x10(%di)
   10807:	8b 00                	mov    (%bx,%si),%ax
   10809:	89 45 ec             	mov    %ax,-0x14(%di)
                    itoa(buf_ptr, num, 10);
   1080c:	6a 0a                	push   $0xa
   1080e:	ff 75 ec             	push   -0x14(%di)
   10811:	ff 75 fc             	push   -0x4(%di)
   10814:	e8 90 fe             	call   106a7 <memcmp+0x66>
   10817:	ff                   	(bad)  
   10818:	ff 83 c4 0c          	incw   0xcc4(%bp,%di)
                    buf_ptr += strlen(buf_ptr);
   1081c:	ff 75 fc             	push   -0x4(%di)
   1081f:	e8 7d fd             	call   1059f <strncmp+0x70>
   10822:	ff                   	(bad)  
   10823:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   10827:	01 45 fc             	add    %ax,-0x4(%di)
                    break;
   1082a:	eb 6c                	jmp    10898 <vsprintf+0xfa>
                }
                case 'x': {
                    int num = va_arg(args, int);
   1082c:	8b 45 10             	mov    0x10(%di),%ax
   1082f:	8d 50 04             	lea    0x4(%bx,%si),%dx
   10832:	89 55 10             	mov    %dx,0x10(%di)
   10835:	8b 00                	mov    (%bx,%si),%ax
   10837:	89 45 f4             	mov    %ax,-0xc(%di)
                    itoa(buf_ptr, num, 16);
   1083a:	6a 10                	push   $0x10
   1083c:	ff 75 f4             	push   -0xc(%di)
   1083f:	ff 75 fc             	push   -0x4(%di)
   10842:	e8 62 fe             	call   106a7 <memcmp+0x66>
   10845:	ff                   	(bad)  
   10846:	ff 83 c4 0c          	incw   0xcc4(%bp,%di)
                    buf_ptr += strlen(buf_ptr);
   1084a:	ff 75 fc             	push   -0x4(%di)
   1084d:	e8 4f fd             	call   1059f <strncmp+0x70>
   10850:	ff                   	(bad)  
   10851:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   10855:	01 45 fc             	add    %ax,-0x4(%di)
                    break;
   10858:	eb 3e                	jmp    10898 <vsprintf+0xfa>
                }
                case 's': {
                    const char *str = va_arg(args, const char *);
   1085a:	8b 45 10             	mov    0x10(%di),%ax
   1085d:	8d 50 04             	lea    0x4(%bx,%si),%dx
   10860:	89 55 10             	mov    %dx,0x10(%di)
   10863:	8b 00                	mov    (%bx,%si),%ax
   10865:	89 45 f0             	mov    %ax,-0x10(%di)
                    strcpy(buf_ptr, str);
   10868:	ff 75 f0             	push   -0x10(%di)
   1086b:	ff 75 fc             	push   -0x4(%di)
   1086e:	e8 3a fc             	call   104ab <panic+0x43>
   10871:	ff                   	(bad)  
   10872:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
                    buf_ptr += strlen(str);
   10876:	ff 75 f0             	push   -0x10(%di)
   10879:	e8 23 fd             	call   1059f <strncmp+0x70>
   1087c:	ff                   	(bad)  
   1087d:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   10881:	01 45 fc             	add    %ax,-0x4(%di)
                    break;
   10884:	eb 12                	jmp    10898 <vsprintf+0xfa>
                }
                default:
                    *buf_ptr++ = *fmt_ptr;
   10886:	8b 45 fc             	mov    -0x4(%di),%ax
   10889:	8d 50 01             	lea    0x1(%bx,%si),%dx
   1088c:	89 55 fc             	mov    %dx,-0x4(%di)
   1088f:	8b 55 f8             	mov    -0x8(%di),%dx
   10892:	0f b6 12             	movzbw (%bp,%si),%dx
   10895:	88 10                	mov    %dl,(%bx,%si)
                    break;
   10897:	90                   	nop
            switch (*fmt_ptr) {
   10898:	eb 11                	jmp    108ab <vsprintf+0x10d>
            }
        } else {
            *buf_ptr++ = *fmt_ptr;
   1089a:	8b 45 fc             	mov    -0x4(%di),%ax
   1089d:	8d 50 01             	lea    0x1(%bx,%si),%dx
   108a0:	89 55 fc             	mov    %dx,-0x4(%di)
   108a3:	8b 55 f8             	mov    -0x8(%di),%dx
   108a6:	0f b6 12             	movzbw (%bp,%si),%dx
   108a9:	88 10                	mov    %dl,(%bx,%si)
        }
        fmt_ptr++;
   108ab:	83 45 f8 01          	addw   $0x1,-0x8(%di)
    while (*fmt_ptr) {
   108af:	8b 45 f8             	mov    -0x8(%di),%ax
   108b2:	0f b6 00             	movzbw (%bx,%si),%ax
   108b5:	84 c0                	test   %al,%al
   108b7:	0f 85 f8 fe          	jne    107b3 <vsprintf+0x15>
   108bb:	ff                   	(bad)  
   108bc:	ff 8b 45 fc          	decw   -0x3bb(%bp,%di)
    }
    *buf_ptr = '\0';
   108c0:	c6 00 00             	movb   $0x0,(%bx,%si)
}
   108c3:	90                   	nop
   108c4:	c9                   	leave  
   108c5:	c3                   	ret    

000108c6 <is_leap_year>:
// 每月天数定义（默认 2 月为 28 天）
static const int days_in_month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

// 判断是否为闰年
static int is_leap_year(int year)
{
   108c6:	55                   	push   %bp
   108c7:	89 e5                	mov    %sp,%bp
    return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));
   108c9:	8b 45 08             	mov    0x8(%di),%ax
   108cc:	83 e0 03             	and    $0x3,%ax
   108cf:	85 c0                	test   %ax,%ax
   108d1:	75 50                	jne    10923 <is_leap_year+0x5d>
   108d3:	8b 4d 08             	mov    0x8(%di),%cx
   108d6:	ba 1f 85             	mov    $0x851f,%dx
   108d9:	eb 51                	jmp    1092c <kernel_mktime+0x2>
   108db:	89 c8                	mov    %cx,%ax
   108dd:	f7 ea                	imul   %dx
   108df:	89 d0                	mov    %dx,%ax
   108e1:	c1 f8 05             	sar    $0x5,%ax
   108e4:	89 ca                	mov    %cx,%dx
   108e6:	c1 fa 1f             	sar    $0x1f,%dx
   108e9:	29 d0                	sub    %dx,%ax
   108eb:	6b d0 64             	imul   $0x64,%ax,%dx
   108ee:	89 c8                	mov    %cx,%ax
   108f0:	29 d0                	sub    %dx,%ax
   108f2:	85 c0                	test   %ax,%ax
   108f4:	75 26                	jne    1091c <is_leap_year+0x56>
   108f6:	8b 4d 08             	mov    0x8(%di),%cx
   108f9:	ba 1f 85             	mov    $0x851f,%dx
   108fc:	eb 51                	jmp    1094f <kernel_mktime+0x25>
   108fe:	89 c8                	mov    %cx,%ax
   10900:	f7 ea                	imul   %dx
   10902:	89 d0                	mov    %dx,%ax
   10904:	c1 f8 07             	sar    $0x7,%ax
   10907:	89 ca                	mov    %cx,%dx
   10909:	c1 fa 1f             	sar    $0x1f,%dx
   1090c:	29 d0                	sub    %dx,%ax
   1090e:	69 d0 90 01          	imul   $0x190,%ax,%dx
   10912:	00 00                	add    %al,(%bx,%si)
   10914:	89 c8                	mov    %cx,%ax
   10916:	29 d0                	sub    %dx,%ax
   10918:	85 c0                	test   %ax,%ax
   1091a:	75 07                	jne    10923 <is_leap_year+0x5d>
   1091c:	b8 01 00             	mov    $0x1,%ax
   1091f:	00 00                	add    %al,(%bx,%si)
   10921:	eb 05                	jmp    10928 <is_leap_year+0x62>
   10923:	b8 00 00             	mov    $0x0,%ax
   10926:	00 00                	add    %al,(%bx,%si)
}
   10928:	5d                   	pop    %bp
   10929:	c3                   	ret    

0001092a <kernel_mktime>:

/**
 * 将本地时间转换为时间戳
 */
time_t kernel_mktime(tm_t *tm)
{
   1092a:	55                   	push   %bp
   1092b:	89 e5                	mov    %sp,%bp
   1092d:	83 ec 10             	sub    $0x10,%sp
    int year = tm->tm_year;
   10930:	8b 45 08             	mov    0x8(%di),%ax
   10933:	8b 40 14             	mov    0x14(%bx,%si),%ax
   10936:	89 45 fc             	mov    %ax,-0x4(%di)
    long days = 0;
   10939:	c7 45 f8 00 00       	movw   $0x0,-0x8(%di)
   1093e:	00 00                	add    %al,(%bx,%si)

    // 处理 Y2K 问题
    if (year < 70)
   10940:	83 7d fc 45          	cmpw   $0x45,-0x4(%di)
   10944:	7f 04                	jg     1094a <kernel_mktime+0x20>
        year += 100; // 把 00-69 解析为 2000-2069
   10946:	83 45 fc 64          	addw   $0x64,-0x4(%di)
    year += 1900;    // 得到实际年份
   1094a:	81 45 fc 6c 07       	addw   $0x76c,-0x4(%di)
   1094f:	00 00                	add    %al,(%bx,%si)

    // 累加从 1970 年到指定年份的天数
    for (int y = 1970; y < year; y++)
   10951:	c7 45 f4 b2 07       	movw   $0x7b2,-0xc(%di)
   10956:	00 00                	add    %al,(%bx,%si)
   10958:	eb 22                	jmp    1097c <kernel_mktime+0x52>
    {
        days += is_leap_year(y) ? 366 : 365;
   1095a:	ff 75 f4             	push   -0xc(%di)
   1095d:	e8 64 ff             	call   108c4 <vsprintf+0x126>
   10960:	ff                   	(bad)  
   10961:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   10965:	85 c0                	test   %ax,%ax
   10967:	74 07                	je     10970 <kernel_mktime+0x46>
   10969:	b8 6e 01             	mov    $0x16e,%ax
   1096c:	00 00                	add    %al,(%bx,%si)
   1096e:	eb 05                	jmp    10975 <kernel_mktime+0x4b>
   10970:	b8 6d 01             	mov    $0x16d,%ax
   10973:	00 00                	add    %al,(%bx,%si)
   10975:	01 45 f8             	add    %ax,-0x8(%di)
    for (int y = 1970; y < year; y++)
   10978:	83 45 f4 01          	addw   $0x1,-0xc(%di)
   1097c:	8b 45 f4             	mov    -0xc(%di),%ax
   1097f:	3b 45 fc             	cmp    -0x4(%di),%ax
   10982:	7c d6                	jl     1095a <kernel_mktime+0x30>
    }

    // 累加当年月份的天数
    for (int m = 0; m < tm->tm_mon; m++)
   10984:	c7 45 f0 00 00       	movw   $0x0,-0x10(%di)
   10989:	00 00                	add    %al,(%bx,%si)
   1098b:	eb 2a                	jmp    109b7 <kernel_mktime+0x8d>
    {
        days += days_in_month[m];
   1098d:	8b 45 f0             	mov    -0x10(%di),%ax
   10990:	8b 04                	mov    (%si),%ax
   10992:	85 a0 10 01          	test   %sp,0x110(%bx,%si)
   10996:	00 01                	add    %al,(%bx,%di)
   10998:	45                   	inc    %bp
   10999:	f8                   	clc    
        if (m == 1 && is_leap_year(year))
   1099a:	83 7d f0 01          	cmpw   $0x1,-0x10(%di)
   1099e:	75 13                	jne    109b3 <kernel_mktime+0x89>
   109a0:	ff 75 fc             	push   -0x4(%di)
   109a3:	e8 1e ff             	call   108c4 <vsprintf+0x126>
   109a6:	ff                   	(bad)  
   109a7:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   109ab:	85 c0                	test   %ax,%ax
   109ad:	74 04                	je     109b3 <kernel_mktime+0x89>
        { // 2 月在闰年多 1 天
            days += 1;
   109af:	83 45 f8 01          	addw   $0x1,-0x8(%di)
    for (int m = 0; m < tm->tm_mon; m++)
   109b3:	83 45 f0 01          	addw   $0x1,-0x10(%di)
   109b7:	8b 45 08             	mov    0x8(%di),%ax
   109ba:	8b 40 10             	mov    0x10(%bx,%si),%ax
   109bd:	39 45 f0             	cmp    %ax,-0x10(%di)
   109c0:	7c cb                	jl     1098d <kernel_mktime+0x63>
        }
    }

    // 累加当月天数
    days += tm->tm_mday - 1;
   109c2:	8b 45 08             	mov    0x8(%di),%ax
   109c5:	8b 40 0c             	mov    0xc(%bx,%si),%ax
   109c8:	83 e8 01             	sub    $0x1,%ax
   109cb:	01 45 f8             	add    %ax,-0x8(%di)

    // 计算总秒数
    return days * DAY + tm->tm_hour * HOUR + tm->tm_min * MINUTE + tm->tm_sec;
   109ce:	8b 45 f8             	mov    -0x8(%di),%ax
   109d1:	69 d0 80 51          	imul   $0x5180,%ax,%dx
   109d5:	01 00                	add    %ax,(%bx,%si)
   109d7:	8b 45 08             	mov    0x8(%di),%ax
   109da:	8b 40 08             	mov    0x8(%bx,%si),%ax
   109dd:	69 c0 10 0e          	imul   $0xe10,%ax,%ax
   109e1:	00 00                	add    %al,(%bx,%si)
   109e3:	01 c2                	add    %ax,%dx
   109e5:	8b 45 08             	mov    0x8(%di),%ax
   109e8:	8b 40 04             	mov    0x4(%bx,%si),%ax
   109eb:	6b c0 3c             	imul   $0x3c,%ax,%ax
   109ee:	01 c2                	add    %ax,%dx
   109f0:	8b 45 08             	mov    0x8(%di),%ax
   109f3:	8b 00                	mov    (%bx,%si),%ax
   109f5:	01 d0                	add    %dx,%ax
}
   109f7:	c9                   	leave  
   109f8:	c3                   	ret    

000109f9 <localtime>:

/**
 * 计算时间戳对应的本地时间
 */
int localtime(tm_t *tm, time_t time)
{
   109f9:	55                   	push   %bp
   109fa:	89 e5                	mov    %sp,%bp
   109fc:	53                   	push   %bx
   109fd:	83 ec 10             	sub    $0x10,%sp
    if (tm == NULL)
   10a00:	83 7d 08 00          	cmpw   $0x0,0x8(%di)
   10a04:	75 0a                	jne    10a10 <localtime+0x17>
        return -1;
   10a06:	b8 ff ff             	mov    $0xffff,%ax
   10a09:	ff                   	(bad)  
   10a0a:	ff                   	(bad)  
   10a0b:	e9 0a 02             	jmp    10c18 <localtime+0x21f>
   10a0e:	00 00                	add    %al,(%bx,%si)

    int year = 1970;
   10a10:	c7 45 f8 b2 07       	movw   $0x7b2,-0x8(%di)
   10a15:	00 00                	add    %al,(%bx,%si)
    int days = time / DAY;
   10a17:	8b 45 0c             	mov    0xc(%di),%ax
   10a1a:	ba 07 45             	mov    $0x4507,%dx
   10a1d:	2e c2 f7 e2          	cs ret $0xe2f7
   10a21:	89 d0                	mov    %dx,%ax
   10a23:	c1 e8 10             	shr    $0x10,%ax
   10a26:	89 45 f4             	mov    %ax,-0xc(%di)
    int remaining_secs = time % DAY;
   10a29:	8b 4d 0c             	mov    0xc(%di),%cx
   10a2c:	ba 07 45             	mov    $0x4507,%dx
   10a2f:	2e c2 89 c8          	cs ret $0xc889
   10a33:	f7 e2                	mul    %dx
   10a35:	89 d0                	mov    %dx,%ax
   10a37:	c1 e8 10             	shr    $0x10,%ax
   10a3a:	69 d0 80 51          	imul   $0x5180,%ax,%dx
   10a3e:	01 00                	add    %ax,(%bx,%si)
   10a40:	89 c8                	mov    %cx,%ax
   10a42:	29 d0                	sub    %dx,%ax
   10a44:	89 45 ec             	mov    %ax,-0x14(%di)

    // 解析小时、分钟、秒
    tm->tm_hour = remaining_secs / HOUR;
   10a47:	8b 4d ec             	mov    -0x14(%di),%cx
   10a4a:	ba c5 b3             	mov    $0xb3c5,%dx
   10a4d:	a2 91 89             	mov    %al,0x8991
   10a50:	c8 f7 ea 8d          	enter  $0xeaf7,$0x8d
   10a54:	04 0a                	add    $0xa,%al
   10a56:	c1 f8 0b             	sar    $0xb,%ax
   10a59:	c1 f9 1f             	sar    $0x1f,%cx
   10a5c:	29 c8                	sub    %cx,%ax
   10a5e:	89 c2                	mov    %ax,%dx
   10a60:	8b 45 08             	mov    0x8(%di),%ax
   10a63:	89 50 08             	mov    %dx,0x8(%bx,%si)
    remaining_secs %= HOUR;
   10a66:	8b 4d ec             	mov    -0x14(%di),%cx
   10a69:	ba c5 b3             	mov    $0xb3c5,%dx
   10a6c:	a2 91 89             	mov    %al,0x8991
   10a6f:	c8 f7 ea 8d          	enter  $0xeaf7,$0x8d
   10a73:	04 0a                	add    $0xa,%al
   10a75:	c1 f8 0b             	sar    $0xb,%ax
   10a78:	89 ca                	mov    %cx,%dx
   10a7a:	c1 fa 1f             	sar    $0x1f,%dx
   10a7d:	29 d0                	sub    %dx,%ax
   10a7f:	69 d0 10 0e          	imul   $0xe10,%ax,%dx
   10a83:	00 00                	add    %al,(%bx,%si)
   10a85:	89 c8                	mov    %cx,%ax
   10a87:	29 d0                	sub    %dx,%ax
   10a89:	89 45 ec             	mov    %ax,-0x14(%di)
    tm->tm_min = remaining_secs / MINUTE;
   10a8c:	8b 4d ec             	mov    -0x14(%di),%cx
   10a8f:	ba 89 88             	mov    $0x8889,%dx
   10a92:	88 88 89 c8          	mov    %cl,-0x3777(%bx,%si)
   10a96:	f7 ea                	imul   %dx
   10a98:	8d 04                	lea    (%si),%ax
   10a9a:	0a c1                	or     %cl,%al
   10a9c:	f8                   	clc    
   10a9d:	05 c1 f9             	add    $0xf9c1,%ax
   10aa0:	1f                   	pop    %ds
   10aa1:	29 c8                	sub    %cx,%ax
   10aa3:	89 c2                	mov    %ax,%dx
   10aa5:	8b 45 08             	mov    0x8(%di),%ax
   10aa8:	89 50 04             	mov    %dx,0x4(%bx,%si)
    tm->tm_sec = remaining_secs % MINUTE;
   10aab:	8b 4d ec             	mov    -0x14(%di),%cx
   10aae:	ba 89 88             	mov    $0x8889,%dx
   10ab1:	88 88 89 c8          	mov    %cl,-0x3777(%bx,%si)
   10ab5:	f7 ea                	imul   %dx
   10ab7:	8d 04                	lea    (%si),%ax
   10ab9:	0a c1                	or     %cl,%al
   10abb:	f8                   	clc    
   10abc:	05 89 ca             	add    $0xca89,%ax
   10abf:	c1 fa 1f             	sar    $0x1f,%dx
   10ac2:	29 d0                	sub    %dx,%ax
   10ac4:	6b d0 3c             	imul   $0x3c,%ax,%dx
   10ac7:	89 c8                	mov    %cx,%ax
   10ac9:	29 d0                	sub    %dx,%ax
   10acb:	8b 55 08             	mov    0x8(%di),%dx
   10ace:	89 02                	mov    %ax,(%bp,%si)

    // 计算年份
    while (days >= (is_leap_year(year) ? 366 : 365))
   10ad0:	eb 22                	jmp    10af4 <localtime+0xfb>
    {
        days -= is_leap_year(year) ? 366 : 365;
   10ad2:	ff 75 f8             	push   -0x8(%di)
   10ad5:	e8 ec fd             	call   108c4 <vsprintf+0x126>
   10ad8:	ff                   	(bad)  
   10ad9:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   10add:	85 c0                	test   %ax,%ax
   10adf:	74 07                	je     10ae8 <localtime+0xef>
   10ae1:	b8 6e 01             	mov    $0x16e,%ax
   10ae4:	00 00                	add    %al,(%bx,%si)
   10ae6:	eb 05                	jmp    10aed <localtime+0xf4>
   10ae8:	b8 6d 01             	mov    $0x16d,%ax
   10aeb:	00 00                	add    %al,(%bx,%si)
   10aed:	29 45 f4             	sub    %ax,-0xc(%di)
        year++;
   10af0:	83 45 f8 01          	addw   $0x1,-0x8(%di)
    while (days >= (is_leap_year(year) ? 366 : 365))
   10af4:	ff 75 f8             	push   -0x8(%di)
   10af7:	e8 ca fd             	call   108c4 <vsprintf+0x126>
   10afa:	ff                   	(bad)  
   10afb:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   10aff:	85 c0                	test   %ax,%ax
   10b01:	74 07                	je     10b0a <localtime+0x111>
   10b03:	b8 6e 01             	mov    $0x16e,%ax
   10b06:	00 00                	add    %al,(%bx,%si)
   10b08:	eb 05                	jmp    10b0f <localtime+0x116>
   10b0a:	b8 6d 01             	mov    $0x16d,%ax
   10b0d:	00 00                	add    %al,(%bx,%si)
   10b0f:	3b 45 f4             	cmp    -0xc(%di),%ax
   10b12:	7e be                	jle    10ad2 <localtime+0xd9>
    }
    tm->tm_year = year - 1900; // 转换为 1900 年的偏移
   10b14:	8b 45 f8             	mov    -0x8(%di),%ax
   10b17:	8d 90 94 f8          	lea    -0x76c(%bx,%si),%dx
   10b1b:	ff                   	(bad)  
   10b1c:	ff 8b 45 08          	decw   0x845(%bp,%di)
   10b20:	89 50 14             	mov    %dx,0x14(%bx,%si)
    tm->tm_year = tm->tm_year >= 100 ? tm->tm_year - 100 : tm->tm_year;
   10b23:	8b 45 08             	mov    0x8(%di),%ax
   10b26:	8b 40 14             	mov    0x14(%bx,%si),%ax
   10b29:	83 f8 63             	cmp    $0x63,%ax
   10b2c:	7e 0b                	jle    10b39 <localtime+0x140>
   10b2e:	8b 45 08             	mov    0x8(%di),%ax
   10b31:	8b 40 14             	mov    0x14(%bx,%si),%ax
   10b34:	83 e8 64             	sub    $0x64,%ax
   10b37:	eb 06                	jmp    10b3f <localtime+0x146>
   10b39:	8b 45 08             	mov    0x8(%di),%ax
   10b3c:	8b 40 14             	mov    0x14(%bx,%si),%ax
   10b3f:	8b 55 08             	mov    0x8(%di),%dx
   10b42:	89 42 14             	mov    %ax,0x14(%bp,%si)
    // 计算一年中的第几天
    tm->tm_yday = days;
   10b45:	8b 45 08             	mov    0x8(%di),%ax
   10b48:	8b 55 f4             	mov    -0xc(%di),%dx
   10b4b:	89 50 1c             	mov    %dx,0x1c(%bx,%si)

    // 计算月份和日期
    int month = 0;
   10b4e:	c7 45 f0 00 00       	movw   $0x0,-0x10(%di)
   10b53:	00 00                	add    %al,(%bx,%si)
    while (days >= days_in_month[month] + (month == 1 && is_leap_year(year) ? 1 : 0))
   10b55:	eb 34                	jmp    10b8b <localtime+0x192>
    {
        days -= days_in_month[month] + (month == 1 && is_leap_year(year) ? 1 : 0);
   10b57:	8b 45 f0             	mov    -0x10(%di),%ax
   10b5a:	8b 1c                	mov    (%si),%bx
   10b5c:	85 a0 10 01          	test   %sp,0x110(%bx,%si)
   10b60:	00 83 7d f0          	add    %al,-0xf83(%bp,%di)
   10b64:	01 75 16             	add    %si,0x16(%di)
   10b67:	ff 75 f8             	push   -0x8(%di)
   10b6a:	e8 57 fd             	call   108c4 <vsprintf+0x126>
   10b6d:	ff                   	(bad)  
   10b6e:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   10b72:	85 c0                	test   %ax,%ax
   10b74:	74 07                	je     10b7d <localtime+0x184>
   10b76:	b8 01 00             	mov    $0x1,%ax
   10b79:	00 00                	add    %al,(%bx,%si)
   10b7b:	eb 05                	jmp    10b82 <localtime+0x189>
   10b7d:	b8 00 00             	mov    $0x0,%ax
   10b80:	00 00                	add    %al,(%bx,%si)
   10b82:	01 d8                	add    %bx,%ax
   10b84:	29 45 f4             	sub    %ax,-0xc(%di)
        month++;
   10b87:	83 45 f0 01          	addw   $0x1,-0x10(%di)
    while (days >= days_in_month[month] + (month == 1 && is_leap_year(year) ? 1 : 0))
   10b8b:	8b 45 f0             	mov    -0x10(%di),%ax
   10b8e:	8b 1c                	mov    (%si),%bx
   10b90:	85 a0 10 01          	test   %sp,0x110(%bx,%si)
   10b94:	00 83 7d f0          	add    %al,-0xf83(%bp,%di)
   10b98:	01 75 16             	add    %si,0x16(%di)
   10b9b:	ff 75 f8             	push   -0x8(%di)
   10b9e:	e8 23 fd             	call   108c4 <vsprintf+0x126>
   10ba1:	ff                   	(bad)  
   10ba2:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
   10ba6:	85 c0                	test   %ax,%ax
   10ba8:	74 07                	je     10bb1 <localtime+0x1b8>
   10baa:	b8 01 00             	mov    $0x1,%ax
   10bad:	00 00                	add    %al,(%bx,%si)
   10baf:	eb 05                	jmp    10bb6 <localtime+0x1bd>
   10bb1:	b8 00 00             	mov    $0x0,%ax
   10bb4:	00 00                	add    %al,(%bx,%si)
   10bb6:	01 d8                	add    %bx,%ax
   10bb8:	39 45 f4             	cmp    %ax,-0xc(%di)
   10bbb:	7d 9a                	jge    10b57 <localtime+0x15e>
    }
    tm->tm_mon = month;
   10bbd:	8b 45 08             	mov    0x8(%di),%ax
   10bc0:	8b 55 f0             	mov    -0x10(%di),%dx
   10bc3:	89 50 10             	mov    %dx,0x10(%bx,%si)
    tm->tm_mday = days + 1;
   10bc6:	8b 45 f4             	mov    -0xc(%di),%ax
   10bc9:	8d 50 01             	lea    0x1(%bx,%si),%dx
   10bcc:	8b 45 08             	mov    0x8(%di),%ax
   10bcf:	89 50 0c             	mov    %dx,0xc(%bx,%si)

    // 计算星期几（1970-01-01 是星期四）
    tm->tm_wday = (time / DAY + 4) % 7;
   10bd2:	8b 45 0c             	mov    0xc(%di),%ax
   10bd5:	ba 07 45             	mov    $0x4507,%dx
   10bd8:	2e c2 f7 e2          	cs ret $0xe2f7
   10bdc:	89 d0                	mov    %dx,%ax
   10bde:	c1 e8 10             	shr    $0x10,%ax
   10be1:	8d 48 04             	lea    0x4(%bx,%si),%cx
   10be4:	ba 25 49             	mov    $0x4925,%dx
   10be7:	92                   	xchg   %ax,%dx
   10be8:	24 89                	and    $0x89,%al
   10bea:	c8 f7 e2 89          	enter  $0xe2f7,$0x89
   10bee:	c8 29 d0 d1          	enter  $0xd029,$0xd1
   10bf2:	e8 01 d0             	call   1dbf6 <_end+0xbb0e>
   10bf5:	c1 e8 02             	shr    $0x2,%ax
   10bf8:	89 c2                	mov    %ax,%dx
   10bfa:	c1 e2 03             	shl    $0x3,%dx
   10bfd:	29 c2                	sub    %ax,%dx
   10bff:	89 c8                	mov    %cx,%ax
   10c01:	29 d0                	sub    %dx,%ax
   10c03:	89 c2                	mov    %ax,%dx
   10c05:	8b 45 08             	mov    0x8(%di),%ax
   10c08:	89 50 18             	mov    %dx,0x18(%bx,%si)

    // 假设不使用夏令时
    tm->tm_isdst = 0;
   10c0b:	8b 45 08             	mov    0x8(%di),%ax
   10c0e:	c7 40 20 00 00       	movw   $0x0,0x20(%bx,%si)
   10c13:	00 00                	add    %al,(%bx,%si)

    return 0;
   10c15:	b8 00 00             	mov    $0x0,%ax
   10c18:	00 00                	add    %al,(%bx,%si)
   10c1a:	8b 5d fc             	mov    -0x4(%di),%bx
   10c1d:	c9                   	leave  
   10c1e:	c3                   	ret    
