
kernel.elf：     文件格式 elf32-i386
kernel.elf
体系结构：i386， 标志 0x00000112：
EXEC_P, HAS_SYMS, D_PAGED
起始地址 0x00100000

程序头：
    LOAD off    0x00000000 vaddr 0x000ff000 paddr 0x000ff000 align 2**12
         filesz 0x000000d4 memsz 0x000000d4 flags r--
    LOAD off    0x00001000 vaddr 0x00100000 paddr 0x00100000 align 2**12
         filesz 0x000031c7 memsz 0x000031c7 flags r-x
    LOAD off    0x00005000 vaddr 0x00104000 paddr 0x00104000 align 2**12
         filesz 0x00000af0 memsz 0x00000af0 flags r--
    LOAD off    0x00006000 vaddr 0x00105000 paddr 0x00105000 align 2**12
         filesz 0x00002010 memsz 0x00031020 flags rw-
   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4
         filesz 0x00000000 memsz 0x00000000 flags rwx

节：
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000031c7  00100000  00100000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000af0  00104000  00104000  00005000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00002010  00105000  00105000  00006000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          0002e020  00108000  00108000  00008010  2**12
                  ALLOC
  4 .comment      0000002b  00000000  00000000  00008010  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000258  00000000  00000000  00008040  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_info   00004133  00000000  00000000  00008298  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_abbrev 0000197e  00000000  00000000  0000c3cb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   00001a2d  00000000  00000000  0000dd49  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_frame  000010c0  00000000  00000000  0000f778  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_str    000010ba  00000000  00000000  00010838  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line_str 00000254  00000000  00000000  000118f2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_rnglists 00000017  00000000  00000000  00011b46  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 start.o
00100007 l       .text	00000000 entry_kernel
00000000 l    df *ABS*	00000000 sched.c
0010029b l     F .text	00000007 hlt
001002a2 l     F .text	0000000c write_tr
001002ae l     F .text	0000001a far_jump
00108000 l     O .bss	0000014c schedulor
001002c8 l     F .text	0000000a idle_func
001002d2 l     F .text	00000020 idle_task_init
001002f2 l     F .text	00000042 first_task_init
00104020 l     O .rodata	00000017 __FUNCTION__.0
00000000 l    df *ABS*	00000000 task.c
00105000 l     O .data	00001000 err_str
001040d4 l     O .rodata	00000009 __FUNCTION__.2
001040e0 l     O .rodata	0000000a __FUNCTION__.1
001040ec l     O .rodata	0000000b __FUNCTION__.0
00000000 l    df *ABS*	00000000 pid.c
0010411c l     O .rodata	0000000f __FUNCTION__.0
00000000 l    df *ABS*	00000000 traps.c
00100a66 l     F .text	00000011 read_cr2
00100a77 l     F .text	00000007 hlt
00100a7e l     F .text	00000137 dump_core_regs
00104648 l     O .rodata	0000000f __FUNCTION__.3
00100bb5 l     F .text	00000088 do_default_handler
00104658 l     O .rodata	00000013 __FUNCTION__.2
0010466c l     O .rodata	0000001e __FUNCTION__.1
0010468c l     O .rodata	00000016 __FUNCTION__.0
00000000 l    df *ABS*	00000000 8259A.c
0010137f l     F .text	0000001d inb
0010139c l     F .text	00000021 outb
00000000 l    df *ABS*	00000000 init.c
001046d0 l     O .rodata	00000005 __FUNCTION__.1
001046d8 l     O .rodata	0000000c __FUNCTION__.0
00000000 l    df *ABS*	00000000 cpu.c
0010166d l     F .text	00000010 read_eflags
0010167d l     F .text	0000000b write_eflags
00101688 l     F .text	00000007 cli
0010168f l     F .text	00000007 sti
00101696 l     F .text	00000028 lidt
001016be l     F .text	00000049 idt_init
00000000 l    df *ABS*	00000000 err.c
00106000 l     O .data	00001000 err_str
00000000 l    df *ABS*	00000000 memory.c
00000000 l    df *ABS*	00000000 mmu.c
00101900 l     F .text	0000000c write_cr3
0012f000 l     O .bss	00001000 pgd
00104918 l     O .rodata	00000012 __FUNCTION__.3
0010492c l     O .rodata	0000000f __FUNCTION__.2
0010493c l     O .rodata	0000000f __FUNCTION__.1
0010494c l     O .rodata	00000009 __FUNCTION__.0
00000000 l    df *ABS*	00000000 mm_block.c
00130000 l     O .bss	00003000 mm_regions
00133000 l     O .bss	00003000 rv_regions
00136000 l     O .bss	00000018 memblock
00101f4d l     F .text	00000058 get_region_from
00101fa5 l     F .text	0000004d free_region_in
00104a0c l     O .rodata	0000000f __FUNCTION__.2
00104a1c l     O .rodata	0000000e __FUNCTION__.1
00104a2c l     O .rodata	0000000e __FUNCTION__.0
00000000 l    df *ABS*	00000000 timer.c
001023e9 l     F .text	00000021 outb
00136018 l     O .bss	00000004 sys_tick
00000000 l    df *ABS*	00000000 rtc.c
0010249c l     F .text	0000001d inb
001024b9 l     F .text	00000021 outb
001024da l     F .text	00000027 read_cmos
00000000 l    df *ABS*	00000000 serial.c
00102653 l     F .text	0000001d inb
00102670 l     F .text	00000021 outb
00102691 l     F .text	00000075 rs232_init
00000000 l    df *ABS*	00000000 debug.c
0010277d l     F .text	00000007 hlt
00107000 l     O .data	00000010 title.0
00000000 l    df *ABS*	00000000 list.c
00102883 l     F .text	00000013 list_is_empty
00000000 l    df *ABS*	00000000 string.c
00000000 l    df *ABS*	00000000 time.c
00104ac0 l     O .rodata	00000030 days_in_month
00102e6e l     F .text	00000064 is_leap_year
00102501 g     F .text	00000152 rtc_init
001003dc g     F .text	00000047 set_task_to_ready_list
00102a7b g     F .text	00000026 strcpy
0010115f g     F .text	00000097 trap_install
00101722 g     F .text	0000000b irq_enable_global
0010291a g     F .text	00000064 list_insert_last
00102d44 g     F .text	0000012a vsprintf
00100d71 g     F .text	0000001c do_handler_segment_not_present
0010025d g       .text	00000000 exception_handler_virtual_exception
00100452 g     F .text	00000066 schedul
0013601c g     O .bss	00000004 startup_time
001018c9 g     F .text	00000024 cpu_init
00101ff2 g     F .text	00000170 mm_alloc_pages
00102784 g     F .text	000000ba dbg_print
00100202 g       .text	00000000 exception_handler_alignment_check
00100835 g     F .text	00000068 pid_is_allocated
00101707 g     F .text	00000010 get_idt_gate_desc
0010147b g     F .text	0000008b irq_enable
0010001e g       .text	00000000 exception_handler_unknown
0010009a g       .text	00000000 exception_handler_breakpoint
00100cc9 g     F .text	0000001c do_handler_overflow
00101058 g     F .text	0000001c do_handler_alignment_check
00100543 g     F .text	0000015e tss_init
001001a9 g       .text	00000000 exception_handler_general_protection
00102b96 g     F .text	00000040 memcpy
00100da9 g     F .text	00000127 do_handler_general_protection
001010c8 g     F .text	00000097 interupt_install
001013bd g     F .text	00000093 init_pic
00100c59 g     F .text	0000001c do_handler_divider
00100d39 g     F .text	0000001c do_handler_double_fault
00100ed0 g     F .text	0000016c do_handler_page_fault
001007fd g     F .text	00000010 task_free
00102297 g     F .text	00000015 mm_alloc_one_page
0012e2a0 g     O .bss	00000004 gdt
00100135 g       .text	00000000 exception_handler_double_fault
0010190c g     F .text	000000c9 kernel_pgd_create
00101450 g     F .text	0000002b pic_send_eoi
00102711 g     F .text	0000006c serial_printf
0010240a g     F .text	00000028 do_handler_timer
00102c77 g     F .text	000000a9 itoa
0010018c g       .text	00000000 exception_handler_stack_segment_fault
00101891 g     F .text	00000038 gdt_init
0010089d g     F .text	00000098 pid_alloc
001010ac g     F .text	0000001c do_handler_virtual_exception
001000b9 g       .text	00000000 exception_handler_overflow
00100381 g     F .text	0000000a get_cur_task
001022c4 g     F .text	00000125 memblock_init
0012e200 g     O .bss	00000098 second_task
001000d8 g       .text	00000000 exception_handler_bound_range
00100d01 g     F .text	0000001c do_handler_invalid_opcode
00100152 g       .text	00000000 exception_handler_invalid_tss
001022ac g     F .text	00000018 mm_free_one_page
00102432 g     F .text	0000006a timer_init
0010103c g     F .text	0000001c do_handler_fpu_error
00101074 g     F .text	0000001c do_handler_machine_check
00100c75 g     F .text	0000001c do_handler_Debug
001017cc g     F .text	0000002e gdt_free_desc
001028bb g     F .text	0000005f list_insert_first
0010080d g     F .text	00000028 pidalloc_init
0012e1e0 g     O .bss	00000004 boot_inform
00100c91 g     F .text	0000001c do_handler_NMI
0010003d g       .text	00000000 exception_handler_divider
00101717 g     F .text	0000000b irq_disable_global
001015c9 g     F .text	000000a4 kernel_init
00100000 g       .text	00000000 _start
00100116 g       .text	00000000 exception_handler_device_unavailable
001000f7 g       .text	00000000 exception_handler_invalid_opcode
00100935 g     F .text	00000071 pid_free
00102afd g     F .text	00000072 strncmp
0010021f g       .text	00000000 exception_handler_machine_check
00100d55 g     F .text	0000001c do_handler_invalid_tss
00102aa1 g     F .text	0000005c strncpy
00101b99 g     F .text	0000010d mmu_get_phaddr
0010283e g     F .text	00000045 panic
0010027c g       .text	00000000 exception_handler_timer
00102c0f g     F .text	00000068 memcmp
0010172d g     F .text	00000018 irq_enter_protection
001017fa g     F .text	00000097 gdt_set_tss
00101506 g     F .text	00000087 irq_disable
00101e0f g     F .text	0000013e mmu_test
0010023e g       .text	00000000 exception_handler_smd_exception
00107010 g       .bss	00000000 __bss_start
00102fa1 g     F .text	00000226 localtime
00102bd6 g     F .text	00000039 memset
00100d1d g     F .text	0000001c do_handler_device_unavailable
00108160 g     O .bss	00026000 task_pool
00100798 g     F .text	00000065 task_alloc
00100423 g     F .text	00000013 switch_to_tss
00102706 g     F .text	0000000b serial_init
0012e2c0 g     O .bss	00000800 idt
00102896 g     F .text	00000025 list_init
00101090 g     F .text	0000001c do_handler_smd_exception
001001c6 g       .text	00000000 exception_handler_page_fault
00102d20 g     F .text	00000024 sprintf
00100c3d g     F .text	0000001c do_handler_unknown
001001e3 g       .text	00000000 exception_handler_fpu_error
00100436 g     F .text	0000001c task_switch_from_to
00101745 g     F .text	00000011 irq_leave_protection
0010038b g     F .text	0000000e set_cur_task
00100ce5 g     F .text	0000001c do_handler_bound_range
0012e160 g     O .bss	00000080 pidallocter
0010158d g     F .text	0000003c func
00101ca6 g     F .text	00000169 mmu_create_task_pgd
0010297e g     F .text	00000078 list_remove_first
00107010 g       .data	00000000 _edata
001019d5 g     F .text	000001c4 mmu_memory_map
00136020 g       .bss	00000000 _end
0010016f g       .text	00000000 exception_handler_segment_not_present
0010007b g       .text	00000000 exception_handler_NMI
0010005c g       .text	00000000 exception_handler_Debug
001004b8 g     F .text	0000008b task_time_tick
001018ed g     F .text	00000013 memory_init
00102162 g     F .text	00000135 mm_free_pages
00100d8d g     F .text	0000001c do_handler_stack_segment_fault
00100cad g     F .text	0000001c do_handler_breakpoint
00102ed2 g     F .text	000000cf kernel_mktime
00100334 g     F .text	0000004d sched_init
001006a1 g     F .text	000000f7 task_init
00102b6f g     F .text	00000027 strlen
001011f6 g     F .text	00000189 trap_init
00100399 g     F .text	00000043 get_ready_task
00101756 g     F .text	00000076 gdt_alloc_desc
001009a6 g     F .text	000000c0 pidalloc_print
001029f6 g     F .text	00000085 list_remove



Disassembly of section .text:

00100000 <_start>:
	#include "cpu_cfg.h"
    .extern kernel_init
    .global _start

_start:
    ljmpl $SELECTOR_KERNEL_CODE_SEG,$entry_kernel
  100000:	ea 07 00 10 00       	ljmp   $0x10,$0x7
  100005:	18 00                	sbb    %al,(%bx,%si)

00100007 <entry_kernel>:
entry_kernel:
    mov $SELECTOR_KERNEL_DATA_SEG,%ax
  100007:	66 b8 20 00 8e d8    	mov    $0xd88e0020,%eax
    mov %ax, %ds
	mov %ax, %ss
  10000d:	8e d0                	mov    %ax,%ss
	mov %ax, %es
  10000f:	8e c0                	mov    %ax,%es
	mov %ax, %fs
  100011:	8e e0                	mov    %ax,%fs
	mov %ax, %gs
  100013:	8e e8                	mov    %ax,%gs


    push 4(%esp) # 将boot_info入栈
  100015:	ff 74 24             	push   0x24(%si)
  100018:	04 e8                	add    $0xe8,%al

    call kernel_init
  10001a:	ab                   	stos   %ax,%es:(%di)
  10001b:	15 00 00             	adc    $0x0,%ax

0010001e <exception_handler_unknown>:
		add $(2*4), %esp
		iret
.endm

# 注册中断处理函数
exception_handler unknown, -1, 0
  10001e:	6a 00                	push   $0x0
  100020:	6a ff                	push   $0xffff
  100022:	60                   	pusha  
  100023:	1e                   	push   %ds
  100024:	06                   	push   %es
  100025:	0f a0                	push   %fs
  100027:	0f a8                	push   %gs
  100029:	54                   	push   %sp
  10002a:	e8 0e 0c             	call   100c3b <do_default_handler+0x86>
  10002d:	00 00                	add    %al,(%bx,%si)
  10002f:	83 c4 04             	add    $0x4,%sp
  100032:	0f a9                	pop    %gs
  100034:	0f a1                	pop    %fs
  100036:	07                   	pop    %es
  100037:	1f                   	pop    %ds
  100038:	61                   	popa   
  100039:	83 c4 08             	add    $0x8,%sp
  10003c:	cf                   	iret   

0010003d <exception_handler_divider>:
exception_handler divider, 0, 0
  10003d:	6a 00                	push   $0x0
  10003f:	6a 00                	push   $0x0
  100041:	60                   	pusha  
  100042:	1e                   	push   %ds
  100043:	06                   	push   %es
  100044:	0f a0                	push   %fs
  100046:	0f a8                	push   %gs
  100048:	54                   	push   %sp
  100049:	e8 0b 0c             	call   100c57 <do_handler_unknown+0x1a>
  10004c:	00 00                	add    %al,(%bx,%si)
  10004e:	83 c4 04             	add    $0x4,%sp
  100051:	0f a9                	pop    %gs
  100053:	0f a1                	pop    %fs
  100055:	07                   	pop    %es
  100056:	1f                   	pop    %ds
  100057:	61                   	popa   
  100058:	83 c4 08             	add    $0x8,%sp
  10005b:	cf                   	iret   

0010005c <exception_handler_Debug>:
exception_handler Debug, 1, 0
  10005c:	6a 00                	push   $0x0
  10005e:	6a 01                	push   $0x1
  100060:	60                   	pusha  
  100061:	1e                   	push   %ds
  100062:	06                   	push   %es
  100063:	0f a0                	push   %fs
  100065:	0f a8                	push   %gs
  100067:	54                   	push   %sp
  100068:	e8 08 0c             	call   100c73 <do_handler_divider+0x1a>
  10006b:	00 00                	add    %al,(%bx,%si)
  10006d:	83 c4 04             	add    $0x4,%sp
  100070:	0f a9                	pop    %gs
  100072:	0f a1                	pop    %fs
  100074:	07                   	pop    %es
  100075:	1f                   	pop    %ds
  100076:	61                   	popa   
  100077:	83 c4 08             	add    $0x8,%sp
  10007a:	cf                   	iret   

0010007b <exception_handler_NMI>:
exception_handler NMI, 2, 0
  10007b:	6a 00                	push   $0x0
  10007d:	6a 02                	push   $0x2
  10007f:	60                   	pusha  
  100080:	1e                   	push   %ds
  100081:	06                   	push   %es
  100082:	0f a0                	push   %fs
  100084:	0f a8                	push   %gs
  100086:	54                   	push   %sp
  100087:	e8 05 0c             	call   100c8f <do_handler_Debug+0x1a>
  10008a:	00 00                	add    %al,(%bx,%si)
  10008c:	83 c4 04             	add    $0x4,%sp
  10008f:	0f a9                	pop    %gs
  100091:	0f a1                	pop    %fs
  100093:	07                   	pop    %es
  100094:	1f                   	pop    %ds
  100095:	61                   	popa   
  100096:	83 c4 08             	add    $0x8,%sp
  100099:	cf                   	iret   

0010009a <exception_handler_breakpoint>:
exception_handler breakpoint, 3, 0
  10009a:	6a 00                	push   $0x0
  10009c:	6a 03                	push   $0x3
  10009e:	60                   	pusha  
  10009f:	1e                   	push   %ds
  1000a0:	06                   	push   %es
  1000a1:	0f a0                	push   %fs
  1000a3:	0f a8                	push   %gs
  1000a5:	54                   	push   %sp
  1000a6:	e8 02 0c             	call   100cab <do_handler_NMI+0x1a>
  1000a9:	00 00                	add    %al,(%bx,%si)
  1000ab:	83 c4 04             	add    $0x4,%sp
  1000ae:	0f a9                	pop    %gs
  1000b0:	0f a1                	pop    %fs
  1000b2:	07                   	pop    %es
  1000b3:	1f                   	pop    %ds
  1000b4:	61                   	popa   
  1000b5:	83 c4 08             	add    $0x8,%sp
  1000b8:	cf                   	iret   

001000b9 <exception_handler_overflow>:
exception_handler overflow, 4, 0
  1000b9:	6a 00                	push   $0x0
  1000bb:	6a 04                	push   $0x4
  1000bd:	60                   	pusha  
  1000be:	1e                   	push   %ds
  1000bf:	06                   	push   %es
  1000c0:	0f a0                	push   %fs
  1000c2:	0f a8                	push   %gs
  1000c4:	54                   	push   %sp
  1000c5:	e8 ff 0b             	call   100cc7 <do_handler_breakpoint+0x1a>
  1000c8:	00 00                	add    %al,(%bx,%si)
  1000ca:	83 c4 04             	add    $0x4,%sp
  1000cd:	0f a9                	pop    %gs
  1000cf:	0f a1                	pop    %fs
  1000d1:	07                   	pop    %es
  1000d2:	1f                   	pop    %ds
  1000d3:	61                   	popa   
  1000d4:	83 c4 08             	add    $0x8,%sp
  1000d7:	cf                   	iret   

001000d8 <exception_handler_bound_range>:
exception_handler bound_range, 5, 0
  1000d8:	6a 00                	push   $0x0
  1000da:	6a 05                	push   $0x5
  1000dc:	60                   	pusha  
  1000dd:	1e                   	push   %ds
  1000de:	06                   	push   %es
  1000df:	0f a0                	push   %fs
  1000e1:	0f a8                	push   %gs
  1000e3:	54                   	push   %sp
  1000e4:	e8 fc 0b             	call   100ce3 <do_handler_overflow+0x1a>
  1000e7:	00 00                	add    %al,(%bx,%si)
  1000e9:	83 c4 04             	add    $0x4,%sp
  1000ec:	0f a9                	pop    %gs
  1000ee:	0f a1                	pop    %fs
  1000f0:	07                   	pop    %es
  1000f1:	1f                   	pop    %ds
  1000f2:	61                   	popa   
  1000f3:	83 c4 08             	add    $0x8,%sp
  1000f6:	cf                   	iret   

001000f7 <exception_handler_invalid_opcode>:
exception_handler invalid_opcode, 6, 0
  1000f7:	6a 00                	push   $0x0
  1000f9:	6a 06                	push   $0x6
  1000fb:	60                   	pusha  
  1000fc:	1e                   	push   %ds
  1000fd:	06                   	push   %es
  1000fe:	0f a0                	push   %fs
  100100:	0f a8                	push   %gs
  100102:	54                   	push   %sp
  100103:	e8 f9 0b             	call   100cff <do_handler_bound_range+0x1a>
  100106:	00 00                	add    %al,(%bx,%si)
  100108:	83 c4 04             	add    $0x4,%sp
  10010b:	0f a9                	pop    %gs
  10010d:	0f a1                	pop    %fs
  10010f:	07                   	pop    %es
  100110:	1f                   	pop    %ds
  100111:	61                   	popa   
  100112:	83 c4 08             	add    $0x8,%sp
  100115:	cf                   	iret   

00100116 <exception_handler_device_unavailable>:
exception_handler device_unavailable, 7, 0
  100116:	6a 00                	push   $0x0
  100118:	6a 07                	push   $0x7
  10011a:	60                   	pusha  
  10011b:	1e                   	push   %ds
  10011c:	06                   	push   %es
  10011d:	0f a0                	push   %fs
  10011f:	0f a8                	push   %gs
  100121:	54                   	push   %sp
  100122:	e8 f6 0b             	call   100d1b <do_handler_invalid_opcode+0x1a>
  100125:	00 00                	add    %al,(%bx,%si)
  100127:	83 c4 04             	add    $0x4,%sp
  10012a:	0f a9                	pop    %gs
  10012c:	0f a1                	pop    %fs
  10012e:	07                   	pop    %es
  10012f:	1f                   	pop    %ds
  100130:	61                   	popa   
  100131:	83 c4 08             	add    $0x8,%sp
  100134:	cf                   	iret   

00100135 <exception_handler_double_fault>:
exception_handler double_fault, 8, 1
  100135:	6a 08                	push   $0x8
  100137:	60                   	pusha  
  100138:	1e                   	push   %ds
  100139:	06                   	push   %es
  10013a:	0f a0                	push   %fs
  10013c:	0f a8                	push   %gs
  10013e:	54                   	push   %sp
  10013f:	e8 f5 0b             	call   100d37 <do_handler_device_unavailable+0x1a>
  100142:	00 00                	add    %al,(%bx,%si)
  100144:	83 c4 04             	add    $0x4,%sp
  100147:	0f a9                	pop    %gs
  100149:	0f a1                	pop    %fs
  10014b:	07                   	pop    %es
  10014c:	1f                   	pop    %ds
  10014d:	61                   	popa   
  10014e:	83 c4 08             	add    $0x8,%sp
  100151:	cf                   	iret   

00100152 <exception_handler_invalid_tss>:
exception_handler invalid_tss, 10, 1
  100152:	6a 0a                	push   $0xa
  100154:	60                   	pusha  
  100155:	1e                   	push   %ds
  100156:	06                   	push   %es
  100157:	0f a0                	push   %fs
  100159:	0f a8                	push   %gs
  10015b:	54                   	push   %sp
  10015c:	e8 f4 0b             	call   100d53 <do_handler_double_fault+0x1a>
  10015f:	00 00                	add    %al,(%bx,%si)
  100161:	83 c4 04             	add    $0x4,%sp
  100164:	0f a9                	pop    %gs
  100166:	0f a1                	pop    %fs
  100168:	07                   	pop    %es
  100169:	1f                   	pop    %ds
  10016a:	61                   	popa   
  10016b:	83 c4 08             	add    $0x8,%sp
  10016e:	cf                   	iret   

0010016f <exception_handler_segment_not_present>:
exception_handler segment_not_present, 11, 1
  10016f:	6a 0b                	push   $0xb
  100171:	60                   	pusha  
  100172:	1e                   	push   %ds
  100173:	06                   	push   %es
  100174:	0f a0                	push   %fs
  100176:	0f a8                	push   %gs
  100178:	54                   	push   %sp
  100179:	e8 f3 0b             	call   100d6f <do_handler_invalid_tss+0x1a>
  10017c:	00 00                	add    %al,(%bx,%si)
  10017e:	83 c4 04             	add    $0x4,%sp
  100181:	0f a9                	pop    %gs
  100183:	0f a1                	pop    %fs
  100185:	07                   	pop    %es
  100186:	1f                   	pop    %ds
  100187:	61                   	popa   
  100188:	83 c4 08             	add    $0x8,%sp
  10018b:	cf                   	iret   

0010018c <exception_handler_stack_segment_fault>:
exception_handler stack_segment_fault, 12, 1
  10018c:	6a 0c                	push   $0xc
  10018e:	60                   	pusha  
  10018f:	1e                   	push   %ds
  100190:	06                   	push   %es
  100191:	0f a0                	push   %fs
  100193:	0f a8                	push   %gs
  100195:	54                   	push   %sp
  100196:	e8 f2 0b             	call   100d8b <do_handler_segment_not_present+0x1a>
  100199:	00 00                	add    %al,(%bx,%si)
  10019b:	83 c4 04             	add    $0x4,%sp
  10019e:	0f a9                	pop    %gs
  1001a0:	0f a1                	pop    %fs
  1001a2:	07                   	pop    %es
  1001a3:	1f                   	pop    %ds
  1001a4:	61                   	popa   
  1001a5:	83 c4 08             	add    $0x8,%sp
  1001a8:	cf                   	iret   

001001a9 <exception_handler_general_protection>:
exception_handler general_protection, 13, 1
  1001a9:	6a 0d                	push   $0xd
  1001ab:	60                   	pusha  
  1001ac:	1e                   	push   %ds
  1001ad:	06                   	push   %es
  1001ae:	0f a0                	push   %fs
  1001b0:	0f a8                	push   %gs
  1001b2:	54                   	push   %sp
  1001b3:	e8 f1 0b             	call   100da7 <do_handler_stack_segment_fault+0x1a>
  1001b6:	00 00                	add    %al,(%bx,%si)
  1001b8:	83 c4 04             	add    $0x4,%sp
  1001bb:	0f a9                	pop    %gs
  1001bd:	0f a1                	pop    %fs
  1001bf:	07                   	pop    %es
  1001c0:	1f                   	pop    %ds
  1001c1:	61                   	popa   
  1001c2:	83 c4 08             	add    $0x8,%sp
  1001c5:	cf                   	iret   

001001c6 <exception_handler_page_fault>:
exception_handler page_fault, 14, 1
  1001c6:	6a 0e                	push   $0xe
  1001c8:	60                   	pusha  
  1001c9:	1e                   	push   %ds
  1001ca:	06                   	push   %es
  1001cb:	0f a0                	push   %fs
  1001cd:	0f a8                	push   %gs
  1001cf:	54                   	push   %sp
  1001d0:	e8 fb 0c             	call   100ece <do_handler_general_protection+0x125>
  1001d3:	00 00                	add    %al,(%bx,%si)
  1001d5:	83 c4 04             	add    $0x4,%sp
  1001d8:	0f a9                	pop    %gs
  1001da:	0f a1                	pop    %fs
  1001dc:	07                   	pop    %es
  1001dd:	1f                   	pop    %ds
  1001de:	61                   	popa   
  1001df:	83 c4 08             	add    $0x8,%sp
  1001e2:	cf                   	iret   

001001e3 <exception_handler_fpu_error>:
exception_handler fpu_error, 16, 0
  1001e3:	6a 00                	push   $0x0
  1001e5:	6a 10                	push   $0x10
  1001e7:	60                   	pusha  
  1001e8:	1e                   	push   %ds
  1001e9:	06                   	push   %es
  1001ea:	0f a0                	push   %fs
  1001ec:	0f a8                	push   %gs
  1001ee:	54                   	push   %sp
  1001ef:	e8 48 0e             	call   10103a <do_handler_page_fault+0x16a>
  1001f2:	00 00                	add    %al,(%bx,%si)
  1001f4:	83 c4 04             	add    $0x4,%sp
  1001f7:	0f a9                	pop    %gs
  1001f9:	0f a1                	pop    %fs
  1001fb:	07                   	pop    %es
  1001fc:	1f                   	pop    %ds
  1001fd:	61                   	popa   
  1001fe:	83 c4 08             	add    $0x8,%sp
  100201:	cf                   	iret   

00100202 <exception_handler_alignment_check>:
exception_handler alignment_check, 17, 1
  100202:	6a 11                	push   $0x11
  100204:	60                   	pusha  
  100205:	1e                   	push   %ds
  100206:	06                   	push   %es
  100207:	0f a0                	push   %fs
  100209:	0f a8                	push   %gs
  10020b:	54                   	push   %sp
  10020c:	e8 47 0e             	call   101056 <do_handler_fpu_error+0x1a>
  10020f:	00 00                	add    %al,(%bx,%si)
  100211:	83 c4 04             	add    $0x4,%sp
  100214:	0f a9                	pop    %gs
  100216:	0f a1                	pop    %fs
  100218:	07                   	pop    %es
  100219:	1f                   	pop    %ds
  10021a:	61                   	popa   
  10021b:	83 c4 08             	add    $0x8,%sp
  10021e:	cf                   	iret   

0010021f <exception_handler_machine_check>:
exception_handler machine_check, 18, 0
  10021f:	6a 00                	push   $0x0
  100221:	6a 12                	push   $0x12
  100223:	60                   	pusha  
  100224:	1e                   	push   %ds
  100225:	06                   	push   %es
  100226:	0f a0                	push   %fs
  100228:	0f a8                	push   %gs
  10022a:	54                   	push   %sp
  10022b:	e8 44 0e             	call   101072 <do_handler_alignment_check+0x1a>
  10022e:	00 00                	add    %al,(%bx,%si)
  100230:	83 c4 04             	add    $0x4,%sp
  100233:	0f a9                	pop    %gs
  100235:	0f a1                	pop    %fs
  100237:	07                   	pop    %es
  100238:	1f                   	pop    %ds
  100239:	61                   	popa   
  10023a:	83 c4 08             	add    $0x8,%sp
  10023d:	cf                   	iret   

0010023e <exception_handler_smd_exception>:
exception_handler smd_exception, 19, 0
  10023e:	6a 00                	push   $0x0
  100240:	6a 13                	push   $0x13
  100242:	60                   	pusha  
  100243:	1e                   	push   %ds
  100244:	06                   	push   %es
  100245:	0f a0                	push   %fs
  100247:	0f a8                	push   %gs
  100249:	54                   	push   %sp
  10024a:	e8 41 0e             	call   10108e <do_handler_machine_check+0x1a>
  10024d:	00 00                	add    %al,(%bx,%si)
  10024f:	83 c4 04             	add    $0x4,%sp
  100252:	0f a9                	pop    %gs
  100254:	0f a1                	pop    %fs
  100256:	07                   	pop    %es
  100257:	1f                   	pop    %ds
  100258:	61                   	popa   
  100259:	83 c4 08             	add    $0x8,%sp
  10025c:	cf                   	iret   

0010025d <exception_handler_virtual_exception>:
exception_handler virtual_exception, 20, 0
  10025d:	6a 00                	push   $0x0
  10025f:	6a 14                	push   $0x14
  100261:	60                   	pusha  
  100262:	1e                   	push   %ds
  100263:	06                   	push   %es
  100264:	0f a0                	push   %fs
  100266:	0f a8                	push   %gs
  100268:	54                   	push   %sp
  100269:	e8 3e 0e             	call   1010aa <do_handler_smd_exception+0x1a>
  10026c:	00 00                	add    %al,(%bx,%si)
  10026e:	83 c4 04             	add    $0x4,%sp
  100271:	0f a9                	pop    %gs
  100273:	0f a1                	pop    %fs
  100275:	07                   	pop    %es
  100276:	1f                   	pop    %ds
  100277:	61                   	popa   
  100278:	83 c4 08             	add    $0x8,%sp
  10027b:	cf                   	iret   

0010027c <exception_handler_timer>:

  10027c:	6a 00                	push   $0x0
  10027e:	6a 20                	push   $0x20
  100280:	60                   	pusha  
  100281:	1e                   	push   %ds
  100282:	06                   	push   %es
  100283:	0f a0                	push   %fs
  100285:	0f a8                	push   %gs
  100287:	54                   	push   %sp
  100288:	e8 7d 21             	call   102408 <outb+0x1f>
  10028b:	00 00                	add    %al,(%bx,%si)
  10028d:	83 c4 04             	add    $0x4,%sp
  100290:	0f a9                	pop    %gs
  100292:	0f a1                	pop    %fs
  100294:	07                   	pop    %es
  100295:	1f                   	pop    %ds
  100296:	61                   	popa   
  100297:	83 c4 08             	add    $0x8,%sp
  10029a:	cf                   	iret   

0010029b <hlt>:

static inline void write_cr4(uint32_t v) {
    __asm__ __volatile__("mov %[v], %%cr4"::[v]"r"(v));
}

static inline void hlt(void) {
  10029b:	55                   	push   %bp
  10029c:	89 e5                	mov    %sp,%bp
    __asm__ __volatile__("hlt");
  10029e:	f4                   	hlt    
}
  10029f:	90                   	nop
  1002a0:	5d                   	pop    %bp
  1002a1:	c3                   	ret    

001002a2 <write_tr>:
	idt.limit = size - 1;

	__asm__ __volatile__("lidt %0"::"m"(idt));
}

static inline void write_tr (uint32_t tss_selector) {
  1002a2:	55                   	push   %bp
  1002a3:	89 e5                	mov    %sp,%bp
    __asm__ __volatile__("ltr %%ax"::"a"(tss_selector));
  1002a5:	8b 45 08             	mov    0x8(%di),%ax
  1002a8:	0f 00 d8             	ltr    %ax
}
  1002ab:	90                   	nop
  1002ac:	5d                   	pop    %bp
  1002ad:	c3                   	ret    

001002ae <far_jump>:
static inline void far_jump(uint32_t selector, uint32_t offset) {
  1002ae:	55                   	push   %bp
  1002af:	89 e5                	mov    %sp,%bp
  1002b1:	83 ec 10             	sub    $0x10,%sp
	uint32_t addr[] = {offset, selector };
  1002b4:	8b 45 0c             	mov    0xc(%di),%ax
  1002b7:	89 45 f8             	mov    %ax,-0x8(%di)
  1002ba:	8b 45 08             	mov    0x8(%di),%ax
  1002bd:	89 45 fc             	mov    %ax,-0x4(%di)
	__asm__ __volatile__("ljmpl *(%[a])"::[a]"r"(addr));
  1002c0:	8d 45 f8             	lea    -0x8(%di),%ax
  1002c3:	ff 28                	ljmp   *(%bx,%si)
}
  1002c5:	90                   	nop
  1002c6:	c9                   	leave  
  1002c7:	c3                   	ret    

001002c8 <idle_func>:
#include "cpu.h"
#include "cpu_instr.h"
static schedulor_t schedulor;

static void idle_func(void)
{
  1002c8:	55                   	push   %bp
  1002c9:	89 e5                	mov    %sp,%bp
    while (1)
    {
        hlt();
  1002cb:	e8 cb ff             	call   100299 <exception_handler_timer+0x1d>
  1002ce:	ff                   	(bad)  
  1002cf:	ff                   	(bad)  
  1002d0:	eb f9                	jmp    1002cb <idle_func+0x3>

001002d2 <idle_task_init>:
    }
}
static idle_task_init(void)
{
  1002d2:	55                   	push   %bp
  1002d3:	89 e5                	mov    %sp,%bp
  1002d5:	83 ec 08             	sub    $0x8,%sp
    task_init(&schedulor.idle_task, KERNEL, idle_func, NULL);
  1002d8:	b8 c8 02             	mov    $0x2c8,%ax
  1002db:	10 00                	adc    %al,(%bx,%si)
  1002dd:	6a 00                	push   $0x0
  1002df:	50                   	push   %ax
  1002e0:	6a 01                	push   $0x1
  1002e2:	68 1c 80             	push   $0x801c
  1002e5:	10 00                	adc    %al,(%bx,%si)
  1002e7:	e8 b5 03             	call   10069f <tss_init+0x15c>
  1002ea:	00 00                	add    %al,(%bx,%si)
  1002ec:	83 c4 10             	add    $0x10,%sp
}
  1002ef:	90                   	nop
  1002f0:	c9                   	leave  
  1002f1:	c3                   	ret    

001002f2 <first_task_init>:
static void first_task_init(void)
{
  1002f2:	55                   	push   %bp
  1002f3:	89 e5                	mov    %sp,%bp
  1002f5:	83 ec 08             	sub    $0x8,%sp
    
    task_init(&schedulor.first_task,KERNEL,0,NULL);
  1002f8:	6a 00                	push   $0x0
  1002fa:	6a 00                	push   $0x0
  1002fc:	6a 01                	push   $0x1
  1002fe:	68 b4 80             	push   $0x80b4
  100301:	10 00                	adc    %al,(%bx,%si)
  100303:	e8 99 03             	call   10069f <tss_init+0x15c>
  100306:	00 00                	add    %al,(%bx,%si)
  100308:	83 c4 10             	add    $0x10,%sp
    set_cur_task(&schedulor.first_task);
  10030b:	83 ec 0c             	sub    $0xc,%sp
  10030e:	68 b4 80             	push   $0x80b4
  100311:	10 00                	adc    %al,(%bx,%si)
  100313:	e8 73 00             	call   100389 <get_cur_task+0x8>
  100316:	00 00                	add    %al,(%bx,%si)
  100318:	83 c4 10             	add    $0x10,%sp
    write_tr(schedulor.first_task.tss_sel);
  10031b:	0f b7 05             	movzww (%di),%ax
  10031e:	38 81 10 00          	cmp    %al,0x10(%bx,%di)
  100322:	0f b7 c0             	movzww %ax,%ax
  100325:	83 ec 0c             	sub    $0xc,%sp
  100328:	50                   	push   %ax
  100329:	e8 74 ff             	call   1002a0 <hlt+0x5>
  10032c:	ff                   	(bad)  
  10032d:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  100331:	90                   	nop
  100332:	c9                   	leave  
  100333:	c3                   	ret    

00100334 <sched_init>:
void sched_init(void)
{
  100334:	55                   	push   %bp
  100335:	89 e5                	mov    %sp,%bp
  100337:	83 ec 08             	sub    $0x8,%sp
    pidalloc_init(&pidallocter);
  10033a:	83 ec 0c             	sub    $0xc,%sp
  10033d:	68 60 e1             	push   $0xe160
  100340:	12 00                	adc    (%bx,%si),%al
  100342:	e8 c6 04             	call   10080b <task_free+0xe>
  100345:	00 00                	add    %al,(%bx,%si)
  100347:	83 c4 10             	add    $0x10,%sp

    list_init(&schedulor.ready_list);
  10034a:	83 ec 0c             	sub    $0xc,%sp
  10034d:	68 04 80             	push   $0x8004
  100350:	10 00                	adc    %al,(%bx,%si)
  100352:	e8 3f 25             	call   102894 <list_is_empty+0x11>
  100355:	00 00                	add    %al,(%bx,%si)
  100357:	83 c4 10             	add    $0x10,%sp
    list_init(&schedulor.sleep_list);
  10035a:	83 ec 0c             	sub    $0xc,%sp
  10035d:	68 10 80             	push   $0x8010
  100360:	10 00                	adc    %al,(%bx,%si)
  100362:	e8 2f 25             	call   102894 <list_is_empty+0x11>
  100365:	00 00                	add    %al,(%bx,%si)
  100367:	83 c4 10             	add    $0x10,%sp
    schedulor.cur_task = NULL;
  10036a:	c7 05 00 80          	movw   $0x8000,(%di)
  10036e:	10 00                	adc    %al,(%bx,%si)
  100370:	00 00                	add    %al,(%bx,%si)
  100372:	00 00                	add    %al,(%bx,%si)
    idle_task_init();
  100374:	e8 59 ff             	call   1002d0 <idle_func+0x8>
  100377:	ff                   	(bad)  
  100378:	ff                   	(bad)  
    first_task_init();
  100379:	e8 74 ff             	call   1002f0 <idle_task_init+0x1e>
  10037c:	ff                   	(bad)  
  10037d:	ff 90 c9 c3          	call   *-0x3c37(%bx,%si)

00100381 <get_cur_task>:
}

task_t *get_cur_task(void)
{
  100381:	55                   	push   %bp
  100382:	89 e5                	mov    %sp,%bp
    return schedulor.cur_task;
  100384:	a1 00 80             	mov    0x8000,%ax
  100387:	10 00                	adc    %al,(%bx,%si)
}
  100389:	5d                   	pop    %bp
  10038a:	c3                   	ret    

0010038b <set_cur_task>:
void set_cur_task(task_t *task)
{
  10038b:	55                   	push   %bp
  10038c:	89 e5                	mov    %sp,%bp
    schedulor.cur_task = task;
  10038e:	8b 45 08             	mov    0x8(%di),%ax
  100391:	a3 00 80             	mov    %ax,0x8000
  100394:	10 00                	adc    %al,(%bx,%si)
}
  100396:	90                   	nop
  100397:	5d                   	pop    %bp
  100398:	c3                   	ret    

00100399 <get_ready_task>:

task_t *get_ready_task(void)
{
  100399:	55                   	push   %bp
  10039a:	89 e5                	mov    %sp,%bp
  10039c:	83 ec 18             	sub    $0x18,%sp
    list_node_t *fnode = list_remove_first(&schedulor.ready_list);
  10039f:	83 ec 0c             	sub    $0xc,%sp
  1003a2:	68 04 80             	push   $0x8004
  1003a5:	10 00                	adc    %al,(%bx,%si)
  1003a7:	e8 d2 25             	call   10297c <list_insert_last+0x62>
  1003aa:	00 00                	add    %al,(%bx,%si)
  1003ac:	83 c4 10             	add    $0x10,%sp
  1003af:	89 45 f4             	mov    %ax,-0xc(%di)
    if (fnode == NULL)
  1003b2:	83 7d f4 00          	cmpw   $0x0,-0xc(%di)
  1003b6:	75 07                	jne    1003bf <get_ready_task+0x26>
    {
        return NULL;
  1003b8:	b8 00 00             	mov    $0x0,%ax
  1003bb:	00 00                	add    %al,(%bx,%si)
  1003bd:	eb 1b                	jmp    1003da <get_ready_task+0x41>
    }
    task_t *ftask = list_node_parent(fnode, task_t, node);
  1003bf:	83 7d f4 00          	cmpw   $0x0,-0xc(%di)
  1003c3:	74 0a                	je     1003cf <get_ready_task+0x36>
  1003c5:	8b 45 f4             	mov    -0xc(%di),%ax
  1003c8:	2d 88 00             	sub    $0x88,%ax
  1003cb:	00 00                	add    %al,(%bx,%si)
  1003cd:	eb 05                	jmp    1003d4 <get_ready_task+0x3b>
  1003cf:	b8 00 00             	mov    $0x0,%ax
  1003d2:	00 00                	add    %al,(%bx,%si)
  1003d4:	89 45 f0             	mov    %ax,-0x10(%di)
    return ftask;
  1003d7:	8b 45 f0             	mov    -0x10(%di),%ax
}
  1003da:	c9                   	leave  
  1003db:	c3                   	ret    

001003dc <set_task_to_ready_list>:
void set_task_to_ready_list(task_t *task)
{
  1003dc:	55                   	push   %bp
  1003dd:	89 e5                	mov    %sp,%bp
  1003df:	83 ec 08             	sub    $0x8,%sp
    if (!task)
  1003e2:	83 7d 08 00          	cmpw   $0x0,0x8(%di)
  1003e6:	75 20                	jne    100408 <set_task_to_ready_list+0x2c>
    {
        dbg_error("task is empty\r\n");
  1003e8:	83 ec 0c             	sub    $0xc,%sp
  1003eb:	68 00 40             	push   $0x4000
  1003ee:	10 00                	adc    %al,(%bx,%si)
  1003f0:	6a 3d                	push   $0x3d
  1003f2:	68 20 40             	push   $0x4020
  1003f5:	10 00                	adc    %al,(%bx,%si)
  1003f7:	68 10 40             	push   $0x4010
  1003fa:	10 00                	adc    %al,(%bx,%si)
  1003fc:	6a 01                	push   $0x1
  1003fe:	e8 81 23             	call   102782 <hlt+0x5>
  100401:	00 00                	add    %al,(%bx,%si)
  100403:	83 c4 20             	add    $0x20,%sp
        return;
  100406:	eb 19                	jmp    100421 <set_task_to_ready_list+0x45>
    }
    list_insert_last(&schedulor.ready_list, &task->node);
  100408:	8b 45 08             	mov    0x8(%di),%ax
  10040b:	05 88 00             	add    $0x88,%ax
  10040e:	00 00                	add    %al,(%bx,%si)
  100410:	83 ec 08             	sub    $0x8,%sp
  100413:	50                   	push   %ax
  100414:	68 04 80             	push   $0x8004
  100417:	10 00                	adc    %al,(%bx,%si)
  100419:	e8 fc 24             	call   102918 <list_insert_first+0x5d>
  10041c:	00 00                	add    %al,(%bx,%si)
  10041e:	83 c4 10             	add    $0x10,%sp
}
  100421:	c9                   	leave  
  100422:	c3                   	ret    

00100423 <switch_to_tss>:

/**
 * 切换至TSS，即跳转实现任务切换
 */
void switch_to_tss(uint32_t tss_selector)
{
  100423:	55                   	push   %bp
  100424:	89 e5                	mov    %sp,%bp
    far_jump(tss_selector, 0);
  100426:	6a 00                	push   $0x0
  100428:	ff 75 08             	push   0x8(%di)
  10042b:	e8 7e fe             	call   1002ac <write_tr+0xa>
  10042e:	ff                   	(bad)  
  10042f:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
}
  100433:	90                   	nop
  100434:	c9                   	leave  
  100435:	c3                   	ret    

00100436 <task_switch_from_to>:
/**
 * 切换任务
 **/
void task_switch_from_to(task_t *from, task_t *to)
{
  100436:	55                   	push   %bp
  100437:	89 e5                	mov    %sp,%bp
    switch_to_tss(to->tss_sel);
  100439:	8b 45 0c             	mov    0xc(%di),%ax
  10043c:	0f b7 80 84 00       	movzww 0x84(%bx,%si),%ax
  100441:	00 00                	add    %al,(%bx,%si)
  100443:	0f b7 c0             	movzww %ax,%ax
  100446:	50                   	push   %ax
  100447:	e8 d7 ff             	call   100421 <set_task_to_ready_list+0x45>
  10044a:	ff                   	(bad)  
  10044b:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
}
  10044f:	90                   	nop
  100450:	c9                   	leave  
  100451:	c3                   	ret    

00100452 <schedul>:
void schedul(void)
{
  100452:	55                   	push   %bp
  100453:	89 e5                	mov    %sp,%bp
  100455:	83 ec 18             	sub    $0x18,%sp

    task_t *pre_task = get_cur_task();
  100458:	e8 24 ff             	call   10037f <sched_init+0x4b>
  10045b:	ff                   	(bad)  
  10045c:	ff 89 45 f0          	decw   -0xfbb(%bx,%di)
    task_t *cur_task = get_ready_task();
  100460:	e8 34 ff             	call   100397 <set_cur_task+0xc>
  100463:	ff                   	(bad)  
  100464:	ff 89 45 f4          	decw   -0xbbb(%bx,%di)
    if (pre_task == cur_task)
  100468:	8b 45 f0             	mov    -0x10(%di),%ax
  10046b:	3b 45 f4             	cmp    -0xc(%di),%ax
  10046e:	74 45                	je     1004b5 <schedul+0x63>
    {
        return;
    }
    if(cur_task == NULL)
  100470:	83 7d f4 00          	cmpw   $0x0,-0xc(%di)
  100474:	75 07                	jne    10047d <schedul+0x2b>
    {
        cur_task = &schedulor.idle_task;
  100476:	c7 45 f4 1c 80       	movw   $0x801c,-0xc(%di)
  10047b:	10 00                	adc    %al,(%bx,%si)
    }
    set_cur_task(cur_task);
  10047d:	83 ec 0c             	sub    $0xc,%sp
  100480:	ff 75 f4             	push   -0xc(%di)
  100483:	e8 03 ff             	call   100389 <get_cur_task+0x8>
  100486:	ff                   	(bad)  
  100487:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    if(pre_task != &schedulor.idle_task)
  10048b:	81 7d f0 1c 80       	cmpw   $0x801c,-0x10(%di)
  100490:	10 00                	adc    %al,(%bx,%si)
  100492:	74 0e                	je     1004a2 <schedul+0x50>
    {

        set_task_to_ready_list(pre_task);
  100494:	83 ec 0c             	sub    $0xc,%sp
  100497:	ff 75 f0             	push   -0x10(%di)
  10049a:	e8 3d ff             	call   1003da <get_ready_task+0x41>
  10049d:	ff                   	(bad)  
  10049e:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    }
    task_switch_from_to(pre_task, cur_task);
  1004a2:	83 ec 08             	sub    $0x8,%sp
  1004a5:	ff 75 f4             	push   -0xc(%di)
  1004a8:	ff 75 f0             	push   -0x10(%di)
  1004ab:	e8 86 ff             	call   100434 <switch_to_tss+0x11>
  1004ae:	ff                   	(bad)  
  1004af:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
  1004b3:	eb 01                	jmp    1004b6 <schedul+0x64>
        return;
  1004b5:	90                   	nop
}
  1004b6:	c9                   	leave  
  1004b7:	c3                   	ret    

001004b8 <task_time_tick>:

void task_time_tick(void)
{
  1004b8:	55                   	push   %bp
  1004b9:	89 e5                	mov    %sp,%bp
  1004bb:	83 ec 18             	sub    $0x18,%sp
    irq_state_t state = irq_enter_protection();
  1004be:	e8 6a 12             	call   10172b <irq_enable_global+0x9>
  1004c1:	00 00                	add    %al,(%bx,%si)
  1004c3:	89 45 f4             	mov    %ax,-0xc(%di)

    task_t *cur_task = get_cur_task();
  1004c6:	e8 b6 fe             	call   10037f <sched_init+0x4b>
  1004c9:	ff                   	(bad)  
  1004ca:	ff 89 45 f0          	decw   -0xfbb(%bx,%di)
    if (cur_task == NULL)
  1004ce:	83 7d f0 00          	cmpw   $0x0,-0x10(%di)
  1004d2:	75 28                	jne    1004fc <task_time_tick+0x44>
    {
        set_cur_task(&schedulor.idle_task);
  1004d4:	83 ec 0c             	sub    $0xc,%sp
  1004d7:	68 1c 80             	push   $0x801c
  1004da:	10 00                	adc    %al,(%bx,%si)
  1004dc:	e8 aa fe             	call   100389 <get_cur_task+0x8>
  1004df:	ff                   	(bad)  
  1004e0:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
        switch_to_tss(schedulor.idle_task.tss_sel);
  1004e4:	0f b7 05             	movzww (%di),%ax
  1004e7:	a0 80 10             	mov    0x1080,%al
  1004ea:	00 0f                	add    %cl,(%bx)
  1004ec:	b7 c0                	mov    $0xc0,%bh
  1004ee:	83 ec 0c             	sub    $0xc,%sp
  1004f1:	50                   	push   %ax
  1004f2:	e8 2c ff             	call   100421 <set_task_to_ready_list+0x45>
  1004f5:	ff                   	(bad)  
  1004f6:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
  1004fa:	eb 36                	jmp    100532 <task_time_tick+0x7a>
    }
    else
    {
        if (--cur_task->slice_ticks == 0)
  1004fc:	8b 45 f0             	mov    -0x10(%di),%ax
  1004ff:	8b 80 94 00          	mov    0x94(%bx,%si),%ax
  100503:	00 00                	add    %al,(%bx,%si)
  100505:	8d 50 ff             	lea    -0x1(%bx,%si),%dx
  100508:	8b 45 f0             	mov    -0x10(%di),%ax
  10050b:	89 90 94 00          	mov    %dx,0x94(%bx,%si)
  10050f:	00 00                	add    %al,(%bx,%si)
  100511:	8b 45 f0             	mov    -0x10(%di),%ax
  100514:	8b 80 94 00          	mov    0x94(%bx,%si),%ax
  100518:	00 00                	add    %al,(%bx,%si)
  10051a:	85 c0                	test   %ax,%ax
  10051c:	75 14                	jne    100532 <task_time_tick+0x7a>
        {
            cur_task->slice_ticks = cur_task->attr.time_slice;
  10051e:	8b 45 f0             	mov    -0x10(%di),%ax
  100521:	8b 50 0c             	mov    0xc(%bx,%si),%dx
  100524:	8b 45 f0             	mov    -0x10(%di),%ax
  100527:	89 90 94 00          	mov    %dx,0x94(%bx,%si)
  10052b:	00 00                	add    %al,(%bx,%si)
            schedul();
  10052d:	e8 20 ff             	call   100450 <task_switch_from_to+0x1a>
  100530:	ff                   	(bad)  
  100531:	ff 83 ec 0c          	incw   0xcec(%bp,%di)
        }
    }

    irq_leave_protection(state);
  100535:	ff 75 f4             	push   -0xc(%di)
  100538:	e8 08 12             	call   101743 <irq_enter_protection+0x16>
  10053b:	00 00                	add    %al,(%bx,%si)
  10053d:	83 c4 10             	add    $0x10,%sp
  100540:	90                   	nop
  100541:	c9                   	leave  
  100542:	c3                   	ret    

00100543 <tss_init>:

task_t task_pool[TASK_MAX_NR];


int tss_init(task_t* task,int type,ph_addr_t entry,task_attr_t *attr)
{
  100543:	55                   	push   %bp
  100544:	89 e5                	mov    %sp,%bp
  100546:	83 ec 28             	sub    $0x28,%sp
    int tss_sel = gdt_alloc_desc();
  100549:	e8 08 12             	call   101754 <irq_leave_protection+0xf>
  10054c:	00 00                	add    %al,(%bx,%si)
  10054e:	89 45 ec             	mov    %ax,-0x14(%di)
    if(tss_sel<0)
  100551:	83 7d ec 00          	cmpw   $0x0,-0x14(%di)
  100555:	79 2e                	jns    100585 <tss_init+0x42>
    {
        dbg_error("tss desc alloc failed:%s\r\n",err_str[DESC_TSS_CROSS_BORDER]);
  100557:	a1 08 50             	mov    0x5008,%ax
  10055a:	10 00                	adc    %al,(%bx,%si)
  10055c:	83 ec 08             	sub    $0x8,%sp
  10055f:	50                   	push   %ax
  100560:	68 88 40             	push   $0x4088
  100563:	10 00                	adc    %al,(%bx,%si)
  100565:	6a 10                	push   $0x10
  100567:	68 d4 40             	push   $0x40d4
  10056a:	10 00                	adc    %al,(%bx,%si)
  10056c:	68 a3 40             	push   $0x40a3
  10056f:	10 00                	adc    %al,(%bx,%si)
  100571:	6a 01                	push   $0x1
  100573:	e8 0c 22             	call   102782 <hlt+0x5>
  100576:	00 00                	add    %al,(%bx,%si)
  100578:	83 c4 20             	add    $0x20,%sp
        return DESC_TSS_CROSS_BORDER;
  10057b:	b8 02 00             	mov    $0x2,%ax
  10057e:	00 00                	add    %al,(%bx,%si)
  100580:	e9 1a 01             	jmp    10069d <tss_init+0x15a>
  100583:	00 00                	add    %al,(%bx,%si)
    }
    gdt_set_tss(tss_sel,(ph_addr_t)&task->tss,sizeof(tss_t));
  100585:	8b 45 08             	mov    0x8(%di),%ax
  100588:	83 c0 1c             	add    $0x1c,%ax
  10058b:	83 ec 04             	sub    $0x4,%sp
  10058e:	6a 68                	push   $0x68
  100590:	50                   	push   %ax
  100591:	ff 75 ec             	push   -0x14(%di)
  100594:	e8 61 12             	call   1017f8 <gdt_free_desc+0x2c>
  100597:	00 00                	add    %al,(%bx,%si)
  100599:	83 c4 10             	add    $0x10,%sp
    memset(&task->tss,0,sizeof(tss_t));
  10059c:	8b 45 08             	mov    0x8(%di),%ax
  10059f:	83 c0 1c             	add    $0x1c,%ax
  1005a2:	83 ec 04             	sub    $0x4,%sp
  1005a5:	6a 68                	push   $0x68
  1005a7:	6a 00                	push   $0x0
  1005a9:	50                   	push   %ax
  1005aa:	e8 27 26             	call   102bd4 <memcpy+0x3e>
  1005ad:	00 00                	add    %al,(%bx,%si)
  1005af:	83 c4 10             	add    $0x10,%sp

    ph_addr_t kernel_stack_base = mm_alloc_one_page();
  1005b2:	e8 e0 1c             	call   102295 <mm_free_pages+0x133>
  1005b5:	00 00                	add    %al,(%bx,%si)
  1005b7:	89 45 e8             	mov    %ax,-0x18(%di)
        gdt_free_desc(tss_sel);
        return MEM_NOT_ENOUGH;
    }

    int code_sel,data_sel;
    if(type == KERNEL)
  1005ba:	83 7d 0c 01          	cmpw   $0x1,0xc(%di)
  1005be:	75 2b                	jne    1005eb <tss_init+0xa8>
    {
        code_sel = SELECTOR_KERNEL_CODE_SEG;
  1005c0:	c7 45 f0 18 00       	movw   $0x18,-0x10(%di)
  1005c5:	00 00                	add    %al,(%bx,%si)
        data_sel = SELECTOR_KERNEL_DATA_SEG;
  1005c7:	c7 45 f4 20 00       	movw   $0x20,-0xc(%di)
  1005cc:	00 00                	add    %al,(%bx,%si)
        task->tss.esp = task->tss.esp0 = kernel_stack_base + MEM_PAGE_SIZE -1;
  1005ce:	8b 45 e8             	mov    -0x18(%di),%ax
  1005d1:	8d 90 ff 0f          	lea    0xfff(%bx,%si),%dx
  1005d5:	00 00                	add    %al,(%bx,%si)
  1005d7:	8b 45 08             	mov    0x8(%di),%ax
  1005da:	89 50 20             	mov    %dx,0x20(%bx,%si)
  1005dd:	8b 45 08             	mov    0x8(%di),%ax
  1005e0:	8b 50 20             	mov    0x20(%bx,%si),%dx
  1005e3:	8b 45 08             	mov    0x8(%di),%ax
  1005e6:	89 50 54             	mov    %dx,0x54(%bx,%si)
  1005e9:	eb 27                	jmp    100612 <tss_init+0xcf>
    }else{
        code_sel = SELECTOR_USR_CODE_SEG;
  1005eb:	c7 45 f0 2b 00       	movw   $0x2b,-0x10(%di)
  1005f0:	00 00                	add    %al,(%bx,%si)
        data_sel = SELECTOR_USR_DATA_SEG;
  1005f2:	c7 45 f4 33 00       	movw   $0x33,-0xc(%di)
  1005f7:	00 00                	add    %al,(%bx,%si)
        task->tss.esp = 0xFFFFFFFF;
  1005f9:	8b 45 08             	mov    0x8(%di),%ax
  1005fc:	c7 40 54 ff ff       	movw   $0xffff,0x54(%bx,%si)
  100601:	ff                   	(bad)  
  100602:	ff 8b 45 e8          	decw   -0x17bb(%bp,%di)
        task->tss.esp0 = kernel_stack_base + MEM_PAGE_SIZE -1;
  100606:	8d 90 ff 0f          	lea    0xfff(%bx,%si),%dx
  10060a:	00 00                	add    %al,(%bx,%si)
  10060c:	8b 45 08             	mov    0x8(%di),%ax
  10060f:	89 50 20             	mov    %dx,0x20(%bx,%si)
    }

    ph_addr_t page_dir = mmu_create_task_pgd();
  100612:	e8 8f 16             	call   101ca4 <mmu_get_phaddr+0x10b>
  100615:	00 00                	add    %al,(%bx,%si)
  100617:	89 45 e4             	mov    %ax,-0x1c(%di)
        gdt_free_desc(tss_sel);
        mm_free_one_page(kernel_stack_base);
        return MEM_NOT_ENOUGH;
    }

    task->tss.eip = entry;
  10061a:	8b 45 08             	mov    0x8(%di),%ax
  10061d:	8b 55 10             	mov    0x10(%di),%dx
  100620:	89 50 3c             	mov    %dx,0x3c(%bx,%si)
    task->tss.eflags = EFLAGS_DEFAULT| EFLAGS_IF;
  100623:	8b 45 08             	mov    0x8(%di),%ax
  100626:	c7 40 40 02 02       	movw   $0x202,0x40(%bx,%si)
  10062b:	00 00                	add    %al,(%bx,%si)
    task->tss.ss0 = SELECTOR_KERNEL_CODE_SEG;
  10062d:	8b 45 08             	mov    0x8(%di),%ax
  100630:	c7 40 24 18 00       	movw   $0x18,0x24(%bx,%si)
  100635:	00 00                	add    %al,(%bx,%si)
    task->tss.es = task->tss.ss = task->tss.ds = task->tss.fs 
            = task->tss.gs = data_sel;   // 全部采用同一数据段
  100637:	8b 55 f4             	mov    -0xc(%di),%dx
  10063a:	8b 45 08             	mov    0x8(%di),%ax
  10063d:	89 50 78             	mov    %dx,0x78(%bx,%si)
  100640:	8b 45 08             	mov    0x8(%di),%ax
  100643:	8b 50 78             	mov    0x78(%bx,%si),%dx
  100646:	8b 45 08             	mov    0x8(%di),%ax
  100649:	89 50 74             	mov    %dx,0x74(%bx,%si)
    task->tss.es = task->tss.ss = task->tss.ds = task->tss.fs 
  10064c:	8b 45 08             	mov    0x8(%di),%ax
  10064f:	8b 50 74             	mov    0x74(%bx,%si),%dx
  100652:	8b 45 08             	mov    0x8(%di),%ax
  100655:	89 50 70             	mov    %dx,0x70(%bx,%si)
  100658:	8b 45 08             	mov    0x8(%di),%ax
  10065b:	8b 50 70             	mov    0x70(%bx,%si),%dx
  10065e:	8b 45 08             	mov    0x8(%di),%ax
  100661:	89 50 6c             	mov    %dx,0x6c(%bx,%si)
  100664:	8b 45 08             	mov    0x8(%di),%ax
  100667:	8b 50 6c             	mov    0x6c(%bx,%si),%dx
  10066a:	8b 45 08             	mov    0x8(%di),%ax
  10066d:	89 50 64             	mov    %dx,0x64(%bx,%si)
    task->tss.cs = code_sel; 
  100670:	8b 55 f0             	mov    -0x10(%di),%dx
  100673:	8b 45 08             	mov    0x8(%di),%ax
  100676:	89 50 68             	mov    %dx,0x68(%bx,%si)

    task->tss.cr3 = page_dir;
  100679:	8b 45 08             	mov    0x8(%di),%ax
  10067c:	8b 55 e4             	mov    -0x1c(%di),%dx
  10067f:	89 50 38             	mov    %dx,0x38(%bx,%si)
    task->tss_sel = tss_sel;
  100682:	8b 45 ec             	mov    -0x14(%di),%ax
  100685:	89 c2                	mov    %ax,%dx
  100687:	8b 45 08             	mov    0x8(%di),%ax
  10068a:	66 89 90 84 00       	mov    %edx,0x84(%bx,%si)
  10068f:	00 00                	add    %al,(%bx,%si)
    task->entry = entry;
  100691:	8b 45 08             	mov    0x8(%di),%ax
  100694:	8b 55 10             	mov    0x10(%di),%dx
  100697:	89 50 14             	mov    %dx,0x14(%bx,%si)

    return ERROR_OK;   
  10069a:	b8 00 00             	mov    $0x0,%ax
  10069d:	00 00                	add    %al,(%bx,%si)
}
  10069f:	c9                   	leave  
  1006a0:	c3                   	ret    

001006a1 <task_init>:

int task_init(task_t *task,int type,ph_addr_t entry,task_attr_t *attr)
{
  1006a1:	55                   	push   %bp
  1006a2:	89 e5                	mov    %sp,%bp
  1006a4:	83 ec 18             	sub    $0x18,%sp
    if(!task){
  1006a7:	83 7d 08 00          	cmpw   $0x0,0x8(%di)
  1006ab:	75 0a                	jne    1006b7 <task_init+0x16>
        return TASK_NULL;
  1006ad:	b8 01 00             	mov    $0x1,%ax
  1006b0:	00 00                	add    %al,(%bx,%si)
  1006b2:	e9 df 00             	jmp    100794 <task_init+0xf3>
  1006b5:	00 00                	add    %al,(%bx,%si)
    }
    if(attr)
  1006b7:	83 7d 14 00          	cmpw   $0x0,0x14(%di)
  1006bb:	74 34                	je     1006f1 <task_init+0x50>
    {
        task->attr.sched_policy = attr->sched_policy;
  1006bd:	8b 45 14             	mov    0x14(%di),%ax
  1006c0:	8b 10                	mov    (%bx,%si),%dx
  1006c2:	8b 45 08             	mov    0x8(%di),%ax
  1006c5:	89 50 08             	mov    %dx,0x8(%bx,%si)
        task->attr.stack_size = attr->stack_size;
  1006c8:	8b 45 14             	mov    0x14(%di),%ax
  1006cb:	8b 50 08             	mov    0x8(%bx,%si),%dx
  1006ce:	8b 45 08             	mov    0x8(%di),%ax
  1006d1:	89 50 10             	mov    %dx,0x10(%bx,%si)
        task->slice_ticks =task->attr.time_slice = attr->time_slice;
  1006d4:	8b 45 14             	mov    0x14(%di),%ax
  1006d7:	8b 50 04             	mov    0x4(%bx,%si),%dx
  1006da:	8b 45 08             	mov    0x8(%di),%ax
  1006dd:	89 50 0c             	mov    %dx,0xc(%bx,%si)
  1006e0:	8b 45 08             	mov    0x8(%di),%ax
  1006e3:	8b 50 0c             	mov    0xc(%bx,%si),%dx
  1006e6:	8b 45 08             	mov    0x8(%di),%ax
  1006e9:	89 90 94 00          	mov    %dx,0x94(%bx,%si)
  1006ed:	00 00                	add    %al,(%bx,%si)
  1006ef:	eb 2d                	jmp    10071e <task_init+0x7d>
    }
    else{
        task->attr.sched_policy = TASK_SCHED_POLICY_DEFAULT;
  1006f1:	8b 45 08             	mov    0x8(%di),%ax
  1006f4:	c7 40 08 00 00       	movw   $0x0,0x8(%bx,%si)
  1006f9:	00 00                	add    %al,(%bx,%si)
        task->attr.stack_size = MEM_PAGE_SIZE;
  1006fb:	8b 45 08             	mov    0x8(%di),%ax
  1006fe:	c7 40 10 00 10       	movw   $0x1000,0x10(%bx,%si)
  100703:	00 00                	add    %al,(%bx,%si)
        task->slice_ticks = task->attr.time_slice = TASK_TIME_SLICE_DEFAULT;
  100705:	8b 45 08             	mov    0x8(%di),%ax
  100708:	c7 40 0c 0a 00       	movw   $0xa,0xc(%bx,%si)
  10070d:	00 00                	add    %al,(%bx,%si)
  10070f:	8b 45 08             	mov    0x8(%di),%ax
  100712:	8b 50 0c             	mov    0xc(%bx,%si),%dx
  100715:	8b 45 08             	mov    0x8(%di),%ax
  100718:	89 90 94 00          	mov    %dx,0x94(%bx,%si)
  10071c:	00 00                	add    %al,(%bx,%si)
    }
    int ret;
    ret = tss_init(task,type,entry,attr);
  10071e:	ff 75 14             	push   0x14(%di)
  100721:	ff 75 10             	push   0x10(%di)
  100724:	ff 75 0c             	push   0xc(%di)
  100727:	ff 75 08             	push   0x8(%di)
  10072a:	e8 14 fe             	call   100541 <task_time_tick+0x89>
  10072d:	ff                   	(bad)  
  10072e:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
  100732:	89 45 f4             	mov    %ax,-0xc(%di)
    if(ret != ERROR_OK)
  100735:	83 7d f4 00          	cmpw   $0x0,-0xc(%di)
  100739:	74 2e                	je     100769 <task_init+0xc8>
    {
        dbg_error("%s\r\n",err_str[ret]);
  10073b:	8b 45 f4             	mov    -0xc(%di),%ax
  10073e:	8b 04                	mov    (%si),%ax
  100740:	85 00                	test   %ax,(%bx,%si)
  100742:	50                   	push   %ax
  100743:	10 00                	adc    %al,(%bx,%si)
  100745:	83 ec 08             	sub    $0x8,%sp
  100748:	50                   	push   %ax
  100749:	68 af 40             	push   $0x40af
  10074c:	10 00                	adc    %al,(%bx,%si)
  10074e:	6a 56                	push   $0x56
  100750:	68 e0 40             	push   $0x40e0
  100753:	10 00                	adc    %al,(%bx,%si)
  100755:	68 a3 40             	push   $0x40a3
  100758:	10 00                	adc    %al,(%bx,%si)
  10075a:	6a 01                	push   $0x1
  10075c:	e8 23 20             	call   102782 <hlt+0x5>
  10075f:	00 00                	add    %al,(%bx,%si)
  100761:	83 c4 20             	add    $0x20,%sp
        return ret;
  100764:	8b 45 f4             	mov    -0xc(%di),%ax
  100767:	eb 2d                	jmp    100796 <task_init+0xf5>
    }
    task->pid = pid_alloc(&pidallocter);
  100769:	83 ec 0c             	sub    $0xc,%sp
  10076c:	68 60 e1             	push   $0xe160
  10076f:	12 00                	adc    (%bx,%si),%al
  100771:	e8 27 01             	call   10089b <pid_is_allocated+0x66>
  100774:	00 00                	add    %al,(%bx,%si)
  100776:	83 c4 10             	add    $0x10,%sp
  100779:	8b 55 08             	mov    0x8(%di),%dx
  10077c:	89 42 18             	mov    %ax,0x18(%bp,%si)
    task->type = type;
  10077f:	8b 55 0c             	mov    0xc(%di),%dx
  100782:	8b 45 08             	mov    0x8(%di),%ax
  100785:	89 50 04             	mov    %dx,0x4(%bx,%si)
    task->state = TASK_CREATED;
  100788:	8b 45 08             	mov    0x8(%di),%ax
  10078b:	c7 00 00 00          	movw   $0x0,(%bx,%si)
  10078f:	00 00                	add    %al,(%bx,%si)
    return 0;
  100791:	b8 00 00             	mov    $0x0,%ax
  100794:	00 00                	add    %al,(%bx,%si)
}
  100796:	c9                   	leave  
  100797:	c3                   	ret    

00100798 <task_alloc>:

task_t* task_alloc(void)
{
  100798:	55                   	push   %bp
  100799:	89 e5                	mov    %sp,%bp
  10079b:	83 ec 18             	sub    $0x18,%sp
    for (int i = 0; i < TASK_MAX_NR; i++)
  10079e:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
  1007a3:	00 00                	add    %al,(%bx,%si)
  1007a5:	eb 28                	jmp    1007cf <task_alloc+0x37>
    {
        if(task_pool[i].type == TASKNONE)
  1007a7:	8b 45 f4             	mov    -0xc(%di),%ax
  1007aa:	69 c0 98 00          	imul   $0x98,%ax,%ax
  1007ae:	00 00                	add    %al,(%bx,%si)
  1007b0:	05 64 81             	add    $0x8164,%ax
  1007b3:	10 00                	adc    %al,(%bx,%si)
  1007b5:	8b 00                	mov    (%bx,%si),%ax
  1007b7:	85 c0                	test   %ax,%ax
  1007b9:	75 10                	jne    1007cb <task_alloc+0x33>
        {
            return &task_pool[i];
  1007bb:	8b 45 f4             	mov    -0xc(%di),%ax
  1007be:	69 c0 98 00          	imul   $0x98,%ax,%ax
  1007c2:	00 00                	add    %al,(%bx,%si)
  1007c4:	05 60 81             	add    $0x8160,%ax
  1007c7:	10 00                	adc    %al,(%bx,%si)
  1007c9:	eb 30                	jmp    1007fb <task_alloc+0x63>
    for (int i = 0; i < TASK_MAX_NR; i++)
  1007cb:	83 45 f4 01          	addw   $0x1,-0xc(%di)
  1007cf:	81 7d f4 ff 03       	cmpw   $0x3ff,-0xc(%di)
  1007d4:	00 00                	add    %al,(%bx,%si)
  1007d6:	7e cf                	jle    1007a7 <task_alloc+0xf>
        }
    }
    dbg_error("there is none in task pool\r\n");
  1007d8:	83 ec 0c             	sub    $0xc,%sp
  1007db:	68 b4 40             	push   $0x40b4
  1007de:	10 00                	adc    %al,(%bx,%si)
  1007e0:	6a 68                	push   $0x68
  1007e2:	68 ec 40             	push   $0x40ec
  1007e5:	10 00                	adc    %al,(%bx,%si)
  1007e7:	68 a3 40             	push   $0x40a3
  1007ea:	10 00                	adc    %al,(%bx,%si)
  1007ec:	6a 01                	push   $0x1
  1007ee:	e8 91 1f             	call   102782 <hlt+0x5>
  1007f1:	00 00                	add    %al,(%bx,%si)
  1007f3:	83 c4 20             	add    $0x20,%sp
    return NULL;
  1007f6:	b8 00 00             	mov    $0x0,%ax
  1007f9:	00 00                	add    %al,(%bx,%si)
}
  1007fb:	c9                   	leave  
  1007fc:	c3                   	ret    

001007fd <task_free>:

void task_free(task_t* task)
{
  1007fd:	55                   	push   %bp
  1007fe:	89 e5                	mov    %sp,%bp
    task->type = TASKNONE;
  100800:	8b 45 08             	mov    0x8(%di),%ax
  100803:	c7 40 04 00 00       	movw   $0x0,0x4(%bx,%si)
  100808:	00 00                	add    %al,(%bx,%si)
  10080a:	90                   	nop
  10080b:	5d                   	pop    %bp
  10080c:	c3                   	ret    

0010080d <pidalloc_init>:
pidalloc_t pidallocter;
/**
 * 初始化 PID 分配器
 * @param alloc PID 分配器
 */
void pidalloc_init(pidalloc_t *alloc) {
  10080d:	55                   	push   %bp
  10080e:	89 e5                	mov    %sp,%bp
  100810:	83 ec 10             	sub    $0x10,%sp
    for (int i = 0; i < BITMAP_SIZE; i++) {
  100813:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
  100818:	00 00                	add    %al,(%bx,%si)
  10081a:	eb 0f                	jmp    10082b <pidalloc_init+0x1e>
        alloc->bitmap[i] = 0;  // 将所有 PID 初始化为未分配
  10081c:	8b 55 08             	mov    0x8(%di),%dx
  10081f:	8b 45 fc             	mov    -0x4(%di),%ax
  100822:	01 d0                	add    %dx,%ax
  100824:	c6 00 00             	movb   $0x0,(%bx,%si)
    for (int i = 0; i < BITMAP_SIZE; i++) {
  100827:	83 45 fc 01          	addw   $0x1,-0x4(%di)
  10082b:	83 7d fc 7f          	cmpw   $0x7f,-0x4(%di)
  10082f:	7e eb                	jle    10081c <pidalloc_init+0xf>
    }
}
  100831:	90                   	nop
  100832:	90                   	nop
  100833:	c9                   	leave  
  100834:	c3                   	ret    

00100835 <pid_is_allocated>:
 * 检查指定 PID 是否已被分配
 * @param alloc PID 分配器
 * @param pid 待检查的 PID
 * @return true - 已分配，false - 未分配
 */
int pid_is_allocated(pidalloc_t *alloc, int pid) {
  100835:	55                   	push   %bp
  100836:	89 e5                	mov    %sp,%bp
  100838:	83 ec 10             	sub    $0x10,%sp
    if (pid <= 0 || pid > PID_MAX_NR) {
  10083b:	83 7d 0c 00          	cmpw   $0x0,0xc(%di)
  10083f:	7e 09                	jle    10084a <pid_is_allocated+0x15>
  100841:	81 7d 0c 00 04       	cmpw   $0x400,0xc(%di)
  100846:	00 00                	add    %al,(%bx,%si)
  100848:	7e 07                	jle    100851 <pid_is_allocated+0x1c>
        return false;  // PID 无效
  10084a:	b8 00 00             	mov    $0x0,%ax
  10084d:	00 00                	add    %al,(%bx,%si)
  10084f:	eb 4a                	jmp    10089b <pid_is_allocated+0x66>
    }

    int byte_index = (pid - 1) / 8;
  100851:	8b 45 0c             	mov    0xc(%di),%ax
  100854:	83 e8 01             	sub    $0x1,%ax
  100857:	8d 50 07             	lea    0x7(%bx,%si),%dx
  10085a:	85 c0                	test   %ax,%ax
  10085c:	0f 48 c2             	cmovs  %dx,%ax
  10085f:	c1 f8 03             	sar    $0x3,%ax
  100862:	89 45 fc             	mov    %ax,-0x4(%di)
    int bit_index = (pid - 1) % 8;
  100865:	8b 45 0c             	mov    0xc(%di),%ax
  100868:	83 e8 01             	sub    $0x1,%ax
  10086b:	99                   	cwtd   
  10086c:	c1 ea 1d             	shr    $0x1d,%dx
  10086f:	01 d0                	add    %dx,%ax
  100871:	83 e0 07             	and    $0x7,%ax
  100874:	29 d0                	sub    %dx,%ax
  100876:	89 45 f8             	mov    %ax,-0x8(%di)
    return (alloc->bitmap[byte_index] & (1 << bit_index)) != 0;
  100879:	8b 55 08             	mov    0x8(%di),%dx
  10087c:	8b 45 fc             	mov    -0x4(%di),%ax
  10087f:	01 d0                	add    %dx,%ax
  100881:	0f b6 00             	movzbw (%bx,%si),%ax
  100884:	0f b6 d0             	movzbw %al,%dx
  100887:	8b 45 f8             	mov    -0x8(%di),%ax
  10088a:	89 c1                	mov    %ax,%cx
  10088c:	d3 fa                	sar    %cl,%dx
  10088e:	89 d0                	mov    %dx,%ax
  100890:	83 e0 01             	and    $0x1,%ax
  100893:	85 c0                	test   %ax,%ax
  100895:	0f 95 c0             	setne  %al
  100898:	0f b6 c0             	movzbw %al,%ax
}
  10089b:	c9                   	leave  
  10089c:	c3                   	ret    

0010089d <pid_alloc>:
/**
 * 分配一个 PID
 * @param alloc PID 分配器
 * @return 分配的 PID，-1 表示没有可用的 PID
 */
int pid_alloc(pidalloc_t *alloc) {
  10089d:	55                   	push   %bp
  10089e:	89 e5                	mov    %sp,%bp
  1008a0:	53                   	push   %bx
  1008a1:	83 ec 10             	sub    $0x10,%sp
    for (int i = 0; i < PID_MAX_NR; i++) {
  1008a4:	c7 45 f8 00 00       	movw   $0x0,-0x8(%di)
  1008a9:	00 00                	add    %al,(%bx,%si)
  1008ab:	eb 75                	jmp    100922 <pid_alloc+0x85>
        int byte_index = i / 8;
  1008ad:	8b 45 f8             	mov    -0x8(%di),%ax
  1008b0:	8d 50 07             	lea    0x7(%bx,%si),%dx
  1008b3:	85 c0                	test   %ax,%ax
  1008b5:	0f 48 c2             	cmovs  %dx,%ax
  1008b8:	c1 f8 03             	sar    $0x3,%ax
  1008bb:	89 45 f4             	mov    %ax,-0xc(%di)
        int bit_index = i % 8;
  1008be:	8b 45 f8             	mov    -0x8(%di),%ax
  1008c1:	99                   	cwtd   
  1008c2:	c1 ea 1d             	shr    $0x1d,%dx
  1008c5:	01 d0                	add    %dx,%ax
  1008c7:	83 e0 07             	and    $0x7,%ax
  1008ca:	29 d0                	sub    %dx,%ax
  1008cc:	89 45 f0             	mov    %ax,-0x10(%di)

        // 如果当前位未被占用
        if ((alloc->bitmap[byte_index] & (1 << bit_index)) == 0) {
  1008cf:	8b 55 08             	mov    0x8(%di),%dx
  1008d2:	8b 45 f4             	mov    -0xc(%di),%ax
  1008d5:	01 d0                	add    %dx,%ax
  1008d7:	0f b6 00             	movzbw (%bx,%si),%ax
  1008da:	0f b6 d0             	movzbw %al,%dx
  1008dd:	8b 45 f0             	mov    -0x10(%di),%ax
  1008e0:	89 c1                	mov    %ax,%cx
  1008e2:	d3 fa                	sar    %cl,%dx
  1008e4:	89 d0                	mov    %dx,%ax
  1008e6:	83 e0 01             	and    $0x1,%ax
  1008e9:	85 c0                	test   %ax,%ax
  1008eb:	75 31                	jne    10091e <pid_alloc+0x81>
            // 设置该位为 1，表示 PID 被占用
            alloc->bitmap[byte_index] |= (1 << bit_index);
  1008ed:	8b 55 08             	mov    0x8(%di),%dx
  1008f0:	8b 45 f4             	mov    -0xc(%di),%ax
  1008f3:	01 d0                	add    %dx,%ax
  1008f5:	0f b6 00             	movzbw (%bx,%si),%ax
  1008f8:	89 c3                	mov    %ax,%bx
  1008fa:	8b 45 f0             	mov    -0x10(%di),%ax
  1008fd:	ba 01 00             	mov    $0x1,%dx
  100900:	00 00                	add    %al,(%bx,%si)
  100902:	89 c1                	mov    %ax,%cx
  100904:	d3 e2                	shl    %cl,%dx
  100906:	89 d0                	mov    %dx,%ax
  100908:	09 d8                	or     %bx,%ax
  10090a:	89 c2                	mov    %ax,%dx
  10090c:	8b 4d 08             	mov    0x8(%di),%cx
  10090f:	8b 45 f4             	mov    -0xc(%di),%ax
  100912:	01 c8                	add    %cx,%ax
  100914:	88 10                	mov    %dl,(%bx,%si)
            return i + 1;  // 返回分配的 PID（PID 从 1 开始）
  100916:	8b 45 f8             	mov    -0x8(%di),%ax
  100919:	83 c0 01             	add    $0x1,%ax
  10091c:	eb 12                	jmp    100930 <pid_alloc+0x93>
    for (int i = 0; i < PID_MAX_NR; i++) {
  10091e:	83 45 f8 01          	addw   $0x1,-0x8(%di)
  100922:	81 7d f8 ff 03       	cmpw   $0x3ff,-0x8(%di)
  100927:	00 00                	add    %al,(%bx,%si)
  100929:	7e 82                	jle    1008ad <pid_alloc+0x10>
        }
    }

    return -1;  // 如果没有空闲 PID，返回 -1
  10092b:	b8 ff ff             	mov    $0xffff,%ax
  10092e:	ff                   	(bad)  
  10092f:	ff 8b 5d fc          	decw   -0x3a3(%bp,%di)
}
  100933:	c9                   	leave  
  100934:	c3                   	ret    

00100935 <pid_free>:
/**
 * 释放指定的 PID
 * @param alloc PID 分配器
 * @param pid 待释放的 PID
 */
void pid_free(pidalloc_t *alloc, int pid) {
  100935:	55                   	push   %bp
  100936:	89 e5                	mov    %sp,%bp
  100938:	53                   	push   %bx
  100939:	83 ec 10             	sub    $0x10,%sp
    if (pid <= 0 || pid > PID_MAX_NR) {
  10093c:	83 7d 0c 00          	cmpw   $0x0,0xc(%di)
  100940:	7e 5e                	jle    1009a0 <pid_free+0x6b>
  100942:	81 7d 0c 00 04       	cmpw   $0x400,0xc(%di)
  100947:	00 00                	add    %al,(%bx,%si)
  100949:	7f 55                	jg     1009a0 <pid_free+0x6b>
        return;  // 无效的 PID
    }

    int byte_index = (pid - 1) / 8;
  10094b:	8b 45 0c             	mov    0xc(%di),%ax
  10094e:	83 e8 01             	sub    $0x1,%ax
  100951:	8d 50 07             	lea    0x7(%bx,%si),%dx
  100954:	85 c0                	test   %ax,%ax
  100956:	0f 48 c2             	cmovs  %dx,%ax
  100959:	c1 f8 03             	sar    $0x3,%ax
  10095c:	89 45 f8             	mov    %ax,-0x8(%di)
    int bit_index = (pid - 1) % 8;
  10095f:	8b 45 0c             	mov    0xc(%di),%ax
  100962:	83 e8 01             	sub    $0x1,%ax
  100965:	99                   	cwtd   
  100966:	c1 ea 1d             	shr    $0x1d,%dx
  100969:	01 d0                	add    %dx,%ax
  10096b:	83 e0 07             	and    $0x7,%ax
  10096e:	29 d0                	sub    %dx,%ax
  100970:	89 45 f4             	mov    %ax,-0xc(%di)

    // 将该位设置为 0，表示 PID 被释放
    alloc->bitmap[byte_index] &= ~(1 << bit_index);
  100973:	8b 55 08             	mov    0x8(%di),%dx
  100976:	8b 45 f8             	mov    -0x8(%di),%ax
  100979:	01 d0                	add    %dx,%ax
  10097b:	0f b6 00             	movzbw (%bx,%si),%ax
  10097e:	89 c3                	mov    %ax,%bx
  100980:	8b 45 f4             	mov    -0xc(%di),%ax
  100983:	ba 01 00             	mov    $0x1,%dx
  100986:	00 00                	add    %al,(%bx,%si)
  100988:	89 c1                	mov    %ax,%cx
  10098a:	d3 e2                	shl    %cl,%dx
  10098c:	89 d0                	mov    %dx,%ax
  10098e:	f7 d0                	not    %ax
  100990:	21 d8                	and    %bx,%ax
  100992:	89 c2                	mov    %ax,%dx
  100994:	8b 4d 08             	mov    0x8(%di),%cx
  100997:	8b 45 f8             	mov    -0x8(%di),%ax
  10099a:	01 c8                	add    %cx,%ax
  10099c:	88 10                	mov    %dl,(%bx,%si)
  10099e:	eb 01                	jmp    1009a1 <pid_free+0x6c>
        return;  // 无效的 PID
  1009a0:	90                   	nop
}
  1009a1:	8b 5d fc             	mov    -0x4(%di),%bx
  1009a4:	c9                   	leave  
  1009a5:	c3                   	ret    

001009a6 <pidalloc_print>:

/**
 * 打印所有被占用的 PID
 * @param alloc PID 分配器
 */
void pidalloc_print(pidalloc_t *alloc) {
  1009a6:	55                   	push   %bp
  1009a7:	89 e5                	mov    %sp,%bp
  1009a9:	83 ec 18             	sub    $0x18,%sp
    dbg_info("Allocated PIDs: ");
  1009ac:	83 ec 0c             	sub    $0xc,%sp
  1009af:	68 f8 40             	push   $0x40f8
  1009b2:	10 00                	adc    %al,(%bx,%si)
  1009b4:	6a 4a                	push   $0x4a
  1009b6:	68 1c 41             	push   $0x411c
  1009b9:	10 00                	adc    %al,(%bx,%si)
  1009bb:	68 09 41             	push   $0x4109
  1009be:	10 00                	adc    %al,(%bx,%si)
  1009c0:	6a 03                	push   $0x3
  1009c2:	e8 bd 1d             	call   102782 <hlt+0x5>
  1009c5:	00 00                	add    %al,(%bx,%si)
  1009c7:	83 c4 20             	add    $0x20,%sp
    for (int i = 0; i < PID_MAX_NR; i++) {
  1009ca:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
  1009cf:	00 00                	add    %al,(%bx,%si)
  1009d1:	eb 69                	jmp    100a3c <pidalloc_print+0x96>
        int byte_index = i / 8;
  1009d3:	8b 45 f4             	mov    -0xc(%di),%ax
  1009d6:	8d 50 07             	lea    0x7(%bx,%si),%dx
  1009d9:	85 c0                	test   %ax,%ax
  1009db:	0f 48 c2             	cmovs  %dx,%ax
  1009de:	c1 f8 03             	sar    $0x3,%ax
  1009e1:	89 45 f0             	mov    %ax,-0x10(%di)
        int bit_index = i % 8;
  1009e4:	8b 45 f4             	mov    -0xc(%di),%ax
  1009e7:	99                   	cwtd   
  1009e8:	c1 ea 1d             	shr    $0x1d,%dx
  1009eb:	01 d0                	add    %dx,%ax
  1009ed:	83 e0 07             	and    $0x7,%ax
  1009f0:	29 d0                	sub    %dx,%ax
  1009f2:	89 45 ec             	mov    %ax,-0x14(%di)
        if ((alloc->bitmap[byte_index] & (1 << bit_index)) != 0) {
  1009f5:	8b 55 08             	mov    0x8(%di),%dx
  1009f8:	8b 45 f0             	mov    -0x10(%di),%ax
  1009fb:	01 d0                	add    %dx,%ax
  1009fd:	0f b6 00             	movzbw (%bx,%si),%ax
  100a00:	0f b6 d0             	movzbw %al,%dx
  100a03:	8b 45 ec             	mov    -0x14(%di),%ax
  100a06:	89 c1                	mov    %ax,%cx
  100a08:	d3 fa                	sar    %cl,%dx
  100a0a:	89 d0                	mov    %dx,%ax
  100a0c:	83 e0 01             	and    $0x1,%ax
  100a0f:	85 c0                	test   %ax,%ax
  100a11:	74 25                	je     100a38 <pidalloc_print+0x92>
            dbg_info("%d ", i + 1);
  100a13:	8b 45 f4             	mov    -0xc(%di),%ax
  100a16:	83 c0 01             	add    $0x1,%ax
  100a19:	83 ec 08             	sub    $0x8,%sp
  100a1c:	50                   	push   %ax
  100a1d:	68 14 41             	push   $0x4114
  100a20:	10 00                	adc    %al,(%bx,%si)
  100a22:	6a 4f                	push   $0x4f
  100a24:	68 1c 41             	push   $0x411c
  100a27:	10 00                	adc    %al,(%bx,%si)
  100a29:	68 09 41             	push   $0x4109
  100a2c:	10 00                	adc    %al,(%bx,%si)
  100a2e:	6a 03                	push   $0x3
  100a30:	e8 4f 1d             	call   102782 <hlt+0x5>
  100a33:	00 00                	add    %al,(%bx,%si)
  100a35:	83 c4 20             	add    $0x20,%sp
    for (int i = 0; i < PID_MAX_NR; i++) {
  100a38:	83 45 f4 01          	addw   $0x1,-0xc(%di)
  100a3c:	81 7d f4 ff 03       	cmpw   $0x3ff,-0xc(%di)
  100a41:	00 00                	add    %al,(%bx,%si)
  100a43:	7e 8e                	jle    1009d3 <pidalloc_print+0x2d>
        }
    }
    dbg_info("\n");
  100a45:	83 ec 0c             	sub    $0xc,%sp
  100a48:	68 18 41             	push   $0x4118
  100a4b:	10 00                	adc    %al,(%bx,%si)
  100a4d:	6a 52                	push   $0x52
  100a4f:	68 1c 41             	push   $0x411c
  100a52:	10 00                	adc    %al,(%bx,%si)
  100a54:	68 09 41             	push   $0x4109
  100a57:	10 00                	adc    %al,(%bx,%si)
  100a59:	6a 03                	push   $0x3
  100a5b:	e8 24 1d             	call   102782 <hlt+0x5>
  100a5e:	00 00                	add    %al,(%bx,%si)
  100a60:	83 c4 20             	add    $0x20,%sp
  100a63:	90                   	nop
  100a64:	c9                   	leave  
  100a65:	c3                   	ret    

00100a66 <read_cr2>:
static inline uint32_t read_cr2() {
  100a66:	55                   	push   %bp
  100a67:	89 e5                	mov    %sp,%bp
  100a69:	83 ec 10             	sub    $0x10,%sp
	__asm__ __volatile__("mov %%cr2, %[v]":[v]"=r"(cr2));
  100a6c:	0f 20 d0             	mov    %cr2,%eax
  100a6f:	89 45 fc             	mov    %ax,-0x4(%di)
	return cr2;
  100a72:	8b 45 fc             	mov    -0x4(%di),%ax
}
  100a75:	c9                   	leave  
  100a76:	c3                   	ret    

00100a77 <hlt>:
static inline void hlt(void) {
  100a77:	55                   	push   %bp
  100a78:	89 e5                	mov    %sp,%bp
    __asm__ __volatile__("hlt");
  100a7a:	f4                   	hlt    
}
  100a7b:	90                   	nop
  100a7c:	5d                   	pop    %bp
  100a7d:	c3                   	ret    

00100a7e <dump_core_regs>:
#include "cpu_cfg.h"
#include "../cpu.h"
#include "debug.h"
#include "cpu_instr.h"

static void dump_core_regs (exception_frame_t * frame) {
  100a7e:	55                   	push   %bp
  100a7f:	89 e5                	mov    %sp,%bp
  100a81:	57                   	push   %di
  100a82:	56                   	push   %si
  100a83:	53                   	push   %bx
  100a84:	83 ec 2c             	sub    $0x2c,%sp
    // 打印CPU寄存器相关内容
    uint32_t esp, ss;
    /*0特权级发生异常和3特权级发生异常  栈信息略有不同*/
    if (frame->cs & 0x7) {
  100a87:	8b 45 08             	mov    0x8(%di),%ax
  100a8a:	8b 40 3c             	mov    0x3c(%bx,%si),%ax
  100a8d:	83 e0 07             	and    $0x7,%ax
  100a90:	85 c0                	test   %ax,%ax
  100a92:	74 14                	je     100aa8 <dump_core_regs+0x2a>
        ss = frame->ds;
  100a94:	8b 45 08             	mov    0x8(%di),%ax
  100a97:	8b 40 0c             	mov    0xc(%bx,%si),%ax
  100a9a:	89 45 e0             	mov    %ax,-0x20(%di)
        esp = frame->esp;
  100a9d:	8b 45 08             	mov    0x8(%di),%ax
  100aa0:	8b 40 1c             	mov    0x1c(%bx,%si),%ax
  100aa3:	89 45 e4             	mov    %ax,-0x1c(%di)
  100aa6:	eb 12                	jmp    100aba <dump_core_regs+0x3c>
    } else {
        ss = frame->ss3;
  100aa8:	8b 45 08             	mov    0x8(%di),%ax
  100aab:	8b 40 48             	mov    0x48(%bx,%si),%ax
  100aae:	89 45 e0             	mov    %ax,-0x20(%di)
        esp = frame->esp3;
  100ab1:	8b 45 08             	mov    0x8(%di),%ax
  100ab4:	8b 40 44             	mov    0x44(%bx,%si),%ax
  100ab7:	89 45 e4             	mov    %ax,-0x1c(%di)
    }

    dbg_info("IRQ: %d, error code: %d.\r\n", frame->num, frame->error_code);
  100aba:	8b 45 08             	mov    0x8(%di),%ax
  100abd:	8b 50 34             	mov    0x34(%bx,%si),%dx
  100ac0:	8b 45 08             	mov    0x8(%di),%ax
  100ac3:	8b 40 30             	mov    0x30(%bx,%si),%ax
  100ac6:	83 ec 04             	sub    $0x4,%sp
  100ac9:	52                   	push   %dx
  100aca:	50                   	push   %ax
  100acb:	68 2c 41             	push   $0x412c
  100ace:	10 00                	adc    %al,(%bx,%si)
  100ad0:	6a 14                	push   $0x14
  100ad2:	68 48 46             	push   $0x4648
  100ad5:	10 00                	adc    %al,(%bx,%si)
  100ad7:	68 47 41             	push   $0x4147
  100ada:	10 00                	adc    %al,(%bx,%si)
  100adc:	6a 03                	push   $0x3
  100ade:	e8 a1 1c             	call   102782 <hlt+0x5>
  100ae1:	00 00                	add    %al,(%bx,%si)
  100ae3:	83 c4 20             	add    $0x20,%sp
    dbg_info("CS: %d\r\nDS: %d\r\nES: %d\r\nSS: %d\r\nFS:%d\r\nGS:%d\r\n",
  100ae6:	8b 45 08             	mov    0x8(%di),%ax
  100ae9:	8b 30                	mov    (%bx,%si),%si
  100aeb:	8b 45 08             	mov    0x8(%di),%ax
  100aee:	8b 58 04             	mov    0x4(%bx,%si),%bx
  100af1:	8b 45 08             	mov    0x8(%di),%ax
  100af4:	8b 48 08             	mov    0x8(%bx,%si),%cx
  100af7:	8b 45 08             	mov    0x8(%di),%ax
  100afa:	8b 50 0c             	mov    0xc(%bx,%si),%dx
  100afd:	8b 45 08             	mov    0x8(%di),%ax
  100b00:	8b 40 3c             	mov    0x3c(%bx,%si),%ax
  100b03:	83 ec 04             	sub    $0x4,%sp
  100b06:	56                   	push   %si
  100b07:	53                   	push   %bx
  100b08:	ff 75 e0             	push   -0x20(%di)
  100b0b:	51                   	push   %cx
  100b0c:	52                   	push   %dx
  100b0d:	50                   	push   %ax
  100b0e:	68 54 41             	push   $0x4154
  100b11:	10 00                	adc    %al,(%bx,%si)
  100b13:	6a 15                	push   $0x15
  100b15:	68 48 46             	push   $0x4648
  100b18:	10 00                	adc    %al,(%bx,%si)
  100b1a:	68 47 41             	push   $0x4147
  100b1d:	10 00                	adc    %al,(%bx,%si)
  100b1f:	6a 03                	push   $0x3
  100b21:	e8 5e 1c             	call   102782 <hlt+0x5>
  100b24:	00 00                	add    %al,(%bx,%si)
  100b26:	83 c4 30             	add    $0x30,%sp
               frame->cs, frame->ds, frame->es, ss, frame->fs, frame->gs
    );
    dbg_info("EAX:0x%x\r\n"
  100b29:	8b 45 08             	mov    0x8(%di),%ax
  100b2c:	8b 40 18             	mov    0x18(%bx,%si),%ax
  100b2f:	89 45 d4             	mov    %ax,-0x2c(%di)
  100b32:	8b 45 08             	mov    0x8(%di),%ax
  100b35:	8b 78 14             	mov    0x14(%bx,%si),%di
  100b38:	8b 45 08             	mov    0x8(%di),%ax
  100b3b:	8b 70 10             	mov    0x10(%bx,%si),%si
  100b3e:	8b 45 08             	mov    0x8(%di),%ax
  100b41:	8b 58 24             	mov    0x24(%bx,%si),%bx
  100b44:	8b 45 08             	mov    0x8(%di),%ax
  100b47:	8b 48 28             	mov    0x28(%bx,%si),%cx
  100b4a:	8b 45 08             	mov    0x8(%di),%ax
  100b4d:	8b 50 20             	mov    0x20(%bx,%si),%dx
  100b50:	8b 45 08             	mov    0x8(%di),%ax
  100b53:	8b 40 2c             	mov    0x2c(%bx,%si),%ax
  100b56:	83 ec 0c             	sub    $0xc,%sp
  100b59:	ff 75 e4             	push   -0x1c(%di)
  100b5c:	ff 75 d4             	push   -0x2c(%di)
  100b5f:	57                   	push   %di
  100b60:	56                   	push   %si
  100b61:	53                   	push   %bx
  100b62:	51                   	push   %cx
  100b63:	52                   	push   %dx
  100b64:	50                   	push   %ax
  100b65:	68 84 41             	push   $0x4184
  100b68:	10 00                	adc    %al,(%bx,%si)
  100b6a:	6a 18                	push   $0x18
  100b6c:	68 48 46             	push   $0x4648
  100b6f:	10 00                	adc    %al,(%bx,%si)
  100b71:	68 47 41             	push   $0x4147
  100b74:	10 00                	adc    %al,(%bx,%si)
  100b76:	6a 03                	push   $0x3
  100b78:	e8 07 1c             	call   102782 <hlt+0x5>
  100b7b:	00 00                	add    %al,(%bx,%si)
  100b7d:	83 c4 40             	add    $0x40,%sp
              "ESI:0x%x\r\n"
              "EBP:0x%x\r\n"
              "ESP:0x%x\r\n",
               frame->eax, frame->ebx, frame->ecx, frame->edx,
               frame->edi, frame->esi, frame->ebp, esp);
    dbg_info("EIP:0x%x\r\nEFLAGS:0x%x\r\n", frame->eip, frame->eflags);
  100b80:	8b 45 08             	mov    0x8(%di),%ax
  100b83:	8b 50 40             	mov    0x40(%bx,%si),%dx
  100b86:	8b 45 08             	mov    0x8(%di),%ax
  100b89:	8b 40 38             	mov    0x38(%bx,%si),%ax
  100b8c:	83 ec 04             	sub    $0x4,%sp
  100b8f:	52                   	push   %dx
  100b90:	50                   	push   %ax
  100b91:	68 d5 41             	push   $0x41d5
  100b94:	10 00                	adc    %al,(%bx,%si)
  100b96:	6a 22                	push   $0x22
  100b98:	68 48 46             	push   $0x4648
  100b9b:	10 00                	adc    %al,(%bx,%si)
  100b9d:	68 47 41             	push   $0x4147
  100ba0:	10 00                	adc    %al,(%bx,%si)
  100ba2:	6a 03                	push   $0x3
  100ba4:	e8 db 1b             	call   102782 <hlt+0x5>
  100ba7:	00 00                	add    %al,(%bx,%si)
  100ba9:	83 c4 20             	add    $0x20,%sp
}
  100bac:	90                   	nop
  100bad:	8d 65 f4             	lea    -0xc(%di),%sp
  100bb0:	5b                   	pop    %bx
  100bb1:	5e                   	pop    %si
  100bb2:	5f                   	pop    %di
  100bb3:	5d                   	pop    %bp
  100bb4:	c3                   	ret    

00100bb5 <do_default_handler>:

static void do_default_handler (exception_frame_t * frame, const char * message) {
  100bb5:	55                   	push   %bp
  100bb6:	89 e5                	mov    %sp,%bp
  100bb8:	83 ec 08             	sub    $0x8,%sp
    dbg_info("--------------------------------\r\n");
  100bbb:	83 ec 0c             	sub    $0xc,%sp
  100bbe:	68 f0 41             	push   $0x41f0
  100bc1:	10 00                	adc    %al,(%bx,%si)
  100bc3:	6a 26                	push   $0x26
  100bc5:	68 58 46             	push   $0x4658
  100bc8:	10 00                	adc    %al,(%bx,%si)
  100bca:	68 47 41             	push   $0x4147
  100bcd:	10 00                	adc    %al,(%bx,%si)
  100bcf:	6a 03                	push   $0x3
  100bd1:	e8 ae 1b             	call   102782 <hlt+0x5>
  100bd4:	00 00                	add    %al,(%bx,%si)
  100bd6:	83 c4 20             	add    $0x20,%sp
    dbg_info("IRQ/Exception happend: %s.\r\n", message);
  100bd9:	83 ec 08             	sub    $0x8,%sp
  100bdc:	ff 75 0c             	push   0xc(%di)
  100bdf:	68 13 42             	push   $0x4213
  100be2:	10 00                	adc    %al,(%bx,%si)
  100be4:	6a 27                	push   $0x27
  100be6:	68 58 46             	push   $0x4658
  100be9:	10 00                	adc    %al,(%bx,%si)
  100beb:	68 47 41             	push   $0x4147
  100bee:	10 00                	adc    %al,(%bx,%si)
  100bf0:	6a 03                	push   $0x3
  100bf2:	e8 8d 1b             	call   102782 <hlt+0x5>
  100bf5:	00 00                	add    %al,(%bx,%si)
  100bf7:	83 c4 20             	add    $0x20,%sp
    dump_core_regs(frame);
  100bfa:	83 ec 0c             	sub    $0xc,%sp
  100bfd:	ff 75 08             	push   0x8(%di)
  100c00:	e8 79 fe             	call   100a7c <hlt+0x5>
  100c03:	ff                   	(bad)  
  100c04:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    
    // todo: 留等以后补充打印任务栈的内容

    dbg_info("--------------------------------\r\n");
  100c08:	83 ec 0c             	sub    $0xc,%sp
  100c0b:	68 f0 41             	push   $0x41f0
  100c0e:	10 00                	adc    %al,(%bx,%si)
  100c10:	6a 2c                	push   $0x2c
  100c12:	68 58 46             	push   $0x4658
  100c15:	10 00                	adc    %al,(%bx,%si)
  100c17:	68 47 41             	push   $0x4147
  100c1a:	10 00                	adc    %al,(%bx,%si)
  100c1c:	6a 03                	push   $0x3
  100c1e:	e8 61 1b             	call   102782 <hlt+0x5>
  100c21:	00 00                	add    %al,(%bx,%si)
  100c23:	83 c4 20             	add    $0x20,%sp
    if (frame->cs & 0x3) {
  100c26:	8b 45 08             	mov    0x8(%di),%ax
  100c29:	8b 40 3c             	mov    0x3c(%bx,%si),%ax
  100c2c:	83 e0 03             	and    $0x3,%ax
  100c2f:	85 c0                	test   %ax,%ax
  100c31:	75 07                	jne    100c3a <do_default_handler+0x85>
        //sys_exit(frame->error_code);
    } else {
        for (;;) {
            hlt();
  100c33:	e8 3f fe             	call   100a75 <read_cr2+0xf>
  100c36:	ff                   	(bad)  
  100c37:	ff                   	(bad)  
  100c38:	eb f9                	jmp    100c33 <do_default_handler+0x7e>
        }
    }
}
  100c3a:	90                   	nop
  100c3b:	c9                   	leave  
  100c3c:	c3                   	ret    

00100c3d <do_handler_unknown>:

void do_handler_unknown (exception_frame_t * frame) {
  100c3d:	55                   	push   %bp
  100c3e:	89 e5                	mov    %sp,%bp
  100c40:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "Unknown exception.");
  100c43:	83 ec 08             	sub    $0x8,%sp
  100c46:	68 30 42             	push   $0x4230
  100c49:	10 00                	adc    %al,(%bx,%si)
  100c4b:	ff 75 08             	push   0x8(%di)
  100c4e:	e8 62 ff             	call   100bb3 <dump_core_regs+0x135>
  100c51:	ff                   	(bad)  
  100c52:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  100c56:	90                   	nop
  100c57:	c9                   	leave  
  100c58:	c3                   	ret    

00100c59 <do_handler_divider>:

void do_handler_divider(exception_frame_t * frame) {
  100c59:	55                   	push   %bp
  100c5a:	89 e5                	mov    %sp,%bp
  100c5c:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "Divider Error.");
  100c5f:	83 ec 08             	sub    $0x8,%sp
  100c62:	68 43 42             	push   $0x4243
  100c65:	10 00                	adc    %al,(%bx,%si)
  100c67:	ff 75 08             	push   0x8(%di)
  100c6a:	e8 46 ff             	call   100bb3 <dump_core_regs+0x135>
  100c6d:	ff                   	(bad)  
  100c6e:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  100c72:	90                   	nop
  100c73:	c9                   	leave  
  100c74:	c3                   	ret    

00100c75 <do_handler_Debug>:

void do_handler_Debug(exception_frame_t * frame) {
  100c75:	55                   	push   %bp
  100c76:	89 e5                	mov    %sp,%bp
  100c78:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "Debug Exception");
  100c7b:	83 ec 08             	sub    $0x8,%sp
  100c7e:	68 52 42             	push   $0x4252
  100c81:	10 00                	adc    %al,(%bx,%si)
  100c83:	ff 75 08             	push   0x8(%di)
  100c86:	e8 2a ff             	call   100bb3 <dump_core_regs+0x135>
  100c89:	ff                   	(bad)  
  100c8a:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  100c8e:	90                   	nop
  100c8f:	c9                   	leave  
  100c90:	c3                   	ret    

00100c91 <do_handler_NMI>:

void do_handler_NMI(exception_frame_t * frame) {
  100c91:	55                   	push   %bp
  100c92:	89 e5                	mov    %sp,%bp
  100c94:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "NMI Interrupt.");
  100c97:	83 ec 08             	sub    $0x8,%sp
  100c9a:	68 62 42             	push   $0x4262
  100c9d:	10 00                	adc    %al,(%bx,%si)
  100c9f:	ff 75 08             	push   0x8(%di)
  100ca2:	e8 0e ff             	call   100bb3 <dump_core_regs+0x135>
  100ca5:	ff                   	(bad)  
  100ca6:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  100caa:	90                   	nop
  100cab:	c9                   	leave  
  100cac:	c3                   	ret    

00100cad <do_handler_breakpoint>:

void do_handler_breakpoint(exception_frame_t * frame) {
  100cad:	55                   	push   %bp
  100cae:	89 e5                	mov    %sp,%bp
  100cb0:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "Breakpoint.");
  100cb3:	83 ec 08             	sub    $0x8,%sp
  100cb6:	68 71 42             	push   $0x4271
  100cb9:	10 00                	adc    %al,(%bx,%si)
  100cbb:	ff 75 08             	push   0x8(%di)
  100cbe:	e8 f2 fe             	call   100bb3 <dump_core_regs+0x135>
  100cc1:	ff                   	(bad)  
  100cc2:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  100cc6:	90                   	nop
  100cc7:	c9                   	leave  
  100cc8:	c3                   	ret    

00100cc9 <do_handler_overflow>:

void do_handler_overflow(exception_frame_t * frame) {
  100cc9:	55                   	push   %bp
  100cca:	89 e5                	mov    %sp,%bp
  100ccc:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "Overflow.");
  100ccf:	83 ec 08             	sub    $0x8,%sp
  100cd2:	68 7d 42             	push   $0x427d
  100cd5:	10 00                	adc    %al,(%bx,%si)
  100cd7:	ff 75 08             	push   0x8(%di)
  100cda:	e8 d6 fe             	call   100bb3 <dump_core_regs+0x135>
  100cdd:	ff                   	(bad)  
  100cde:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  100ce2:	90                   	nop
  100ce3:	c9                   	leave  
  100ce4:	c3                   	ret    

00100ce5 <do_handler_bound_range>:

void do_handler_bound_range(exception_frame_t * frame) {
  100ce5:	55                   	push   %bp
  100ce6:	89 e5                	mov    %sp,%bp
  100ce8:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "BOUND Range Exceeded.");
  100ceb:	83 ec 08             	sub    $0x8,%sp
  100cee:	68 87 42             	push   $0x4287
  100cf1:	10 00                	adc    %al,(%bx,%si)
  100cf3:	ff 75 08             	push   0x8(%di)
  100cf6:	e8 ba fe             	call   100bb3 <dump_core_regs+0x135>
  100cf9:	ff                   	(bad)  
  100cfa:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  100cfe:	90                   	nop
  100cff:	c9                   	leave  
  100d00:	c3                   	ret    

00100d01 <do_handler_invalid_opcode>:

void do_handler_invalid_opcode(exception_frame_t * frame) {
  100d01:	55                   	push   %bp
  100d02:	89 e5                	mov    %sp,%bp
  100d04:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "Invalid Opcode.");
  100d07:	83 ec 08             	sub    $0x8,%sp
  100d0a:	68 9d 42             	push   $0x429d
  100d0d:	10 00                	adc    %al,(%bx,%si)
  100d0f:	ff 75 08             	push   0x8(%di)
  100d12:	e8 9e fe             	call   100bb3 <dump_core_regs+0x135>
  100d15:	ff                   	(bad)  
  100d16:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  100d1a:	90                   	nop
  100d1b:	c9                   	leave  
  100d1c:	c3                   	ret    

00100d1d <do_handler_device_unavailable>:

void do_handler_device_unavailable(exception_frame_t * frame) {
  100d1d:	55                   	push   %bp
  100d1e:	89 e5                	mov    %sp,%bp
  100d20:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "Device Not Available.");
  100d23:	83 ec 08             	sub    $0x8,%sp
  100d26:	68 ad 42             	push   $0x42ad
  100d29:	10 00                	adc    %al,(%bx,%si)
  100d2b:	ff 75 08             	push   0x8(%di)
  100d2e:	e8 82 fe             	call   100bb3 <dump_core_regs+0x135>
  100d31:	ff                   	(bad)  
  100d32:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  100d36:	90                   	nop
  100d37:	c9                   	leave  
  100d38:	c3                   	ret    

00100d39 <do_handler_double_fault>:

void do_handler_double_fault(exception_frame_t * frame) {
  100d39:	55                   	push   %bp
  100d3a:	89 e5                	mov    %sp,%bp
  100d3c:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "Double Fault.");
  100d3f:	83 ec 08             	sub    $0x8,%sp
  100d42:	68 c3 42             	push   $0x42c3
  100d45:	10 00                	adc    %al,(%bx,%si)
  100d47:	ff 75 08             	push   0x8(%di)
  100d4a:	e8 66 fe             	call   100bb3 <dump_core_regs+0x135>
  100d4d:	ff                   	(bad)  
  100d4e:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  100d52:	90                   	nop
  100d53:	c9                   	leave  
  100d54:	c3                   	ret    

00100d55 <do_handler_invalid_tss>:

void do_handler_invalid_tss(exception_frame_t * frame) {
  100d55:	55                   	push   %bp
  100d56:	89 e5                	mov    %sp,%bp
  100d58:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "Invalid TSS");
  100d5b:	83 ec 08             	sub    $0x8,%sp
  100d5e:	68 d1 42             	push   $0x42d1
  100d61:	10 00                	adc    %al,(%bx,%si)
  100d63:	ff 75 08             	push   0x8(%di)
  100d66:	e8 4a fe             	call   100bb3 <dump_core_regs+0x135>
  100d69:	ff                   	(bad)  
  100d6a:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  100d6e:	90                   	nop
  100d6f:	c9                   	leave  
  100d70:	c3                   	ret    

00100d71 <do_handler_segment_not_present>:

void do_handler_segment_not_present(exception_frame_t * frame) {
  100d71:	55                   	push   %bp
  100d72:	89 e5                	mov    %sp,%bp
  100d74:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "Segment Not Present.");
  100d77:	83 ec 08             	sub    $0x8,%sp
  100d7a:	68 dd 42             	push   $0x42dd
  100d7d:	10 00                	adc    %al,(%bx,%si)
  100d7f:	ff 75 08             	push   0x8(%di)
  100d82:	e8 2e fe             	call   100bb3 <dump_core_regs+0x135>
  100d85:	ff                   	(bad)  
  100d86:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  100d8a:	90                   	nop
  100d8b:	c9                   	leave  
  100d8c:	c3                   	ret    

00100d8d <do_handler_stack_segment_fault>:

void do_handler_stack_segment_fault(exception_frame_t * frame) {
  100d8d:	55                   	push   %bp
  100d8e:	89 e5                	mov    %sp,%bp
  100d90:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "Stack-Segment Fault.");
  100d93:	83 ec 08             	sub    $0x8,%sp
  100d96:	68 f2 42             	push   $0x42f2
  100d99:	10 00                	adc    %al,(%bx,%si)
  100d9b:	ff 75 08             	push   0x8(%di)
  100d9e:	e8 12 fe             	call   100bb3 <dump_core_regs+0x135>
  100da1:	ff                   	(bad)  
  100da2:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  100da6:	90                   	nop
  100da7:	c9                   	leave  
  100da8:	c3                   	ret    

00100da9 <do_handler_general_protection>:

void do_handler_general_protection(exception_frame_t * frame) {
  100da9:	55                   	push   %bp
  100daa:	89 e5                	mov    %sp,%bp
  100dac:	83 ec 08             	sub    $0x8,%sp
    dbg_info("--------------------------------\r\n");
  100daf:	83 ec 0c             	sub    $0xc,%sp
  100db2:	68 f0 41             	push   $0x41f0
  100db5:	10 00                	adc    %al,(%bx,%si)
  100db7:	6a 6b                	push   $0x6b
  100db9:	68 6c 46             	push   $0x466c
  100dbc:	10 00                	adc    %al,(%bx,%si)
  100dbe:	68 47 41             	push   $0x4147
  100dc1:	10 00                	adc    %al,(%bx,%si)
  100dc3:	6a 03                	push   $0x3
  100dc5:	e8 ba 19             	call   102782 <hlt+0x5>
  100dc8:	00 00                	add    %al,(%bx,%si)
  100dca:	83 c4 20             	add    $0x20,%sp
    dbg_info("IRQ/Exception happend: General Protection.\r\n");
  100dcd:	83 ec 0c             	sub    $0xc,%sp
  100dd0:	68 08 43             	push   $0x4308
  100dd3:	10 00                	adc    %al,(%bx,%si)
  100dd5:	6a 6c                	push   $0x6c
  100dd7:	68 6c 46             	push   $0x466c
  100dda:	10 00                	adc    %al,(%bx,%si)
  100ddc:	68 47 41             	push   $0x4147
  100ddf:	10 00                	adc    %al,(%bx,%si)
  100de1:	6a 03                	push   $0x3
  100de3:	e8 9c 19             	call   102782 <hlt+0x5>
  100de6:	00 00                	add    %al,(%bx,%si)
  100de8:	83 c4 20             	add    $0x20,%sp
    if (frame->error_code & ERR_EXT) {
  100deb:	8b 45 08             	mov    0x8(%di),%ax
  100dee:	8b 40 34             	mov    0x34(%bx,%si),%ax
  100df1:	83 e0 01             	and    $0x1,%ax
  100df4:	85 c0                	test   %ax,%ax
  100df6:	74 20                	je     100e18 <do_handler_general_protection+0x6f>
        dbg_info("The exception occurred during delivery of an "
  100df8:	83 ec 0c             	sub    $0xc,%sp
  100dfb:	68 38 43             	push   $0x4338
  100dfe:	10 00                	adc    %al,(%bx,%si)
  100e00:	6a 6e                	push   $0x6e
  100e02:	68 6c 46             	push   $0x466c
  100e05:	10 00                	adc    %al,(%bx,%si)
  100e07:	68 47 41             	push   $0x4147
  100e0a:	10 00                	adc    %al,(%bx,%si)
  100e0c:	6a 03                	push   $0x3
  100e0e:	e8 71 19             	call   102782 <hlt+0x5>
  100e11:	00 00                	add    %al,(%bx,%si)
  100e13:	83 c4 20             	add    $0x20,%sp
  100e16:	eb 1e                	jmp    100e36 <do_handler_general_protection+0x8d>
                  "event external to the program, such as an interrupt "
                  "or an earlier exception.\r\n");
    } else {
        dbg_info("The exception occurred during delivery of a "
  100e18:	83 ec 0c             	sub    $0xc,%sp
  100e1b:	68 b4 43             	push   $0x43b4
  100e1e:	10 00                	adc    %al,(%bx,%si)
  100e20:	6a 72                	push   $0x72
  100e22:	68 6c 46             	push   $0x466c
  100e25:	10 00                	adc    %al,(%bx,%si)
  100e27:	68 47 41             	push   $0x4147
  100e2a:	10 00                	adc    %al,(%bx,%si)
  100e2c:	6a 03                	push   $0x3
  100e2e:	e8 51 19             	call   102782 <hlt+0x5>
  100e31:	00 00                	add    %al,(%bx,%si)
  100e33:	83 c4 20             	add    $0x20,%sp
                  "software interrupt (INT n, INT3, or INTO).\r\n");
    }
    
    if (frame->error_code & ERR_IDT) {
  100e36:	8b 45 08             	mov    0x8(%di),%ax
  100e39:	8b 40 34             	mov    0x34(%bx,%si),%ax
  100e3c:	83 e0 02             	and    $0x2,%ax
  100e3f:	85 c0                	test   %ax,%ax
  100e41:	74 20                	je     100e63 <do_handler_general_protection+0xba>
        dbg_info("The index portion of the error code refers "
  100e43:	83 ec 0c             	sub    $0xc,%sp
  100e46:	68 10 44             	push   $0x4410
  100e49:	10 00                	adc    %al,(%bx,%si)
  100e4b:	6a 77                	push   $0x77
  100e4d:	68 6c 46             	push   $0x466c
  100e50:	10 00                	adc    %al,(%bx,%si)
  100e52:	68 47 41             	push   $0x4147
  100e55:	10 00                	adc    %al,(%bx,%si)
  100e57:	6a 03                	push   $0x3
  100e59:	e8 26 19             	call   102782 <hlt+0x5>
  100e5c:	00 00                	add    %al,(%bx,%si)
  100e5e:	83 c4 20             	add    $0x20,%sp
  100e61:	eb 1e                	jmp    100e81 <do_handler_general_protection+0xd8>
                  "to a gate descriptor in the IDT\r\n");
    } else {
        dbg_info("The index refers to a descriptor in the GDT\r\n");
  100e63:	83 ec 0c             	sub    $0xc,%sp
  100e66:	68 60 44             	push   $0x4460
  100e69:	10 00                	adc    %al,(%bx,%si)
  100e6b:	6a 7a                	push   $0x7a
  100e6d:	68 6c 46             	push   $0x466c
  100e70:	10 00                	adc    %al,(%bx,%si)
  100e72:	68 47 41             	push   $0x4147
  100e75:	10 00                	adc    %al,(%bx,%si)
  100e77:	6a 03                	push   $0x3
  100e79:	e8 06 19             	call   102782 <hlt+0x5>
  100e7c:	00 00                	add    %al,(%bx,%si)
  100e7e:	83 c4 20             	add    $0x20,%sp
    }
    
    dbg_info("Segment index: %d\r\n", frame->error_code & 0xFFF8);
  100e81:	8b 45 08             	mov    0x8(%di),%ax
  100e84:	8b 40 34             	mov    0x34(%bx,%si),%ax
  100e87:	25 f8 ff             	and    $0xfff8,%ax
  100e8a:	00 00                	add    %al,(%bx,%si)
  100e8c:	83 ec 08             	sub    $0x8,%sp
  100e8f:	50                   	push   %ax
  100e90:	68 8e 44             	push   $0x448e
  100e93:	10 00                	adc    %al,(%bx,%si)
  100e95:	6a 7d                	push   $0x7d
  100e97:	68 6c 46             	push   $0x466c
  100e9a:	10 00                	adc    %al,(%bx,%si)
  100e9c:	68 47 41             	push   $0x4147
  100e9f:	10 00                	adc    %al,(%bx,%si)
  100ea1:	6a 03                	push   $0x3
  100ea3:	e8 dc 18             	call   102782 <hlt+0x5>
  100ea6:	00 00                	add    %al,(%bx,%si)
  100ea8:	83 c4 20             	add    $0x20,%sp

    dump_core_regs(frame);
  100eab:	83 ec 0c             	sub    $0xc,%sp
  100eae:	ff 75 08             	push   0x8(%di)
  100eb1:	e8 c8 fb             	call   100a7c <hlt+0x5>
  100eb4:	ff                   	(bad)  
  100eb5:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    if (frame->cs & 0x3) {
  100eb9:	8b 45 08             	mov    0x8(%di),%ax
  100ebc:	8b 40 3c             	mov    0x3c(%bx,%si),%ax
  100ebf:	83 e0 03             	and    $0x3,%ax
  100ec2:	85 c0                	test   %ax,%ax
  100ec4:	75 07                	jne    100ecd <do_handler_general_protection+0x124>
        //sys_exit(frame->error_code);
    } else {
        for (;;) {
            hlt();
  100ec6:	e8 ac fb             	call   100a75 <read_cr2+0xf>
  100ec9:	ff                   	(bad)  
  100eca:	ff                   	(bad)  
  100ecb:	eb f9                	jmp    100ec6 <do_handler_general_protection+0x11d>
        }
    }
}
  100ecd:	90                   	nop
  100ece:	c9                   	leave  
  100ecf:	c3                   	ret    

00100ed0 <do_handler_page_fault>:

void do_handler_page_fault(exception_frame_t * frame) {
  100ed0:	55                   	push   %bp
  100ed1:	89 e5                	mov    %sp,%bp
  100ed3:	83 ec 08             	sub    $0x8,%sp
    dbg_info("--------------------------------\r\n");
  100ed6:	83 ec 0c             	sub    $0xc,%sp
  100ed9:	68 f0 41             	push   $0x41f0
  100edc:	10 00                	adc    %al,(%bx,%si)
  100ede:	68 8a 00             	push   $0x8a
  100ee1:	00 00                	add    %al,(%bx,%si)
  100ee3:	68 8c 46             	push   $0x468c
  100ee6:	10 00                	adc    %al,(%bx,%si)
  100ee8:	68 47 41             	push   $0x4147
  100eeb:	10 00                	adc    %al,(%bx,%si)
  100eed:	6a 03                	push   $0x3
  100eef:	e8 90 18             	call   102782 <hlt+0x5>
  100ef2:	00 00                	add    %al,(%bx,%si)
  100ef4:	83 c4 20             	add    $0x20,%sp
    dbg_info("IRQ/Exception happend: Page fault.\r\n");
  100ef7:	83 ec 0c             	sub    $0xc,%sp
  100efa:	68 a4 44             	push   $0x44a4
  100efd:	10 00                	adc    %al,(%bx,%si)
  100eff:	68 8b 00             	push   $0x8b
  100f02:	00 00                	add    %al,(%bx,%si)
  100f04:	68 8c 46             	push   $0x468c
  100f07:	10 00                	adc    %al,(%bx,%si)
  100f09:	68 47 41             	push   $0x4147
  100f0c:	10 00                	adc    %al,(%bx,%si)
  100f0e:	6a 03                	push   $0x3
  100f10:	e8 6f 18             	call   102782 <hlt+0x5>
  100f13:	00 00                	add    %al,(%bx,%si)
  100f15:	83 c4 20             	add    $0x20,%sp
    if (frame->error_code & ERR_PAGE_P) {
  100f18:	8b 45 08             	mov    0x8(%di),%ax
  100f1b:	8b 40 34             	mov    0x34(%bx,%si),%ax
  100f1e:	83 e0 01             	and    $0x1,%ax
  100f21:	85 c0                	test   %ax,%ax
  100f23:	74 29                	je     100f4e <do_handler_page_fault+0x7e>
        dbg_info("\tPage-level protection violation: 0x%x.\r\n", read_cr2());
  100f25:	e8 3c fb             	call   100a64 <pidalloc_print+0xbe>
  100f28:	ff                   	(bad)  
  100f29:	ff 83 ec 08          	incw   0x8ec(%bp,%di)
  100f2d:	50                   	push   %ax
  100f2e:	68 cc 44             	push   $0x44cc
  100f31:	10 00                	adc    %al,(%bx,%si)
  100f33:	68 8d 00             	push   $0x8d
  100f36:	00 00                	add    %al,(%bx,%si)
  100f38:	68 8c 46             	push   $0x468c
  100f3b:	10 00                	adc    %al,(%bx,%si)
  100f3d:	68 47 41             	push   $0x4147
  100f40:	10 00                	adc    %al,(%bx,%si)
  100f42:	6a 03                	push   $0x3
  100f44:	e8 3b 18             	call   102782 <hlt+0x5>
  100f47:	00 00                	add    %al,(%bx,%si)
  100f49:	83 c4 20             	add    $0x20,%sp
  100f4c:	eb 27                	jmp    100f75 <do_handler_page_fault+0xa5>
    } else {
         dbg_info("\tPage doesn't present: 0x%x.\r\n", read_cr2());
  100f4e:	e8 13 fb             	call   100a64 <pidalloc_print+0xbe>
  100f51:	ff                   	(bad)  
  100f52:	ff 83 ec 08          	incw   0x8ec(%bp,%di)
  100f56:	50                   	push   %ax
  100f57:	68 f8 44             	push   $0x44f8
  100f5a:	10 00                	adc    %al,(%bx,%si)
  100f5c:	68 8f 00             	push   $0x8f
  100f5f:	00 00                	add    %al,(%bx,%si)
  100f61:	68 8c 46             	push   $0x468c
  100f64:	10 00                	adc    %al,(%bx,%si)
  100f66:	68 47 41             	push   $0x4147
  100f69:	10 00                	adc    %al,(%bx,%si)
  100f6b:	6a 03                	push   $0x3
  100f6d:	e8 12 18             	call   102782 <hlt+0x5>
  100f70:	00 00                	add    %al,(%bx,%si)
  100f72:	83 c4 20             	add    $0x20,%sp
    }
    
    if (frame->error_code & ERR_PAGE_WR) {
  100f75:	8b 45 08             	mov    0x8(%di),%ax
  100f78:	8b 40 34             	mov    0x34(%bx,%si),%ax
  100f7b:	83 e0 02             	and    $0x2,%ax
  100f7e:	85 c0                	test   %ax,%ax
  100f80:	74 23                	je     100fa5 <do_handler_page_fault+0xd5>
        dbg_info("\tThe access causing the fault was a read.\r\n");
  100f82:	83 ec 0c             	sub    $0xc,%sp
  100f85:	68 18 45             	push   $0x4518
  100f88:	10 00                	adc    %al,(%bx,%si)
  100f8a:	68 93 00             	push   $0x93
  100f8d:	00 00                	add    %al,(%bx,%si)
  100f8f:	68 8c 46             	push   $0x468c
  100f92:	10 00                	adc    %al,(%bx,%si)
  100f94:	68 47 41             	push   $0x4147
  100f97:	10 00                	adc    %al,(%bx,%si)
  100f99:	6a 03                	push   $0x3
  100f9b:	e8 e4 17             	call   102782 <hlt+0x5>
  100f9e:	00 00                	add    %al,(%bx,%si)
  100fa0:	83 c4 20             	add    $0x20,%sp
  100fa3:	eb 21                	jmp    100fc6 <do_handler_page_fault+0xf6>
    } else {
        dbg_info("\tThe access causing the fault was a write.\r\n");
  100fa5:	83 ec 0c             	sub    $0xc,%sp
  100fa8:	68 44 45             	push   $0x4544
  100fab:	10 00                	adc    %al,(%bx,%si)
  100fad:	68 95 00             	push   $0x95
  100fb0:	00 00                	add    %al,(%bx,%si)
  100fb2:	68 8c 46             	push   $0x468c
  100fb5:	10 00                	adc    %al,(%bx,%si)
  100fb7:	68 47 41             	push   $0x4147
  100fba:	10 00                	adc    %al,(%bx,%si)
  100fbc:	6a 03                	push   $0x3
  100fbe:	e8 c1 17             	call   102782 <hlt+0x5>
  100fc1:	00 00                	add    %al,(%bx,%si)
  100fc3:	83 c4 20             	add    $0x20,%sp
    }
    
    if (frame->error_code & ERR_PAGE_US) {
  100fc6:	8b 45 08             	mov    0x8(%di),%ax
  100fc9:	8b 40 34             	mov    0x34(%bx,%si),%ax
  100fcc:	83 e0 02             	and    $0x2,%ax
  100fcf:	85 c0                	test   %ax,%ax
  100fd1:	74 23                	je     100ff6 <do_handler_page_fault+0x126>
        dbg_info("\tA supervisor-mode access caused the fault.\r\n");
  100fd3:	83 ec 0c             	sub    $0xc,%sp
  100fd6:	68 74 45             	push   $0x4574
  100fd9:	10 00                	adc    %al,(%bx,%si)
  100fdb:	68 99 00             	push   $0x99
  100fde:	00 00                	add    %al,(%bx,%si)
  100fe0:	68 8c 46             	push   $0x468c
  100fe3:	10 00                	adc    %al,(%bx,%si)
  100fe5:	68 47 41             	push   $0x4147
  100fe8:	10 00                	adc    %al,(%bx,%si)
  100fea:	6a 03                	push   $0x3
  100fec:	e8 93 17             	call   102782 <hlt+0x5>
  100fef:	00 00                	add    %al,(%bx,%si)
  100ff1:	83 c4 20             	add    $0x20,%sp
  100ff4:	eb 21                	jmp    101017 <do_handler_page_fault+0x147>
    } else {
        dbg_info("\tA user-mode access caused the fault.\r\n");
  100ff6:	83 ec 0c             	sub    $0xc,%sp
  100ff9:	68 a4 45             	push   $0x45a4
  100ffc:	10 00                	adc    %al,(%bx,%si)
  100ffe:	68 9b 00             	push   $0x9b
  101001:	00 00                	add    %al,(%bx,%si)
  101003:	68 8c 46             	push   $0x468c
  101006:	10 00                	adc    %al,(%bx,%si)
  101008:	68 47 41             	push   $0x4147
  10100b:	10 00                	adc    %al,(%bx,%si)
  10100d:	6a 03                	push   $0x3
  10100f:	e8 70 17             	call   102782 <hlt+0x5>
  101012:	00 00                	add    %al,(%bx,%si)
  101014:	83 c4 20             	add    $0x20,%sp
    }

    dump_core_regs(frame);
  101017:	83 ec 0c             	sub    $0xc,%sp
  10101a:	ff 75 08             	push   0x8(%di)
  10101d:	e8 5c fa             	call   100a7c <hlt+0x5>
  101020:	ff                   	(bad)  
  101021:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    if (frame->cs & 0x3) {
  101025:	8b 45 08             	mov    0x8(%di),%ax
  101028:	8b 40 3c             	mov    0x3c(%bx,%si),%ax
  10102b:	83 e0 03             	and    $0x3,%ax
  10102e:	85 c0                	test   %ax,%ax
  101030:	75 07                	jne    101039 <do_handler_page_fault+0x169>
        //sys_exit(frame->error_code);
    } else {
        for (;;) {
            hlt();
  101032:	e8 40 fa             	call   100a75 <read_cr2+0xf>
  101035:	ff                   	(bad)  
  101036:	ff                   	(bad)  
  101037:	eb f9                	jmp    101032 <do_handler_page_fault+0x162>
        }
    }
}
  101039:	90                   	nop
  10103a:	c9                   	leave  
  10103b:	c3                   	ret    

0010103c <do_handler_fpu_error>:

void do_handler_fpu_error(exception_frame_t * frame) {
  10103c:	55                   	push   %bp
  10103d:	89 e5                	mov    %sp,%bp
  10103f:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "X87 FPU Floating Point Error.");
  101042:	83 ec 08             	sub    $0x8,%sp
  101045:	68 cc 45             	push   $0x45cc
  101048:	10 00                	adc    %al,(%bx,%si)
  10104a:	ff 75 08             	push   0x8(%di)
  10104d:	e8 63 fb             	call   100bb3 <dump_core_regs+0x135>
  101050:	ff                   	(bad)  
  101051:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  101055:	90                   	nop
  101056:	c9                   	leave  
  101057:	c3                   	ret    

00101058 <do_handler_alignment_check>:

void do_handler_alignment_check(exception_frame_t * frame) {
  101058:	55                   	push   %bp
  101059:	89 e5                	mov    %sp,%bp
  10105b:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "Alignment Check.");
  10105e:	83 ec 08             	sub    $0x8,%sp
  101061:	68 ea 45             	push   $0x45ea
  101064:	10 00                	adc    %al,(%bx,%si)
  101066:	ff 75 08             	push   0x8(%di)
  101069:	e8 47 fb             	call   100bb3 <dump_core_regs+0x135>
  10106c:	ff                   	(bad)  
  10106d:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  101071:	90                   	nop
  101072:	c9                   	leave  
  101073:	c3                   	ret    

00101074 <do_handler_machine_check>:

void do_handler_machine_check(exception_frame_t * frame) {
  101074:	55                   	push   %bp
  101075:	89 e5                	mov    %sp,%bp
  101077:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "Machine Check.");
  10107a:	83 ec 08             	sub    $0x8,%sp
  10107d:	68 fb 45             	push   $0x45fb
  101080:	10 00                	adc    %al,(%bx,%si)
  101082:	ff 75 08             	push   0x8(%di)
  101085:	e8 2b fb             	call   100bb3 <dump_core_regs+0x135>
  101088:	ff                   	(bad)  
  101089:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  10108d:	90                   	nop
  10108e:	c9                   	leave  
  10108f:	c3                   	ret    

00101090 <do_handler_smd_exception>:

void do_handler_smd_exception(exception_frame_t * frame) {
  101090:	55                   	push   %bp
  101091:	89 e5                	mov    %sp,%bp
  101093:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "SIMD Floating Point Exception.");
  101096:	83 ec 08             	sub    $0x8,%sp
  101099:	68 0c 46             	push   $0x460c
  10109c:	10 00                	adc    %al,(%bx,%si)
  10109e:	ff 75 08             	push   0x8(%di)
  1010a1:	e8 0f fb             	call   100bb3 <dump_core_regs+0x135>
  1010a4:	ff                   	(bad)  
  1010a5:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  1010a9:	90                   	nop
  1010aa:	c9                   	leave  
  1010ab:	c3                   	ret    

001010ac <do_handler_virtual_exception>:

void do_handler_virtual_exception(exception_frame_t * frame) {
  1010ac:	55                   	push   %bp
  1010ad:	89 e5                	mov    %sp,%bp
  1010af:	83 ec 08             	sub    $0x8,%sp
	do_default_handler(frame, "Virtualization Exception.");
  1010b2:	83 ec 08             	sub    $0x8,%sp
  1010b5:	68 2b 46             	push   $0x462b
  1010b8:	10 00                	adc    %al,(%bx,%si)
  1010ba:	ff 75 08             	push   0x8(%di)
  1010bd:	e8 f3 fa             	call   100bb3 <dump_core_regs+0x135>
  1010c0:	ff                   	(bad)  
  1010c1:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  1010c5:	90                   	nop
  1010c6:	c9                   	leave  
  1010c7:	c3                   	ret    

001010c8 <interupt_install>:
#include "init.h"
void interupt_install(int irq_num, irq_handler_t handler)
{
  1010c8:	55                   	push   %bp
  1010c9:	89 e5                	mov    %sp,%bp
  1010cb:	83 ec 18             	sub    $0x18,%sp
    if (irq_num >= IDT_ENTRYS_NUM || irq_num < 0)
  1010ce:	81 7d 08 ff 00       	cmpw   $0xff,0x8(%di)
  1010d3:	00 00                	add    %al,(%bx,%si)
  1010d5:	0f 8f 81 00          	jg     10115a <interupt_install+0x92>
  1010d9:	00 00                	add    %al,(%bx,%si)
  1010db:	83 7d 08 00          	cmpw   $0x0,0x8(%di)
  1010df:	78 7b                	js     10115c <interupt_install+0x94>
    {
        return -1;
    }
    uint32_t handler_addr = (uint32_t)handler;
  1010e1:	8b 45 0c             	mov    0xc(%di),%ax
  1010e4:	89 45 f4             	mov    %ax,-0xc(%di)
    gate_desc_t *desc = get_idt_gate_desc(irq_num);
  1010e7:	83 ec 0c             	sub    $0xc,%sp
  1010ea:	ff 75 08             	push   0x8(%di)
  1010ed:	e8 15 06             	call   101705 <idt_init+0x47>
  1010f0:	00 00                	add    %al,(%bx,%si)
  1010f2:	83 c4 10             	add    $0x10,%sp
  1010f5:	89 45 f0             	mov    %ax,-0x10(%di)
    desc->offset_15_0 = handler_addr & 0xFFFF;
  1010f8:	8b 45 f4             	mov    -0xc(%di),%ax
  1010fb:	89 c2                	mov    %ax,%dx
  1010fd:	8b 45 f0             	mov    -0x10(%di),%ax
  101100:	66 89 10             	mov    %edx,(%bx,%si)
    desc->offset_31_16 = (handler_addr >> 16) & 0xFFFF;
  101103:	8b 45 f4             	mov    -0xc(%di),%ax
  101106:	c1 e8 10             	shr    $0x10,%ax
  101109:	89 c2                	mov    %ax,%dx
  10110b:	8b 45 f0             	mov    -0x10(%di),%ax
  10110e:	66 89 50 06          	mov    %edx,0x6(%bx,%si)
    desc->DPL = GATE_DPL0;
  101112:	8b 45 f0             	mov    -0x10(%di),%ax
  101115:	0f b6 50 05          	movzbw 0x5(%bx,%si),%dx
  101119:	83 e2 9f             	and    $0xff9f,%dx
  10111c:	88 50 05             	mov    %dl,0x5(%bx,%si)
    desc->p = 1;
  10111f:	8b 45 f0             	mov    -0x10(%di),%ax
  101122:	0f b6 50 05          	movzbw 0x5(%bx,%si),%dx
  101126:	83 ca 80             	or     $0xff80,%dx
  101129:	88 50 05             	mov    %dl,0x5(%bx,%si)
    desc->param = 0;
  10112c:	8b 45 f0             	mov    -0x10(%di),%ax
  10112f:	c6 40 04 00          	movb   $0x0,0x4(%bx,%si)
    desc->selector = SELECTOR_KERNEL_CODE_SEG;
  101133:	8b 45 f0             	mov    -0x10(%di),%ax
  101136:	66 c7 40 02 18 00 8b 	movl   $0x458b0018,0x2(%bx,%si)
  10113d:	45 
    desc->type = GATE_TRAP_TYPE_IDT;
  10113e:	f0 0f b6 50 05       	lock movzbw 0x5(%bx,%si),%dx
  101143:	83 e2 e0             	and    $0xffe0,%dx
  101146:	83 ca 0f             	or     $0xf,%dx
  101149:	88 50 05             	mov    %dl,0x5(%bx,%si)
    boot_inform->idt_entry_nr++;
  10114c:	a1 e0 e1             	mov    0xe1e0,%ax
  10114f:	12 00                	adc    (%bx,%si),%al
  101151:	8b 50 10             	mov    0x10(%bx,%si),%dx
  101154:	83 c2 01             	add    $0x1,%dx
  101157:	89 50 10             	mov    %dx,0x10(%bx,%si)
    return;
  10115a:	eb 01                	jmp    10115d <interupt_install+0x95>
        return -1;
  10115c:	90                   	nop
}
  10115d:	c9                   	leave  
  10115e:	c3                   	ret    

0010115f <trap_install>:

int trap_install(int irq_num, irq_handler_t handler)
{
  10115f:	55                   	push   %bp
  101160:	89 e5                	mov    %sp,%bp
  101162:	83 ec 18             	sub    $0x18,%sp
    if (irq_num >= IDT_ENTRYS_NUM || irq_num < 0)
  101165:	81 7d 08 ff 00       	cmpw   $0xff,0x8(%di)
  10116a:	00 00                	add    %al,(%bx,%si)
  10116c:	7f 06                	jg     101174 <trap_install+0x15>
  10116e:	83 7d 08 00          	cmpw   $0x0,0x8(%di)
  101172:	79 07                	jns    10117b <trap_install+0x1c>
    {
        return -1;
  101174:	b8 ff ff             	mov    $0xffff,%ax
  101177:	ff                   	(bad)  
  101178:	ff                   	(bad)  
  101179:	eb 79                	jmp    1011f4 <trap_install+0x95>
    }
    uint32_t handler_addr = (uint32_t)handler;
  10117b:	8b 45 0c             	mov    0xc(%di),%ax
  10117e:	89 45 f4             	mov    %ax,-0xc(%di)
    gate_desc_t *desc = get_idt_gate_desc(irq_num);
  101181:	83 ec 0c             	sub    $0xc,%sp
  101184:	ff 75 08             	push   0x8(%di)
  101187:	e8 7b 05             	call   101705 <idt_init+0x47>
  10118a:	00 00                	add    %al,(%bx,%si)
  10118c:	83 c4 10             	add    $0x10,%sp
  10118f:	89 45 f0             	mov    %ax,-0x10(%di)
    desc->offset_15_0 = handler_addr & 0xFFFF;
  101192:	8b 45 f4             	mov    -0xc(%di),%ax
  101195:	89 c2                	mov    %ax,%dx
  101197:	8b 45 f0             	mov    -0x10(%di),%ax
  10119a:	66 89 10             	mov    %edx,(%bx,%si)
    desc->offset_31_16 = (handler_addr >> 16) & 0xFFFF;
  10119d:	8b 45 f4             	mov    -0xc(%di),%ax
  1011a0:	c1 e8 10             	shr    $0x10,%ax
  1011a3:	89 c2                	mov    %ax,%dx
  1011a5:	8b 45 f0             	mov    -0x10(%di),%ax
  1011a8:	66 89 50 06          	mov    %edx,0x6(%bx,%si)
    desc->DPL = GATE_DPL0;
  1011ac:	8b 45 f0             	mov    -0x10(%di),%ax
  1011af:	0f b6 50 05          	movzbw 0x5(%bx,%si),%dx
  1011b3:	83 e2 9f             	and    $0xff9f,%dx
  1011b6:	88 50 05             	mov    %dl,0x5(%bx,%si)
    desc->p = 1;
  1011b9:	8b 45 f0             	mov    -0x10(%di),%ax
  1011bc:	0f b6 50 05          	movzbw 0x5(%bx,%si),%dx
  1011c0:	83 ca 80             	or     $0xff80,%dx
  1011c3:	88 50 05             	mov    %dl,0x5(%bx,%si)
    desc->param = 0;
  1011c6:	8b 45 f0             	mov    -0x10(%di),%ax
  1011c9:	c6 40 04 00          	movb   $0x0,0x4(%bx,%si)
    desc->selector = SELECTOR_KERNEL_CODE_SEG;
  1011cd:	8b 45 f0             	mov    -0x10(%di),%ax
  1011d0:	66 c7 40 02 18 00 8b 	movl   $0x458b0018,0x2(%bx,%si)
  1011d7:	45 
    desc->type = GATE_INT_TYPE_IDT;
  1011d8:	f0 0f b6 50 05       	lock movzbw 0x5(%bx,%si),%dx
  1011dd:	83 e2 e0             	and    $0xffe0,%dx
  1011e0:	83 ca 0e             	or     $0xe,%dx
  1011e3:	88 50 05             	mov    %dl,0x5(%bx,%si)
    boot_inform->idt_entry_nr++;
  1011e6:	a1 e0 e1             	mov    0xe1e0,%ax
  1011e9:	12 00                	adc    (%bx,%si),%al
  1011eb:	8b 50 10             	mov    0x10(%bx,%si),%dx
  1011ee:	83 c2 01             	add    $0x1,%dx
  1011f1:	89 50 10             	mov    %dx,0x10(%bx,%si)
    return;
}
  1011f4:	c9                   	leave  
  1011f5:	c3                   	ret    

001011f6 <trap_init>:
void trap_init(void)
{
  1011f6:	55                   	push   %bp
  1011f7:	89 e5                	mov    %sp,%bp
  1011f9:	83 ec 18             	sub    $0x18,%sp

    for (uint32_t i = 0; i < IDT_ENTRYS_NUM; i++)
  1011fc:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
  101201:	00 00                	add    %al,(%bx,%si)
  101203:	eb 18                	jmp    10121d <trap_init+0x27>
    {
        trap_install(i, exception_handler_unknown);
  101205:	8b 45 f4             	mov    -0xc(%di),%ax
  101208:	83 ec 08             	sub    $0x8,%sp
  10120b:	68 1e 00             	push   $0x1e
  10120e:	10 00                	adc    %al,(%bx,%si)
  101210:	50                   	push   %ax
  101211:	e8 49 ff             	call   10115d <interupt_install+0x95>
  101214:	ff                   	(bad)  
  101215:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    for (uint32_t i = 0; i < IDT_ENTRYS_NUM; i++)
  101219:	83 45 f4 01          	addw   $0x1,-0xc(%di)
  10121d:	81 7d f4 ff 00       	cmpw   $0xff,-0xc(%di)
  101222:	00 00                	add    %al,(%bx,%si)
  101224:	76 df                	jbe    101205 <trap_init+0xf>
    }
    // 设置异常处理接口
    trap_install(IRQ0_DE, exception_handler_divider);
  101226:	83 ec 08             	sub    $0x8,%sp
  101229:	68 3d 00             	push   $0x3d
  10122c:	10 00                	adc    %al,(%bx,%si)
  10122e:	6a 00                	push   $0x0
  101230:	e8 2a ff             	call   10115d <interupt_install+0x95>
  101233:	ff                   	(bad)  
  101234:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ1_DB, exception_handler_Debug);
  101238:	83 ec 08             	sub    $0x8,%sp
  10123b:	68 5c 00             	push   $0x5c
  10123e:	10 00                	adc    %al,(%bx,%si)
  101240:	6a 01                	push   $0x1
  101242:	e8 18 ff             	call   10115d <interupt_install+0x95>
  101245:	ff                   	(bad)  
  101246:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ2_NMI, exception_handler_NMI);
  10124a:	83 ec 08             	sub    $0x8,%sp
  10124d:	68 7b 00             	push   $0x7b
  101250:	10 00                	adc    %al,(%bx,%si)
  101252:	6a 02                	push   $0x2
  101254:	e8 06 ff             	call   10115d <interupt_install+0x95>
  101257:	ff                   	(bad)  
  101258:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ3_BP, exception_handler_breakpoint);
  10125c:	83 ec 08             	sub    $0x8,%sp
  10125f:	68 9a 00             	push   $0x9a
  101262:	10 00                	adc    %al,(%bx,%si)
  101264:	6a 03                	push   $0x3
  101266:	e8 f4 fe             	call   10115d <interupt_install+0x95>
  101269:	ff                   	(bad)  
  10126a:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ4_OF, exception_handler_overflow);
  10126e:	83 ec 08             	sub    $0x8,%sp
  101271:	68 b9 00             	push   $0xb9
  101274:	10 00                	adc    %al,(%bx,%si)
  101276:	6a 04                	push   $0x4
  101278:	e8 e2 fe             	call   10115d <interupt_install+0x95>
  10127b:	ff                   	(bad)  
  10127c:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ5_BR, exception_handler_bound_range);
  101280:	83 ec 08             	sub    $0x8,%sp
  101283:	68 d8 00             	push   $0xd8
  101286:	10 00                	adc    %al,(%bx,%si)
  101288:	6a 05                	push   $0x5
  10128a:	e8 d0 fe             	call   10115d <interupt_install+0x95>
  10128d:	ff                   	(bad)  
  10128e:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ6_UD, exception_handler_invalid_opcode);
  101292:	83 ec 08             	sub    $0x8,%sp
  101295:	68 f7 00             	push   $0xf7
  101298:	10 00                	adc    %al,(%bx,%si)
  10129a:	6a 06                	push   $0x6
  10129c:	e8 be fe             	call   10115d <interupt_install+0x95>
  10129f:	ff                   	(bad)  
  1012a0:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ7_NM, exception_handler_device_unavailable);
  1012a4:	83 ec 08             	sub    $0x8,%sp
  1012a7:	68 16 01             	push   $0x116
  1012aa:	10 00                	adc    %al,(%bx,%si)
  1012ac:	6a 07                	push   $0x7
  1012ae:	e8 ac fe             	call   10115d <interupt_install+0x95>
  1012b1:	ff                   	(bad)  
  1012b2:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ8_DF, exception_handler_double_fault);
  1012b6:	83 ec 08             	sub    $0x8,%sp
  1012b9:	68 35 01             	push   $0x135
  1012bc:	10 00                	adc    %al,(%bx,%si)
  1012be:	6a 08                	push   $0x8
  1012c0:	e8 9a fe             	call   10115d <interupt_install+0x95>
  1012c3:	ff                   	(bad)  
  1012c4:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ10_TS, exception_handler_invalid_tss);
  1012c8:	83 ec 08             	sub    $0x8,%sp
  1012cb:	68 52 01             	push   $0x152
  1012ce:	10 00                	adc    %al,(%bx,%si)
  1012d0:	6a 0a                	push   $0xa
  1012d2:	e8 88 fe             	call   10115d <interupt_install+0x95>
  1012d5:	ff                   	(bad)  
  1012d6:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ11_NP, exception_handler_segment_not_present);
  1012da:	83 ec 08             	sub    $0x8,%sp
  1012dd:	68 6f 01             	push   $0x16f
  1012e0:	10 00                	adc    %al,(%bx,%si)
  1012e2:	6a 0b                	push   $0xb
  1012e4:	e8 76 fe             	call   10115d <interupt_install+0x95>
  1012e7:	ff                   	(bad)  
  1012e8:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ12_SS, exception_handler_stack_segment_fault);
  1012ec:	83 ec 08             	sub    $0x8,%sp
  1012ef:	68 8c 01             	push   $0x18c
  1012f2:	10 00                	adc    %al,(%bx,%si)
  1012f4:	6a 0c                	push   $0xc
  1012f6:	e8 64 fe             	call   10115d <interupt_install+0x95>
  1012f9:	ff                   	(bad)  
  1012fa:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ13_GP, exception_handler_general_protection);
  1012fe:	83 ec 08             	sub    $0x8,%sp
  101301:	68 a9 01             	push   $0x1a9
  101304:	10 00                	adc    %al,(%bx,%si)
  101306:	6a 0d                	push   $0xd
  101308:	e8 52 fe             	call   10115d <interupt_install+0x95>
  10130b:	ff                   	(bad)  
  10130c:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ14_PF, exception_handler_page_fault);
  101310:	83 ec 08             	sub    $0x8,%sp
  101313:	68 c6 01             	push   $0x1c6
  101316:	10 00                	adc    %al,(%bx,%si)
  101318:	6a 0e                	push   $0xe
  10131a:	e8 40 fe             	call   10115d <interupt_install+0x95>
  10131d:	ff                   	(bad)  
  10131e:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ16_MF, exception_handler_fpu_error);
  101322:	83 ec 08             	sub    $0x8,%sp
  101325:	68 e3 01             	push   $0x1e3
  101328:	10 00                	adc    %al,(%bx,%si)
  10132a:	6a 10                	push   $0x10
  10132c:	e8 2e fe             	call   10115d <interupt_install+0x95>
  10132f:	ff                   	(bad)  
  101330:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ17_AC, exception_handler_alignment_check);
  101334:	83 ec 08             	sub    $0x8,%sp
  101337:	68 02 02             	push   $0x202
  10133a:	10 00                	adc    %al,(%bx,%si)
  10133c:	6a 11                	push   $0x11
  10133e:	e8 1c fe             	call   10115d <interupt_install+0x95>
  101341:	ff                   	(bad)  
  101342:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ18_MC, exception_handler_machine_check);
  101346:	83 ec 08             	sub    $0x8,%sp
  101349:	68 1f 02             	push   $0x21f
  10134c:	10 00                	adc    %al,(%bx,%si)
  10134e:	6a 12                	push   $0x12
  101350:	e8 0a fe             	call   10115d <interupt_install+0x95>
  101353:	ff                   	(bad)  
  101354:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ19_XM, exception_handler_smd_exception);
  101358:	83 ec 08             	sub    $0x8,%sp
  10135b:	68 3e 02             	push   $0x23e
  10135e:	10 00                	adc    %al,(%bx,%si)
  101360:	6a 13                	push   $0x13
  101362:	e8 f8 fd             	call   10115d <interupt_install+0x95>
  101365:	ff                   	(bad)  
  101366:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    trap_install(IRQ20_VE, exception_handler_virtual_exception);
  10136a:	83 ec 08             	sub    $0x8,%sp
  10136d:	68 5d 02             	push   $0x25d
  101370:	10 00                	adc    %al,(%bx,%si)
  101372:	6a 14                	push   $0x14
  101374:	e8 e6 fd             	call   10115d <interupt_install+0x95>
  101377:	ff                   	(bad)  
  101378:	ff 83 c4 10          	incw   0x10c4(%bp,%di)

  10137c:	90                   	nop
  10137d:	c9                   	leave  
  10137e:	c3                   	ret    

0010137f <inb>:
static inline uint8_t inb(uint16_t  port) {
  10137f:	55                   	push   %bp
  101380:	89 e5                	mov    %sp,%bp
  101382:	83 ec 14             	sub    $0x14,%sp
  101385:	8b 45 08             	mov    0x8(%di),%ax
  101388:	66 89 45 ec          	mov    %eax,-0x14(%di)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
  10138c:	0f b7 45 ec          	movzww -0x14(%di),%ax
  101390:	89 c2                	mov    %ax,%dx
  101392:	ec                   	in     (%dx),%al
  101393:	88 45 ff             	mov    %al,-0x1(%di)
	return rv;
  101396:	0f b6 45 ff          	movzbw -0x1(%di),%ax
}
  10139a:	c9                   	leave  
  10139b:	c3                   	ret    

0010139c <outb>:
static inline void outb(uint16_t port, uint8_t data) {
  10139c:	55                   	push   %bp
  10139d:	89 e5                	mov    %sp,%bp
  10139f:	83 ec 08             	sub    $0x8,%sp
  1013a2:	8b 45 08             	mov    0x8(%di),%ax
  1013a5:	8b 55 0c             	mov    0xc(%di),%dx
  1013a8:	66 89 45 fc          	mov    %eax,-0x4(%di)
  1013ac:	89 d0                	mov    %dx,%ax
  1013ae:	88 45 f8             	mov    %al,-0x8(%di)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
  1013b1:	0f b7 55 fc          	movzww -0x4(%di),%dx
  1013b5:	0f b6 45 f8          	movzbw -0x8(%di),%ax
  1013b9:	ee                   	out    %al,(%dx)
}
  1013ba:	90                   	nop
  1013bb:	c9                   	leave  
  1013bc:	c3                   	ret    

001013bd <init_pic>:

#include "cpu_instr.h"
#include "8259A.h"

void init_pic(void) {
  1013bd:	55                   	push   %bp
  1013be:	89 e5                	mov    %sp,%bp
    /*主片配置*/
    // 边缘触发，级联，需要配置icw4, 8086模式
    outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
  1013c0:	6a 11                	push   $0x11
  1013c2:	6a 20                	push   $0x20
  1013c4:	e8 d3 ff             	call   10139a <inb+0x1b>
  1013c7:	ff                   	(bad)  
  1013c8:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    // 对应的中断号起始序号0x20
    outb(PIC0_ICW2, IRQ_PIC_START);
  1013cc:	6a 20                	push   $0x20
  1013ce:	6a 21                	push   $0x21
  1013d0:	e8 c7 ff             	call   10139a <inb+0x1b>
  1013d3:	ff                   	(bad)  
  1013d4:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    // 主片IRQ2有从片
    outb(PIC0_ICW3, 1 << 2);
  1013d8:	6a 04                	push   $0x4
  1013da:	6a 21                	push   $0x21
  1013dc:	e8 bb ff             	call   10139a <inb+0x1b>
  1013df:	ff                   	(bad)  
  1013e0:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    // 普通全嵌套、非缓冲、非自动结束、8086模式
    outb(PIC0_ICW4, PIC_ICW4_8086 | PIC_ICW4_SNFM);
  1013e4:	6a 11                	push   $0x11
  1013e6:	6a 21                	push   $0x21
  1013e8:	e8 af ff             	call   10139a <inb+0x1b>
  1013eb:	ff                   	(bad)  
  1013ec:	ff 83 c4 08          	incw   0x8c4(%bp,%di)

    /*从片配置*/
    // 边缘触发，级联，需要配置icw4, 8086模式
    outb(PIC1_ICW1, PIC_ICW1_ICW4 | PIC_ICW1_ALWAYS_1);
  1013f0:	6a 11                	push   $0x11
  1013f2:	68 a0 00             	push   $0xa0
  1013f5:	00 00                	add    %al,(%bx,%si)
  1013f7:	e8 a0 ff             	call   10139a <inb+0x1b>
  1013fa:	ff                   	(bad)  
  1013fb:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    // 起始中断序号，要加上8
    outb(PIC1_ICW2, IRQ_PIC_START + 8);
  1013ff:	6a 28                	push   $0x28
  101401:	68 a1 00             	push   $0xa1
  101404:	00 00                	add    %al,(%bx,%si)
  101406:	e8 91 ff             	call   10139a <inb+0x1b>
  101409:	ff                   	(bad)  
  10140a:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    // 没有从片，连接到主片的IRQ2上
    outb(PIC1_ICW3, 2);
  10140e:	6a 02                	push   $0x2
  101410:	68 a1 00             	push   $0xa1
  101413:	00 00                	add    %al,(%bx,%si)
  101415:	e8 82 ff             	call   10139a <inb+0x1b>
  101418:	ff                   	(bad)  
  101419:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    // “一般嵌套”、非缓冲、非自动结束、8086模式
    outb(PIC1_ICW4, PIC_ICW4_8086);
  10141d:	6a 01                	push   $0x1
  10141f:	68 a1 00             	push   $0xa1
  101422:	00 00                	add    %al,(%bx,%si)
  101424:	e8 73 ff             	call   10139a <inb+0x1b>
  101427:	ff                   	(bad)  
  101428:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    // 禁止所有中断, 允许从PIC1传来的中断
    outb(PIC0_IMR, 0xFF & ~(1 << 2));
  10142c:	68 fb 00             	push   $0xfb
  10142f:	00 00                	add    %al,(%bx,%si)
  101431:	6a 21                	push   $0x21
  101433:	e8 64 ff             	call   10139a <inb+0x1b>
  101436:	ff                   	(bad)  
  101437:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(PIC1_IMR, 0xFF);
  10143b:	68 ff 00             	push   $0xff
  10143e:	00 00                	add    %al,(%bx,%si)
  101440:	68 a1 00             	push   $0xa1
  101443:	00 00                	add    %al,(%bx,%si)
  101445:	e8 52 ff             	call   10139a <inb+0x1b>
  101448:	ff                   	(bad)  
  101449:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
}
  10144d:	90                   	nop
  10144e:	c9                   	leave  
  10144f:	c3                   	ret    

00101450 <pic_send_eoi>:

void pic_send_eoi(int irq_num) {
  101450:	55                   	push   %bp
  101451:	89 e5                	mov    %sp,%bp
    irq_num -= IRQ_PIC_START;
  101453:	83 6d 08 20          	subw   $0x20,0x8(%di)

    // 从片也可能需要发送EOI
    if (irq_num >= 8) {
  101457:	83 7d 08 07          	cmpw   $0x7,0x8(%di)
  10145b:	7e 0f                	jle    10146c <pic_send_eoi+0x1c>
        outb(PIC1_OCW2, PIC_OCW2_EOI);
  10145d:	6a 20                	push   $0x20
  10145f:	68 a0 00             	push   $0xa0
  101462:	00 00                	add    %al,(%bx,%si)
  101464:	e8 33 ff             	call   10139a <inb+0x1b>
  101467:	ff                   	(bad)  
  101468:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    }

    outb(PIC0_OCW2, PIC_OCW2_EOI);
  10146c:	6a 20                	push   $0x20
  10146e:	6a 20                	push   $0x20
  101470:	e8 27 ff             	call   10139a <inb+0x1b>
  101473:	ff                   	(bad)  
  101474:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
}
  101478:	90                   	nop
  101479:	c9                   	leave  
  10147a:	c3                   	ret    

0010147b <irq_enable>:


void irq_enable(int irq_num) {
  10147b:	55                   	push   %bp
  10147c:	89 e5                	mov    %sp,%bp
  10147e:	53                   	push   %bx
  10147f:	83 ec 10             	sub    $0x10,%sp
    if (irq_num < IRQ_PIC_START) {
  101482:	83 7d 08 1f          	cmpw   $0x1f,0x8(%di)
  101486:	7e 78                	jle    101500 <irq_enable+0x85>
        return;
    }

    irq_num -= IRQ_PIC_START;
  101488:	83 6d 08 20          	subw   $0x20,0x8(%di)
    if (irq_num < 8) {
  10148c:	83 7d 08 07          	cmpw   $0x7,0x8(%di)
  101490:	7f 32                	jg     1014c4 <irq_enable+0x49>
        uint8_t mask = inb(PIC0_IMR) & ~(1 << irq_num);
  101492:	6a 21                	push   $0x21
  101494:	e8 e6 fe             	call   10137d <trap_init+0x187>
  101497:	ff                   	(bad)  
  101498:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  10149c:	89 c3                	mov    %ax,%bx
  10149e:	8b 45 08             	mov    0x8(%di),%ax
  1014a1:	ba 01 00             	mov    $0x1,%dx
  1014a4:	00 00                	add    %al,(%bx,%si)
  1014a6:	89 c1                	mov    %ax,%cx
  1014a8:	d3 e2                	shl    %cl,%dx
  1014aa:	89 d0                	mov    %dx,%ax
  1014ac:	f7 d0                	not    %ax
  1014ae:	21 d8                	and    %bx,%ax
  1014b0:	88 45 fa             	mov    %al,-0x6(%di)
        outb(PIC0_IMR, mask);
  1014b3:	0f b6 45 fa          	movzbw -0x6(%di),%ax
  1014b7:	50                   	push   %ax
  1014b8:	6a 21                	push   $0x21
  1014ba:	e8 dd fe             	call   10139a <inb+0x1b>
  1014bd:	ff                   	(bad)  
  1014be:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
  1014c2:	eb 3d                	jmp    101501 <irq_enable+0x86>
    } else {
        irq_num -= 8;
  1014c4:	83 6d 08 08          	subw   $0x8,0x8(%di)
        uint8_t mask = inb(PIC1_IMR) & ~(1 << irq_num);
  1014c8:	68 a1 00             	push   $0xa1
  1014cb:	00 00                	add    %al,(%bx,%si)
  1014cd:	e8 ad fe             	call   10137d <trap_init+0x187>
  1014d0:	ff                   	(bad)  
  1014d1:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  1014d5:	89 c3                	mov    %ax,%bx
  1014d7:	8b 45 08             	mov    0x8(%di),%ax
  1014da:	ba 01 00             	mov    $0x1,%dx
  1014dd:	00 00                	add    %al,(%bx,%si)
  1014df:	89 c1                	mov    %ax,%cx
  1014e1:	d3 e2                	shl    %cl,%dx
  1014e3:	89 d0                	mov    %dx,%ax
  1014e5:	f7 d0                	not    %ax
  1014e7:	21 d8                	and    %bx,%ax
  1014e9:	88 45 fb             	mov    %al,-0x5(%di)
        outb(PIC1_IMR, mask);
  1014ec:	0f b6 45 fb          	movzbw -0x5(%di),%ax
  1014f0:	50                   	push   %ax
  1014f1:	68 a1 00             	push   $0xa1
  1014f4:	00 00                	add    %al,(%bx,%si)
  1014f6:	e8 a1 fe             	call   10139a <inb+0x1b>
  1014f9:	ff                   	(bad)  
  1014fa:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
  1014fe:	eb 01                	jmp    101501 <irq_enable+0x86>
        return;
  101500:	90                   	nop
    }
}
  101501:	8b 5d fc             	mov    -0x4(%di),%bx
  101504:	c9                   	leave  
  101505:	c3                   	ret    

00101506 <irq_disable>:

void irq_disable(int irq_num) {
  101506:	55                   	push   %bp
  101507:	89 e5                	mov    %sp,%bp
  101509:	53                   	push   %bx
  10150a:	83 ec 10             	sub    $0x10,%sp
    if (irq_num < IRQ_PIC_START) {
  10150d:	83 7d 08 1f          	cmpw   $0x1f,0x8(%di)
  101511:	7e 74                	jle    101587 <irq_disable+0x81>
        return;
    }

    irq_num -= IRQ_PIC_START;
  101513:	83 6d 08 20          	subw   $0x20,0x8(%di)
    if (irq_num < 8) {
  101517:	83 7d 08 07          	cmpw   $0x7,0x8(%di)
  10151b:	7f 30                	jg     10154d <irq_disable+0x47>
        uint8_t mask = inb(PIC0_IMR) | (1 << irq_num);
  10151d:	6a 21                	push   $0x21
  10151f:	e8 5b fe             	call   10137d <trap_init+0x187>
  101522:	ff                   	(bad)  
  101523:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  101527:	89 c3                	mov    %ax,%bx
  101529:	8b 45 08             	mov    0x8(%di),%ax
  10152c:	ba 01 00             	mov    $0x1,%dx
  10152f:	00 00                	add    %al,(%bx,%si)
  101531:	89 c1                	mov    %ax,%cx
  101533:	d3 e2                	shl    %cl,%dx
  101535:	89 d0                	mov    %dx,%ax
  101537:	09 d8                	or     %bx,%ax
  101539:	88 45 fa             	mov    %al,-0x6(%di)
        outb(PIC0_IMR, mask);
  10153c:	0f b6 45 fa          	movzbw -0x6(%di),%ax
  101540:	50                   	push   %ax
  101541:	6a 21                	push   $0x21
  101543:	e8 54 fe             	call   10139a <inb+0x1b>
  101546:	ff                   	(bad)  
  101547:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
  10154b:	eb 3b                	jmp    101588 <irq_disable+0x82>
    } else {
        irq_num -= 8;
  10154d:	83 6d 08 08          	subw   $0x8,0x8(%di)
        uint8_t mask = inb(PIC1_IMR) | (1 << irq_num);
  101551:	68 a1 00             	push   $0xa1
  101554:	00 00                	add    %al,(%bx,%si)
  101556:	e8 24 fe             	call   10137d <trap_init+0x187>
  101559:	ff                   	(bad)  
  10155a:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  10155e:	89 c3                	mov    %ax,%bx
  101560:	8b 45 08             	mov    0x8(%di),%ax
  101563:	ba 01 00             	mov    $0x1,%dx
  101566:	00 00                	add    %al,(%bx,%si)
  101568:	89 c1                	mov    %ax,%cx
  10156a:	d3 e2                	shl    %cl,%dx
  10156c:	89 d0                	mov    %dx,%ax
  10156e:	09 d8                	or     %bx,%ax
  101570:	88 45 fb             	mov    %al,-0x5(%di)
        outb(PIC1_IMR, mask);
  101573:	0f b6 45 fb          	movzbw -0x5(%di),%ax
  101577:	50                   	push   %ax
  101578:	68 a1 00             	push   $0xa1
  10157b:	00 00                	add    %al,(%bx,%si)
  10157d:	e8 1a fe             	call   10139a <inb+0x1b>
  101580:	ff                   	(bad)  
  101581:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
  101585:	eb 01                	jmp    101588 <irq_disable+0x82>
        return;
  101587:	90                   	nop
    }
  101588:	8b 5d fc             	mov    -0x4(%di),%bx
  10158b:	c9                   	leave  
  10158c:	c3                   	ret    

0010158d <func>:
#include "task/task.h"
#include "cpu_instr.h"
task_t second_task;

void func(void)
{
  10158d:	55                   	push   %bp
  10158e:	89 e5                	mov    %sp,%bp
  101590:	83 ec 18             	sub    $0x18,%sp
    while (1)
    {

        dbg_info("i am second task\r\n");
  101593:	83 ec 0c             	sub    $0xc,%sp
  101596:	68 a4 46             	push   $0x46a4
  101599:	10 00                	adc    %al,(%bx,%si)
  10159b:	6a 13                	push   $0x13
  10159d:	68 d0 46             	push   $0x46d0
  1015a0:	10 00                	adc    %al,(%bx,%si)
  1015a2:	68 b7 46             	push   $0x46b7
  1015a5:	10 00                	adc    %al,(%bx,%si)
  1015a7:	6a 03                	push   $0x3
  1015a9:	e8 d6 11             	call   102782 <hlt+0x5>
  1015ac:	00 00                	add    %al,(%bx,%si)
  1015ae:	83 c4 20             	add    $0x20,%sp
        for (int i = 0; i < 0xFFFFFF; i++)
  1015b1:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
  1015b6:	00 00                	add    %al,(%bx,%si)
  1015b8:	eb 04                	jmp    1015be <func+0x31>
  1015ba:	83 45 f4 01          	addw   $0x1,-0xc(%di)
  1015be:	81 7d f4 fe ff       	cmpw   $0xfffe,-0xc(%di)
  1015c3:	ff 00                	incw   (%bx,%si)
  1015c5:	7e f3                	jle    1015ba <func+0x2d>
        dbg_info("i am second task\r\n");
  1015c7:	eb ca                	jmp    101593 <func+0x6>

001015c9 <kernel_init>:
        }
        
    }
}
void kernel_init(boot_info_t *boot_info)
{
  1015c9:	55                   	push   %bp
  1015ca:	89 e5                	mov    %sp,%bp
  1015cc:	83 ec 18             	sub    $0x18,%sp
    boot_inform = boot_info;
  1015cf:	8b 45 08             	mov    0x8(%di),%ax
  1015d2:	a3 e0 e1             	mov    %ax,0xe1e0
  1015d5:	12 00                	adc    (%bx,%si),%al
    serial_init();
  1015d7:	e8 2a 11             	call   102704 <rs232_init+0x73>
  1015da:	00 00                	add    %al,(%bx,%si)
    rtc_init();
  1015dc:	e8 20 0f             	call   1024ff <read_cmos+0x25>
  1015df:	00 00                	add    %al,(%bx,%si)
    memory_init();
  1015e1:	e8 07 03             	call   1018eb <cpu_init+0x22>
  1015e4:	00 00                	add    %al,(%bx,%si)
    cpu_init();
  1015e6:	e8 de 02             	call   1018c7 <gdt_init+0x36>
  1015e9:	00 00                	add    %al,(%bx,%si)
    sched_init();
  1015eb:	e8 44 ed             	call   100332 <first_task_init+0x40>
  1015ee:	ff                   	(bad)  
  1015ef:	ff                   	(bad)  
    timer_init();
  1015f0:	e8 3d 0e             	call   102430 <do_handler_timer+0x26>
  1015f3:	00 00                	add    %al,(%bx,%si)
    irq_enable_global();
  1015f5:	e8 28 01             	call   101720 <irq_disable_global+0x9>
  1015f8:	00 00                	add    %al,(%bx,%si)

  

    irq_state_t state = irq_enter_protection();
  1015fa:	e8 2e 01             	call   10172b <irq_enable_global+0x9>
  1015fd:	00 00                	add    %al,(%bx,%si)
  1015ff:	89 45 f0             	mov    %ax,-0x10(%di)
    task_init(&second_task, KERNEL, func,NULL);
  101602:	b8 8d 15             	mov    $0x158d,%ax
  101605:	10 00                	adc    %al,(%bx,%si)
  101607:	6a 00                	push   $0x0
  101609:	50                   	push   %ax
  10160a:	6a 01                	push   $0x1
  10160c:	68 00 e2             	push   $0xe200
  10160f:	12 00                	adc    (%bx,%si),%al
  101611:	e8 8b f0             	call   10069f <tss_init+0x15c>
  101614:	ff                   	(bad)  
  101615:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    set_task_to_ready_list(&second_task);
  101619:	83 ec 0c             	sub    $0xc,%sp
  10161c:	68 00 e2             	push   $0xe200
  10161f:	12 00                	adc    (%bx,%si),%al
  101621:	e8 b6 ed             	call   1003da <get_ready_task+0x41>
  101624:	ff                   	(bad)  
  101625:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    irq_leave_protection(state);
  101629:	83 ec 0c             	sub    $0xc,%sp
  10162c:	ff 75 f0             	push   -0x10(%di)
  10162f:	e8 11 01             	call   101743 <irq_enter_protection+0x16>
  101632:	00 00                	add    %al,(%bx,%si)
  101634:	83 c4 10             	add    $0x10,%sp
        // int i = 1 /0;
        while (1)
    {
        dbg_info("i am first task\r\n");
  101637:	83 ec 0c             	sub    $0xc,%sp
  10163a:	68 be 46             	push   $0x46be
  10163d:	10 00                	adc    %al,(%bx,%si)
  10163f:	6a 2f                	push   $0x2f
  101641:	68 d8 46             	push   $0x46d8
  101644:	10 00                	adc    %al,(%bx,%si)
  101646:	68 b7 46             	push   $0x46b7
  101649:	10 00                	adc    %al,(%bx,%si)
  10164b:	6a 03                	push   $0x3
  10164d:	e8 32 11             	call   102782 <hlt+0x5>
  101650:	00 00                	add    %al,(%bx,%si)
  101652:	83 c4 20             	add    $0x20,%sp
        for (int i = 0; i < 0xFFFFFF; i++)
  101655:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
  10165a:	00 00                	add    %al,(%bx,%si)
  10165c:	eb 04                	jmp    101662 <kernel_init+0x99>
  10165e:	83 45 f4 01          	addw   $0x1,-0xc(%di)
  101662:	81 7d f4 fe ff       	cmpw   $0xfffe,-0xc(%di)
  101667:	ff 00                	incw   (%bx,%si)
  101669:	7e f3                	jle    10165e <kernel_init+0x95>
        dbg_info("i am first task\r\n");
  10166b:	eb ca                	jmp    101637 <kernel_init+0x6e>

0010166d <read_eflags>:
static inline uint32_t read_eflags (void) {
  10166d:	55                   	push   %bp
  10166e:	89 e5                	mov    %sp,%bp
  101670:	83 ec 10             	sub    $0x10,%sp
    __asm__ __volatile__("pushfl\n\tpopl %%eax":"=a"(eflags));
  101673:	9c                   	pushf  
  101674:	58                   	pop    %ax
  101675:	89 45 fc             	mov    %ax,-0x4(%di)
    return eflags;
  101678:	8b 45 fc             	mov    -0x4(%di),%ax
}
  10167b:	c9                   	leave  
  10167c:	c3                   	ret    

0010167d <write_eflags>:
static inline void write_eflags (uint32_t eflags) {
  10167d:	55                   	push   %bp
  10167e:	89 e5                	mov    %sp,%bp
    __asm__ __volatile__("pushl %%eax\n\tpopfl"::"a"(eflags));
  101680:	8b 45 08             	mov    0x8(%di),%ax
  101683:	50                   	push   %ax
  101684:	9d                   	popf   
}
  101685:	90                   	nop
  101686:	5d                   	pop    %bp
  101687:	c3                   	ret    

00101688 <cli>:
static inline void cli() {
  101688:	55                   	push   %bp
  101689:	89 e5                	mov    %sp,%bp
	__asm__ __volatile__("cli");
  10168b:	fa                   	cli    
}
  10168c:	90                   	nop
  10168d:	5d                   	pop    %bp
  10168e:	c3                   	ret    

0010168f <sti>:
static inline void sti() {
  10168f:	55                   	push   %bp
  101690:	89 e5                	mov    %sp,%bp
	__asm__ __volatile__("sti");
  101692:	fb                   	sti    
}
  101693:	90                   	nop
  101694:	5d                   	pop    %bp
  101695:	c3                   	ret    

00101696 <lidt>:
static inline void lidt(uint32_t start, uint32_t size) {
  101696:	55                   	push   %bp
  101697:	89 e5                	mov    %sp,%bp
  101699:	83 ec 10             	sub    $0x10,%sp
	idt.start31_16 = start >> 16;
  10169c:	8b 45 08             	mov    0x8(%di),%ax
  10169f:	c1 e8 10             	shr    $0x10,%ax
  1016a2:	66 89 45 fe          	mov    %eax,-0x2(%di)
	idt.start15_0 = start & 0xFFFF;
  1016a6:	8b 45 08             	mov    0x8(%di),%ax
  1016a9:	66 89 45 fc          	mov    %eax,-0x4(%di)
	idt.limit = size - 1;
  1016ad:	8b 45 0c             	mov    0xc(%di),%ax
  1016b0:	83 e8 01             	sub    $0x1,%ax
  1016b3:	66 89 45 fa          	mov    %eax,-0x6(%di)
	__asm__ __volatile__("lidt %0"::"m"(idt));
  1016b7:	0f 01 5d fa          	lidtw  -0x6(%di)
}
  1016bb:	90                   	nop
  1016bc:	c9                   	leave  
  1016bd:	c3                   	ret    

001016be <idt_init>:

seg_desc_t* gdt;
gate_desc_t idt[IDT_ENTRYS_NUM];

static void idt_init(void)
{
  1016be:	55                   	push   %bp
  1016bf:	89 e5                	mov    %sp,%bp
  1016c1:	83 ec 08             	sub    $0x8,%sp
    boot_inform->idt_base_addr = (uint32_t)idt;
  1016c4:	a1 e0 e1             	mov    0xe1e0,%ax
  1016c7:	12 00                	adc    (%bx,%si),%al
  1016c9:	ba c0 e2             	mov    $0xe2c0,%dx
  1016cc:	12 00                	adc    (%bx,%si),%al
  1016ce:	89 50 0c             	mov    %dx,0xc(%bx,%si)
    boot_inform->idt_entry_nr = 0;
  1016d1:	a1 e0 e1             	mov    0xe1e0,%ax
  1016d4:	12 00                	adc    (%bx,%si),%al
  1016d6:	c7 40 10 00 00       	movw   $0x0,0x10(%bx,%si)
  1016db:	00 00                	add    %al,(%bx,%si)
    boot_inform->idt_entry_limit = IDT_ENTRYS_NUM;
  1016dd:	a1 e0 e1             	mov    0xe1e0,%ax
  1016e0:	12 00                	adc    (%bx,%si),%al
  1016e2:	c7 40 14 00 01       	movw   $0x100,0x14(%bx,%si)
  1016e7:	00 00                	add    %al,(%bx,%si)

    trap_init();
  1016e9:	e8 08 fb             	call   1011f4 <trap_install+0x95>
  1016ec:	ff                   	(bad)  
  1016ed:	ff                   	(bad)  
    lidt((uint32_t)idt,IDTR_LIMIT);
  1016ee:	b8 c0 e2             	mov    $0xe2c0,%ax
  1016f1:	12 00                	adc    (%bx,%si),%al
  1016f3:	83 ec 08             	sub    $0x8,%sp
  1016f6:	68 00 04             	push   $0x400
  1016f9:	00 00                	add    %al,(%bx,%si)
  1016fb:	50                   	push   %ax
  1016fc:	e8 95 ff             	call   101694 <sti+0x5>
  1016ff:	ff                   	(bad)  
  101700:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  101704:	90                   	nop
  101705:	c9                   	leave  
  101706:	c3                   	ret    

00101707 <get_idt_gate_desc>:

gate_desc_t* get_idt_gate_desc(int irq_num)
{
  101707:	55                   	push   %bp
  101708:	89 e5                	mov    %sp,%bp
    return &idt[irq_num];
  10170a:	8b 45 08             	mov    0x8(%di),%ax
  10170d:	c1 e0 03             	shl    $0x3,%ax
  101710:	05 c0 e2             	add    $0xe2c0,%ax
  101713:	12 00                	adc    (%bx,%si),%al
}
  101715:	5d                   	pop    %bp
  101716:	c3                   	ret    

00101717 <irq_disable_global>:



void irq_disable_global(void) {
  101717:	55                   	push   %bp
  101718:	89 e5                	mov    %sp,%bp
    cli();
  10171a:	e8 69 ff             	call   101686 <write_eflags+0x9>
  10171d:	ff                   	(bad)  
  10171e:	ff 90 5d c3          	call   *-0x3ca3(%bx,%si)

00101722 <irq_enable_global>:
}

void irq_enable_global(void) {
  101722:	55                   	push   %bp
  101723:	89 e5                	mov    %sp,%bp
    sti();
  101725:	e8 65 ff             	call   10168d <cli+0x5>
  101728:	ff                   	(bad)  
  101729:	ff 90 5d c3          	call   *-0x3ca3(%bx,%si)

0010172d <irq_enter_protection>:
}

/**
 * @brief 进入中断保护
 */
irq_state_t irq_enter_protection (void) {
  10172d:	55                   	push   %bp
  10172e:	89 e5                	mov    %sp,%bp
  101730:	83 ec 10             	sub    $0x10,%sp
    irq_state_t state = read_eflags();
  101733:	e8 35 ff             	call   10166b <kernel_init+0xa2>
  101736:	ff                   	(bad)  
  101737:	ff 89 45 fc          	decw   -0x3bb(%bx,%di)
    irq_disable_global();
  10173b:	e8 d7 ff             	call   101715 <get_idt_gate_desc+0xe>
  10173e:	ff                   	(bad)  
  10173f:	ff 8b 45 fc          	decw   -0x3bb(%bp,%di)
    return state;
}
  101743:	c9                   	leave  
  101744:	c3                   	ret    

00101745 <irq_leave_protection>:

/**
 * @brief 退出中断保护
 */
void irq_leave_protection (irq_state_t state) {
  101745:	55                   	push   %bp
  101746:	89 e5                	mov    %sp,%bp
    write_eflags(state);
  101748:	ff 75 08             	push   0x8(%di)
  10174b:	e8 2d ff             	call   10167b <read_eflags+0xe>
  10174e:	ff                   	(bad)  
  10174f:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
}
  101753:	90                   	nop
  101754:	c9                   	leave  
  101755:	c3                   	ret    

00101756 <gdt_alloc_desc>:

int gdt_alloc_desc(void)
{
  101756:	55                   	push   %bp
  101757:	89 e5                	mov    %sp,%bp
  101759:	83 ec 10             	sub    $0x10,%sp
    int ret_sel,i;
    for (i = 1; i < GDT_ENTRYS_NUM; i++) {
  10175c:	c7 45 f8 01 00       	movw   $0x1,-0x8(%di)
  101761:	00 00                	add    %al,(%bx,%si)
  101763:	eb 3b                	jmp    1017a0 <gdt_alloc_desc+0x4a>
        seg_desc_t * desc = gdt + i;
  101765:	8b 15                	mov    (%di),%dx
  101767:	a0 e2 12             	mov    0x12e2,%al
  10176a:	00 8b 45 f8          	add    %cl,-0x7bb(%bp,%di)
  10176e:	c1 e0 03             	shl    $0x3,%ax
  101771:	01 d0                	add    %dx,%ax
  101773:	89 45 f4             	mov    %ax,-0xc(%di)
        if (desc->p == 0) {
  101776:	8b 45 f4             	mov    -0xc(%di),%ax
  101779:	0f b6 40 05          	movzbw 0x5(%bx,%si),%ax
  10177d:	83 e0 80             	and    $0xff80,%ax
  101780:	84 c0                	test   %al,%al
  101782:	75 18                	jne    10179c <gdt_alloc_desc+0x46>
            desc->p = 1;     // 标记为占用状态
  101784:	8b 45 f4             	mov    -0xc(%di),%ax
  101787:	0f b6 50 05          	movzbw 0x5(%bx,%si),%dx
  10178b:	83 ca 80             	or     $0xff80,%dx
  10178e:	88 50 05             	mov    %dl,0x5(%bx,%si)
            ret_sel = i << 3;
  101791:	8b 45 f8             	mov    -0x8(%di),%ax
  101794:	c1 e0 03             	shl    $0x3,%ax
  101797:	89 45 fc             	mov    %ax,-0x4(%di)
            break;
  10179a:	eb 0d                	jmp    1017a9 <gdt_alloc_desc+0x53>
    for (i = 1; i < GDT_ENTRYS_NUM; i++) {
  10179c:	83 45 f8 01          	addw   $0x1,-0x8(%di)
  1017a0:	81 7d f8 ff 00       	cmpw   $0xff,-0x8(%di)
  1017a5:	00 00                	add    %al,(%bx,%si)
  1017a7:	7e bc                	jle    101765 <gdt_alloc_desc+0xf>
        }
    }
    if(i>=GDT_ENTRYS_NUM)
  1017a9:	81 7d f8 ff 00       	cmpw   $0xff,-0x8(%di)
  1017ae:	00 00                	add    %al,(%bx,%si)
  1017b0:	7e 07                	jle    1017b9 <gdt_alloc_desc+0x63>
    {
        return -1;
  1017b2:	b8 ff ff             	mov    $0xffff,%ax
  1017b5:	ff                   	(bad)  
  1017b6:	ff                   	(bad)  
  1017b7:	eb 11                	jmp    1017ca <gdt_alloc_desc+0x74>
    }
    boot_inform->gdt_entry_nr++;
  1017b9:	a1 e0 e1             	mov    0xe1e0,%ax
  1017bc:	12 00                	adc    (%bx,%si),%al
  1017be:	8b 50 04             	mov    0x4(%bx,%si),%dx
  1017c1:	83 c2 01             	add    $0x1,%dx
  1017c4:	89 50 04             	mov    %dx,0x4(%bx,%si)
    return ret_sel;
  1017c7:	8b 45 fc             	mov    -0x4(%di),%ax
}
  1017ca:	c9                   	leave  
  1017cb:	c3                   	ret    

001017cc <gdt_free_desc>:
int gdt_free_desc(int selector){
  1017cc:	55                   	push   %bp
  1017cd:	89 e5                	mov    %sp,%bp
  1017cf:	83 ec 10             	sub    $0x10,%sp
    int idx = selector >> 3;
  1017d2:	8b 45 08             	mov    0x8(%di),%ax
  1017d5:	c1 f8 03             	sar    $0x3,%ax
  1017d8:	89 45 fc             	mov    %ax,-0x4(%di)
    gdt[idx].p = 0;
  1017db:	8b 15                	mov    (%di),%dx
  1017dd:	a0 e2 12             	mov    0x12e2,%al
  1017e0:	00 8b 45 fc          	add    %cl,-0x3bb(%bp,%di)
  1017e4:	c1 e0 03             	shl    $0x3,%ax
  1017e7:	01 d0                	add    %dx,%ax
  1017e9:	0f b6 50 05          	movzbw 0x5(%bx,%si),%dx
  1017ed:	83 e2 7f             	and    $0x7f,%dx
  1017f0:	88 50 05             	mov    %dl,0x5(%bx,%si)
    return 0;
  1017f3:	b8 00 00             	mov    $0x0,%ax
  1017f6:	00 00                	add    %al,(%bx,%si)
}
  1017f8:	c9                   	leave  
  1017f9:	c3                   	ret    

001017fa <gdt_set_tss>:
/*
*安装tss段
*/
void gdt_set_tss(int tss_sel,ph_addr_t tss_base,uint32_t tss_limit)
{
  1017fa:	55                   	push   %bp
  1017fb:	89 e5                	mov    %sp,%bp
  1017fd:	83 ec 10             	sub    $0x10,%sp
    seg_desc_t* g = gdt+(tss_sel>>3);
  101800:	8b 15                	mov    (%di),%dx
  101802:	a0 e2 12             	mov    0x12e2,%al
  101805:	00 8b 45 08          	add    %cl,0x845(%bp,%di)
  101809:	c1 f8 03             	sar    $0x3,%ax
  10180c:	c1 e0 03             	shl    $0x3,%ax
  10180f:	01 d0                	add    %dx,%ax
  101811:	89 45 fc             	mov    %ax,-0x4(%di)
    g->p = 1;
  101814:	8b 45 fc             	mov    -0x4(%di),%ax
  101817:	0f b6 50 05          	movzbw 0x5(%bx,%si),%dx
  10181b:	83 ca 80             	or     $0xff80,%dx
  10181e:	88 50 05             	mov    %dl,0x5(%bx,%si)
    g->D_B = 1;
  101821:	8b 45 fc             	mov    -0x4(%di),%ax
  101824:	0f b6 50 06          	movzbw 0x6(%bx,%si),%dx
  101828:	83 ca 40             	or     $0x40,%dx
  10182b:	88 50 06             	mov    %dl,0x6(%bx,%si)
    g->type = SEG_TYPE_TSS;
  10182e:	8b 45 fc             	mov    -0x4(%di),%ax
  101831:	0f b6 50 05          	movzbw 0x5(%bx,%si),%dx
  101835:	83 e2 f0             	and    $0xfff0,%dx
  101838:	83 ca 09             	or     $0x9,%dx
  10183b:	88 50 05             	mov    %dl,0x5(%bx,%si)
    g->base_15_0 = tss_base & 0xFFFF;
  10183e:	8b 45 0c             	mov    0xc(%di),%ax
  101841:	89 c2                	mov    %ax,%dx
  101843:	8b 45 fc             	mov    -0x4(%di),%ax
  101846:	66 89 50 02          	mov    %edx,0x2(%bx,%si)
    g->base_23_16 = (tss_base >> 16) & 0xFF;
  10184a:	8b 45 0c             	mov    0xc(%di),%ax
  10184d:	c1 e8 10             	shr    $0x10,%ax
  101850:	89 c2                	mov    %ax,%dx
  101852:	8b 45 fc             	mov    -0x4(%di),%ax
  101855:	88 50 04             	mov    %dl,0x4(%bx,%si)
    g->base_31_24 = (tss_base >> 24) & 0xFF;
  101858:	8b 45 0c             	mov    0xc(%di),%ax
  10185b:	c1 e8 18             	shr    $0x18,%ax
  10185e:	89 c2                	mov    %ax,%dx
  101860:	8b 45 fc             	mov    -0x4(%di),%ax
  101863:	88 50 07             	mov    %dl,0x7(%bx,%si)

    g->limit_15_0 = tss_limit & 0xFFFF;
  101866:	8b 45 10             	mov    0x10(%di),%ax
  101869:	89 c2                	mov    %ax,%dx
  10186b:	8b 45 fc             	mov    -0x4(%di),%ax
  10186e:	66 89 10             	mov    %edx,(%bx,%si)
    g->limit_19_6 = (tss_limit >> 16)&0xF;
  101871:	8b 45 10             	mov    0x10(%di),%ax
  101874:	c1 e8 10             	shr    $0x10,%ax
  101877:	83 e0 0f             	and    $0xf,%ax
  10187a:	8b 55 fc             	mov    -0x4(%di),%dx
  10187d:	83 e0 0f             	and    $0xf,%ax
  101880:	89 c1                	mov    %ax,%cx
  101882:	0f b6 42 06          	movzbw 0x6(%bp,%si),%ax
  101886:	83 e0 f0             	and    $0xfff0,%ax
  101889:	09 c8                	or     %cx,%ax
  10188b:	88 42 06             	mov    %al,0x6(%bp,%si)
}
  10188e:	90                   	nop
  10188f:	c9                   	leave  
  101890:	c3                   	ret    

00101891 <gdt_init>:

void gdt_init(void)
{
  101891:	55                   	push   %bp
  101892:	89 e5                	mov    %sp,%bp
  101894:	83 ec 10             	sub    $0x10,%sp
    for(int i = boot_inform->gdt_entry_nr;i<GDT_ENTRYS_NUM;++i)
  101897:	a1 e0 e1             	mov    0xe1e0,%ax
  10189a:	12 00                	adc    (%bx,%si),%al
  10189c:	8b 40 04             	mov    0x4(%bx,%si),%ax
  10189f:	89 45 fc             	mov    %ax,-0x4(%di)
  1018a2:	eb 18                	jmp    1018bc <gdt_init+0x2b>
    {
        gdt[i].v=0;
  1018a4:	8b 15                	mov    (%di),%dx
  1018a6:	a0 e2 12             	mov    0x12e2,%al
  1018a9:	00 8b 45 fc          	add    %cl,-0x3bb(%bp,%di)
  1018ad:	c1 e0 03             	shl    $0x3,%ax
  1018b0:	01 d0                	add    %dx,%ax
  1018b2:	c7 00 00 00          	movw   $0x0,(%bx,%si)
  1018b6:	00 00                	add    %al,(%bx,%si)
    for(int i = boot_inform->gdt_entry_nr;i<GDT_ENTRYS_NUM;++i)
  1018b8:	83 45 fc 01          	addw   $0x1,-0x4(%di)
  1018bc:	81 7d fc ff 00       	cmpw   $0xff,-0x4(%di)
  1018c1:	00 00                	add    %al,(%bx,%si)
  1018c3:	7e df                	jle    1018a4 <gdt_init+0x13>
    }
}
  1018c5:	90                   	nop
  1018c6:	90                   	nop
  1018c7:	c9                   	leave  
  1018c8:	c3                   	ret    

001018c9 <cpu_init>:
void cpu_init(void)
{
  1018c9:	55                   	push   %bp
  1018ca:	89 e5                	mov    %sp,%bp
  1018cc:	83 ec 08             	sub    $0x8,%sp
    gdt = (seg_desc_t*)(boot_inform->gdt_base_addr);
  1018cf:	a1 e0 e1             	mov    0xe1e0,%ax
  1018d2:	12 00                	adc    (%bx,%si),%al
  1018d4:	8b 00                	mov    (%bx,%si),%ax
  1018d6:	a3 a0 e2             	mov    %ax,0xe2a0
  1018d9:	12 00                	adc    (%bx,%si),%al
    gdt_init();
  1018db:	e8 b1 ff             	call   10188f <gdt_set_tss+0x95>
  1018de:	ff                   	(bad)  
  1018df:	ff                   	(bad)  
    idt_init();
  1018e0:	e8 d9 fd             	call   1016bc <lidt+0x26>
  1018e3:	ff                   	(bad)  
  1018e4:	ff                   	(bad)  
    init_pic();
  1018e5:	e8 d3 fa             	call   1013bb <outb+0x1f>
  1018e8:	ff                   	(bad)  
  1018e9:	ff 90 c9 c3          	call   *-0x3c37(%bx,%si)

001018ed <memory_init>:
#include "memory.h"

void memory_init(void)
{
  1018ed:	55                   	push   %bp
  1018ee:	89 e5                	mov    %sp,%bp
  1018f0:	83 ec 08             	sub    $0x8,%sp
    memblock_init();
  1018f3:	e8 cc 09             	call   1022c2 <mm_free_one_page+0x16>
  1018f6:	00 00                	add    %al,(%bx,%si)
    kernel_pgd_create();
  1018f8:	e8 0f 00             	call   10190a <write_cr3+0xa>
  1018fb:	00 00                	add    %al,(%bx,%si)
  1018fd:	90                   	nop
  1018fe:	c9                   	leave  
  1018ff:	c3                   	ret    

00101900 <write_cr3>:
static inline void write_cr3(uint32_t v) {
  101900:	55                   	push   %bp
  101901:	89 e5                	mov    %sp,%bp
    __asm__ __volatile__("mov %[v], %%cr3"::[v]"r"(v));
  101903:	8b 45 08             	mov    0x8(%di),%ax
  101906:	0f 22 d8             	mov    %eax,%cr3
}
  101909:	90                   	nop
  10190a:	5d                   	pop    %bp
  10190b:	c3                   	ret    

0010190c <kernel_pgd_create>:
#include "cpu_instr.h"
// 全局页目录表
static uint32_t pgd[1024] __attribute__((aligned(4096))) = {0};

void kernel_pgd_create(void)
{
  10190c:	55                   	push   %bp
  10190d:	89 e5                	mov    %sp,%bp
  10190f:	83 ec 28             	sub    $0x28,%sp
    ph_addr_t start_addr = 0;
  101912:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
  101917:	00 00                	add    %al,(%bx,%si)
    ph_addr_t end_addr = MEM_TOTAL_SIZE - 1;
  101919:	c7 45 e8 ff ff       	movw   $0xffff,-0x18(%di)
  10191e:	ff 07                	incw   (%bx)
    // 一张中间页表，管理4MB空间,计算需要多少张中间页表
    uint32_t pmd_num = MEM_TOTAL_SIZE / (4 * 1024 * 1024);
  101920:	c7 45 e4 20 00       	movw   $0x20,-0x1c(%di)
  101925:	00 00                	add    %al,(%bx,%si)
    // 0~128M 4KB 恒等映射
    for (int i = 0; i < pmd_num; i++)
  101927:	c7 45 f0 00 00       	movw   $0x0,-0x10(%di)
  10192c:	00 00                	add    %al,(%bx,%si)
  10192e:	e9 82 00             	jmp    1019b3 <kernel_pgd_create+0xa7>
  101931:	00 00                	add    %al,(%bx,%si)
    {
        ph_addr_t pmd_addr = (uint32_t *)mm_alloc_one_page();
  101933:	e8 5f 09             	call   102295 <mm_free_pages+0x133>
  101936:	00 00                	add    %al,(%bx,%si)
  101938:	89 45 e0             	mov    %ax,-0x20(%di)
        // dbg_info("alloc a pmd:%x\r\n",pmd_addr);
        uint32_t *pte = (uint32_t *)pmd_addr;
  10193b:	8b 45 e0             	mov    -0x20(%di),%ax
  10193e:	89 45 dc             	mov    %ax,-0x24(%di)
        if (pmd_addr & 0xFFF != 0)
  101941:	8b 45 e0             	mov    -0x20(%di),%ax
  101944:	83 e0 01             	and    $0x1,%ax
  101947:	85 c0                	test   %ax,%ax
  101949:	74 20                	je     10196b <kernel_pgd_create+0x5f>
        {
            dbg_error("pmd not align \r\n");
  10194b:	83 ec 0c             	sub    $0xc,%sp
  10194e:	68 34 47             	push   $0x4734
  101951:	10 00                	adc    %al,(%bx,%si)
  101953:	6a 17                	push   $0x17
  101955:	68 18 49             	push   $0x4918
  101958:	10 00                	adc    %al,(%bx,%si)
  10195a:	68 45 47             	push   $0x4745
  10195d:	10 00                	adc    %al,(%bx,%si)
  10195f:	6a 01                	push   $0x1
  101961:	e8 1e 0e             	call   102782 <hlt+0x5>
  101964:	00 00                	add    %al,(%bx,%si)
  101966:	83 c4 20             	add    $0x20,%sp
            return;
  101969:	eb 68                	jmp    1019d3 <kernel_pgd_create+0xc7>
        }
        // 给PDE赋值
        pgd[i] = pmd_addr | PDE_P | PDE_U;
  10196b:	8b 45 e0             	mov    -0x20(%di),%ax
  10196e:	83 c8 05             	or     $0x5,%ax
  101971:	89 c2                	mov    %ax,%dx
  101973:	8b 45 f0             	mov    -0x10(%di),%ax
  101976:	89 14                	mov    %dx,(%si)
  101978:	85 00                	test   %ax,(%bx,%si)
  10197a:	f0 12 00             	lock adc (%bx,%si),%al
        // dbg_info("pde addr %x,value %x",&pgd[i],pgd[i]);
        // 给PTE赋值
        for (int j = 0; j < 1024; j++)
  10197d:	c7 45 ec 00 00       	movw   $0x0,-0x14(%di)
  101982:	00 00                	add    %al,(%bx,%si)
  101984:	eb 22                	jmp    1019a8 <kernel_pgd_create+0x9c>
        {
            pte[j] = start_addr | PTE_P | PTE_W;
  101986:	8b 45 ec             	mov    -0x14(%di),%ax
  101989:	8d 14                	lea    (%si),%dx
  10198b:	85 00                	test   %ax,(%bx,%si)
  10198d:	00 00                	add    %al,(%bx,%si)
  10198f:	00 8b 45 dc          	add    %cl,-0x23bb(%bp,%di)
  101993:	01 d0                	add    %dx,%ax
  101995:	8b 55 f4             	mov    -0xc(%di),%dx
  101998:	83 ca 03             	or     $0x3,%dx
  10199b:	89 10                	mov    %dx,(%bx,%si)
            // dbg_info("pte addr %x,value %x\r\n",&pte[j],pte[j]);
            start_addr += MEM_PAGE_SIZE;
  10199d:	81 45 f4 00 10       	addw   $0x1000,-0xc(%di)
  1019a2:	00 00                	add    %al,(%bx,%si)
        for (int j = 0; j < 1024; j++)
  1019a4:	83 45 ec 01          	addw   $0x1,-0x14(%di)
  1019a8:	81 7d ec ff 03       	cmpw   $0x3ff,-0x14(%di)
  1019ad:	00 00                	add    %al,(%bx,%si)
  1019af:	7e d5                	jle    101986 <kernel_pgd_create+0x7a>
    for (int i = 0; i < pmd_num; i++)
  1019b1:	83 45 f0 01          	addw   $0x1,-0x10(%di)
  1019b5:	8b 45 f0             	mov    -0x10(%di),%ax
  1019b8:	39 45 e4             	cmp    %ax,-0x1c(%di)
  1019bb:	0f 87 72 ff          	ja     101931 <kernel_pgd_create+0x25>
  1019bf:	ff                   	(bad)  
  1019c0:	ff                   	(bad)  
        }
    }
    // 设置页表地址
    write_cr3((uint32_t)pgd);
  1019c1:	b8 00 f0             	mov    $0xf000,%ax
  1019c4:	12 00                	adc    (%bx,%si),%al
  1019c6:	83 ec 0c             	sub    $0xc,%sp
  1019c9:	50                   	push   %ax
  1019ca:	e8 31 ff             	call   1018fe <memory_init+0x11>
  1019cd:	ff                   	(bad)  
  1019ce:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    return;
  1019d2:	90                   	nop
}
  1019d3:	c9                   	leave  
  1019d4:	c3                   	ret    

001019d5 <mmu_memory_map>:

/*建立虚拟地址，物理地址内存映射关系*/
int mmu_memory_map(ph_addr_t vm, ph_addr_t phm, uint32_t write_disable, uint32_t user_mode_acc)
{
  1019d5:	55                   	push   %bp
  1019d6:	89 e5                	mov    %sp,%bp
  1019d8:	53                   	push   %bx
  1019d9:	83 ec 24             	sub    $0x24,%sp
    int pgd_idx = (vm >> 22) & 0x3FF; // 取虚拟地址高10位
  1019dc:	8b 45 08             	mov    0x8(%di),%ax
  1019df:	c1 e8 16             	shr    $0x16,%ax
  1019e2:	89 45 ec             	mov    %ax,-0x14(%di)
    pde_t *pde = &pgd[pgd_idx];
  1019e5:	8b 45 ec             	mov    -0x14(%di),%ax
  1019e8:	c1 e0 02             	shl    $0x2,%ax
  1019eb:	05 00 f0             	add    $0xf000,%ax
  1019ee:	12 00                	adc    (%bx,%si),%al
  1019f0:	89 45 e8             	mov    %ax,-0x18(%di)
    ph_addr_t pmd,alloced;
    if (!pde->present)
  1019f3:	8b 45 e8             	mov    -0x18(%di),%ax
  1019f6:	0f b6 00             	movzbw (%bx,%si),%ax
  1019f9:	83 e0 01             	and    $0x1,%ax
  1019fc:	84 c0                	test   %al,%al
  1019fe:	75 7d                	jne    101a7d <mmu_memory_map+0xa8>
    {
        pmd = mm_alloc_one_page();
  101a00:	e8 92 08             	call   102295 <mm_free_pages+0x133>
  101a03:	00 00                	add    %al,(%bx,%si)
  101a05:	89 45 f4             	mov    %ax,-0xc(%di)
        alloced = pmd;
  101a08:	8b 45 f4             	mov    -0xc(%di),%ax
  101a0b:	89 45 f0             	mov    %ax,-0x10(%di)
        pde->present = 1;
  101a0e:	8b 45 e8             	mov    -0x18(%di),%ax
  101a11:	0f b6 10             	movzbw (%bx,%si),%dx
  101a14:	83 ca 01             	or     $0x1,%dx
  101a17:	88 10                	mov    %dl,(%bx,%si)
        pde->write_disable = 1; 
  101a19:	8b 45 e8             	mov    -0x18(%di),%ax
  101a1c:	0f b6 10             	movzbw (%bx,%si),%dx
  101a1f:	83 ca 02             	or     $0x2,%dx
  101a22:	88 10                	mov    %dl,(%bx,%si)
        pde->user_mode_acc = 1; 
  101a24:	8b 45 e8             	mov    -0x18(%di),%ax
  101a27:	0f b6 10             	movzbw (%bx,%si),%dx
  101a2a:	83 ca 04             	or     $0x4,%dx
  101a2d:	88 10                	mov    %dl,(%bx,%si)
        pde->phy_pt_addr = pmd >> 12;       
  101a2f:	8b 45 f4             	mov    -0xc(%di),%ax
  101a32:	c1 e8 0c             	shr    $0xc,%ax
  101a35:	25 ff ff             	and    $0xffff,%ax
  101a38:	0f 00 89 c2 8b       	str    -0x743e(%bx,%di)
  101a3d:	45                   	inc    %bp
  101a3e:	e8 89 d1             	call   10ebca <task_pool+0x6a6a>
  101a41:	83 e1 0f             	and    $0xf,%cx
  101a44:	89 cb                	mov    %cx,%bx
  101a46:	c1 e3 04             	shl    $0x4,%bx
  101a49:	0f b6 48 01          	movzbw 0x1(%bx,%si),%cx
  101a4d:	83 e1 0f             	and    $0xf,%cx
  101a50:	09 d9                	or     %bx,%cx
  101a52:	88 48 01             	mov    %cl,0x1(%bx,%si)
  101a55:	89 d1                	mov    %dx,%cx
  101a57:	c1 e9 04             	shr    $0x4,%cx
  101a5a:	0f b6 d9             	movzbw %cl,%bx
  101a5d:	0f b6 48 02          	movzbw 0x2(%bx,%si),%cx
  101a61:	83 e1 00             	and    $0x0,%cx
  101a64:	09 d9                	or     %bx,%cx
  101a66:	88 48 02             	mov    %cl,0x2(%bx,%si)
  101a69:	c1 ea 0c             	shr    $0xc,%dx
  101a6c:	0f b6 ca             	movzbw %dl,%cx
  101a6f:	0f b6 50 03          	movzbw 0x3(%bx,%si),%dx
  101a73:	83 e2 00             	and    $0x0,%dx
  101a76:	09 ca                	or     %cx,%dx
  101a78:	88 50 03             	mov    %dl,0x3(%bx,%si)
  101a7b:	eb 25                	jmp    101aa2 <mmu_memory_map+0xcd>
    }
    else
    {
        pmd = pde->phy_pt_addr << 12;
  101a7d:	8b 45 e8             	mov    -0x18(%di),%ax
  101a80:	0f b6 50 01          	movzbw 0x1(%bx,%si),%dx
  101a84:	c0 ea 04             	shr    $0x4,%dl
  101a87:	0f b6 ca             	movzbw %dl,%cx
  101a8a:	0f b6 50 02          	movzbw 0x2(%bx,%si),%dx
  101a8e:	c1 e2 04             	shl    $0x4,%dx
  101a91:	09 ca                	or     %cx,%dx
  101a93:	0f b6 40 03          	movzbw 0x3(%bx,%si),%ax
  101a97:	c1 e0 0c             	shl    $0xc,%ax
  101a9a:	09 d0                	or     %dx,%ax
  101a9c:	c1 e0 0c             	shl    $0xc,%ax
  101a9f:	89 45 f4             	mov    %ax,-0xc(%di)
    }
    pte_t *pte = (pte_t *)pmd;
  101aa2:	8b 45 f4             	mov    -0xc(%di),%ax
  101aa5:	89 45 e4             	mov    %ax,-0x1c(%di)

    int pmd_idx = (vm >> 12) & 0x3FF; // 取虚拟地址中间10位
  101aa8:	8b 45 08             	mov    0x8(%di),%ax
  101aab:	c1 e8 0c             	shr    $0xc,%ax
  101aae:	25 ff 03             	and    $0x3ff,%ax
  101ab1:	00 00                	add    %al,(%bx,%si)
  101ab3:	89 45 e0             	mov    %ax,-0x20(%di)
    pte += pmd_idx;
  101ab6:	8b 45 e0             	mov    -0x20(%di),%ax
  101ab9:	c1 e0 02             	shl    $0x2,%ax
  101abc:	01 45 e4             	add    %ax,-0x1c(%di)
    if (pte->present)
  101abf:	8b 45 e4             	mov    -0x1c(%di),%ax
  101ac2:	0f b6 00             	movzbw (%bx,%si),%ax
  101ac5:	83 e0 01             	and    $0x1,%ax
  101ac8:	84 c0                	test   %al,%al
  101aca:	74 36                	je     101b02 <mmu_memory_map+0x12d>
    {
        mm_free_one_page(alloced);
  101acc:	83 ec 0c             	sub    $0xc,%sp
  101acf:	ff 75 f0             	push   -0x10(%di)
  101ad2:	e8 d5 07             	call   1022aa <mm_alloc_one_page+0x13>
  101ad5:	00 00                	add    %al,(%bx,%si)
  101ad7:	83 c4 10             	add    $0x10,%sp
        dbg_error("There is a mapping relationship here, and this operation will overwrite the existing mapping");
  101ada:	83 ec 0c             	sub    $0xc,%sp
  101add:	68 54 47             	push   $0x4754
  101ae0:	10 00                	adc    %al,(%bx,%si)
  101ae2:	6a 44                	push   $0x44
  101ae4:	68 2c 49             	push   $0x492c
  101ae7:	10 00                	adc    %al,(%bx,%si)
  101ae9:	68 45 47             	push   $0x4745
  101aec:	10 00                	adc    %al,(%bx,%si)
  101aee:	6a 01                	push   $0x1
  101af0:	e8 8f 0c             	call   102782 <hlt+0x5>
  101af3:	00 00                	add    %al,(%bx,%si)
  101af5:	83 c4 20             	add    $0x20,%sp
        return -1;
  101af8:	b8 ff ff             	mov    $0xffff,%ax
  101afb:	ff                   	(bad)  
  101afc:	ff                   	(bad)  
  101afd:	e9 92 00             	jmp    101b92 <mmu_memory_map+0x1bd>
  101b00:	00 00                	add    %al,(%bx,%si)
    }
    pte->present = 1;
  101b02:	8b 45 e4             	mov    -0x1c(%di),%ax
  101b05:	0f b6 10             	movzbw (%bx,%si),%dx
  101b08:	83 ca 01             	or     $0x1,%dx
  101b0b:	88 10                	mov    %dl,(%bx,%si)
    pte->write_disable = write_disable;
  101b0d:	8b 45 10             	mov    0x10(%di),%ax
  101b10:	83 e0 01             	and    $0x1,%ax
  101b13:	8b 55 e4             	mov    -0x1c(%di),%dx
  101b16:	83 e0 01             	and    $0x1,%ax
  101b19:	8d 0c                	lea    (%si),%cx
  101b1b:	00 0f                	add    %cl,(%bx)
  101b1d:	b6 02                	mov    $0x2,%dh
  101b1f:	83 e0 fd             	and    $0xfffd,%ax
  101b22:	09 c8                	or     %cx,%ax
  101b24:	88 02                	mov    %al,(%bp,%si)
    pte->user_mode_acc = user_mode_acc;
  101b26:	8b 45 14             	mov    0x14(%di),%ax
  101b29:	83 e0 01             	and    $0x1,%ax
  101b2c:	8b 55 e4             	mov    -0x1c(%di),%dx
  101b2f:	83 e0 01             	and    $0x1,%ax
  101b32:	8d 0c                	lea    (%si),%cx
  101b34:	85 00                	test   %ax,(%bx,%si)
  101b36:	00 00                	add    %al,(%bx,%si)
  101b38:	00 0f                	add    %cl,(%bx)
  101b3a:	b6 02                	mov    $0x2,%dh
  101b3c:	83 e0 fb             	and    $0xfffb,%ax
  101b3f:	09 c8                	or     %cx,%ax
  101b41:	88 02                	mov    %al,(%bp,%si)
    pte->phy_page_addr = phm >> 12;
  101b43:	8b 45 0c             	mov    0xc(%di),%ax
  101b46:	c1 e8 0c             	shr    $0xc,%ax
  101b49:	25 ff ff             	and    $0xffff,%ax
  101b4c:	0f 00 89 c2 8b       	str    -0x743e(%bx,%di)
  101b51:	45                   	inc    %bp
  101b52:	e4 89                	in     $0x89,%al
  101b54:	d1 83 e1 0f          	rolw   0xfe1(%bp,%di)
  101b58:	89 cb                	mov    %cx,%bx
  101b5a:	c1 e3 04             	shl    $0x4,%bx
  101b5d:	0f b6 48 01          	movzbw 0x1(%bx,%si),%cx
  101b61:	83 e1 0f             	and    $0xf,%cx
  101b64:	09 d9                	or     %bx,%cx
  101b66:	88 48 01             	mov    %cl,0x1(%bx,%si)
  101b69:	89 d1                	mov    %dx,%cx
  101b6b:	c1 e9 04             	shr    $0x4,%cx
  101b6e:	0f b6 d9             	movzbw %cl,%bx
  101b71:	0f b6 48 02          	movzbw 0x2(%bx,%si),%cx
  101b75:	83 e1 00             	and    $0x0,%cx
  101b78:	09 d9                	or     %bx,%cx
  101b7a:	88 48 02             	mov    %cl,0x2(%bx,%si)
  101b7d:	c1 ea 0c             	shr    $0xc,%dx
  101b80:	0f b6 ca             	movzbw %dl,%cx
  101b83:	0f b6 50 03          	movzbw 0x3(%bx,%si),%dx
  101b87:	83 e2 00             	and    $0x0,%dx
  101b8a:	09 ca                	or     %cx,%dx
  101b8c:	88 50 03             	mov    %dl,0x3(%bx,%si)

    return 1;
  101b8f:	b8 01 00             	mov    $0x1,%ax
  101b92:	00 00                	add    %al,(%bx,%si)
}
  101b94:	8b 5d fc             	mov    -0x4(%di),%bx
  101b97:	c9                   	leave  
  101b98:	c3                   	ret    

00101b99 <mmu_get_phaddr>:

/*根据虚拟地址获取物理地址*/
int mmu_get_phaddr(ph_addr_t vm) 
{
  101b99:	55                   	push   %bp
  101b9a:	89 e5                	mov    %sp,%bp
  101b9c:	83 ec 38             	sub    $0x38,%sp
    int pgd_idx = (vm >> 22) & 0x3FF; // 获取虚拟地址的页目录索引（高10位）
  101b9f:	8b 45 08             	mov    0x8(%di),%ax
  101ba2:	c1 e8 16             	shr    $0x16,%ax
  101ba5:	89 45 f4             	mov    %ax,-0xc(%di)
    int pmd_idx = (vm >> 12) & 0x3FF; // 获取虚拟地址的页表索引（中间10位）
  101ba8:	8b 45 08             	mov    0x8(%di),%ax
  101bab:	c1 e8 0c             	shr    $0xc,%ax
  101bae:	25 ff 03             	and    $0x3ff,%ax
  101bb1:	00 00                	add    %al,(%bx,%si)
  101bb3:	89 45 f0             	mov    %ax,-0x10(%di)
    int page_offset = vm & 0xFFF;     // 获取虚拟地址的页内偏移（低12位）
  101bb6:	8b 45 08             	mov    0x8(%di),%ax
  101bb9:	25 ff 0f             	and    $0xfff,%ax
  101bbc:	00 00                	add    %al,(%bx,%si)
  101bbe:	89 45 ec             	mov    %ax,-0x14(%di)

    // 获取页目录项
    pde_t* pde = &pgd[pgd_idx];
  101bc1:	8b 45 f4             	mov    -0xc(%di),%ax
  101bc4:	c1 e0 02             	shl    $0x2,%ax
  101bc7:	05 00 f0             	add    $0xf000,%ax
  101bca:	12 00                	adc    (%bx,%si),%al
  101bcc:	89 45 e8             	mov    %ax,-0x18(%di)
    if (!pde->present) {
  101bcf:	8b 45 e8             	mov    -0x18(%di),%ax
  101bd2:	0f b6 00             	movzbw (%bx,%si),%ax
  101bd5:	83 e0 01             	and    $0x1,%ax
  101bd8:	84 c0                	test   %al,%al
  101bda:	75 28                	jne    101c04 <mmu_get_phaddr+0x6b>
        dbg_error("Page directory entry not present");
  101bdc:	83 ec 0c             	sub    $0xc,%sp
  101bdf:	68 b4 47             	push   $0x47b4
  101be2:	10 00                	adc    %al,(%bx,%si)
  101be4:	6a 59                	push   $0x59
  101be6:	68 3c 49             	push   $0x493c
  101be9:	10 00                	adc    %al,(%bx,%si)
  101beb:	68 45 47             	push   $0x4745
  101bee:	10 00                	adc    %al,(%bx,%si)
  101bf0:	6a 01                	push   $0x1
  101bf2:	e8 8d 0b             	call   102782 <hlt+0x5>
  101bf5:	00 00                	add    %al,(%bx,%si)
  101bf7:	83 c4 20             	add    $0x20,%sp
        return -1; // 页目录项不存在
  101bfa:	b8 ff ff             	mov    $0xffff,%ax
  101bfd:	ff                   	(bad)  
  101bfe:	ff                   	(bad)  
  101bff:	e9 a0 00             	jmp    101ca2 <mmu_get_phaddr+0x109>
  101c02:	00 00                	add    %al,(%bx,%si)
    }

    // 获取页表基地址
    ph_addr_t pmd = pde->phy_pt_addr << 12;
  101c04:	8b 45 e8             	mov    -0x18(%di),%ax
  101c07:	0f b6 50 01          	movzbw 0x1(%bx,%si),%dx
  101c0b:	c0 ea 04             	shr    $0x4,%dl
  101c0e:	0f b6 ca             	movzbw %dl,%cx
  101c11:	0f b6 50 02          	movzbw 0x2(%bx,%si),%dx
  101c15:	c1 e2 04             	shl    $0x4,%dx
  101c18:	09 ca                	or     %cx,%dx
  101c1a:	0f b6 40 03          	movzbw 0x3(%bx,%si),%ax
  101c1e:	c1 e0 0c             	shl    $0xc,%ax
  101c21:	09 d0                	or     %dx,%ax
  101c23:	c1 e0 0c             	shl    $0xc,%ax
  101c26:	89 45 e4             	mov    %ax,-0x1c(%di)
    pte_t* pte = (pte_t*)pmd;
  101c29:	8b 45 e4             	mov    -0x1c(%di),%ax
  101c2c:	89 45 e0             	mov    %ax,-0x20(%di)

    // 获取页表项
    pte_t* page_entry = &pte[pmd_idx];
  101c2f:	8b 45 f0             	mov    -0x10(%di),%ax
  101c32:	8d 14                	lea    (%si),%dx
  101c34:	85 00                	test   %ax,(%bx,%si)
  101c36:	00 00                	add    %al,(%bx,%si)
  101c38:	00 8b 45 e0          	add    %cl,-0x1fbb(%bp,%di)
  101c3c:	01 d0                	add    %dx,%ax
  101c3e:	89 45 dc             	mov    %ax,-0x24(%di)
    if (!page_entry->present) {
  101c41:	8b 45 dc             	mov    -0x24(%di),%ax
  101c44:	0f b6 00             	movzbw (%bx,%si),%ax
  101c47:	83 e0 01             	and    $0x1,%ax
  101c4a:	84 c0                	test   %al,%al
  101c4c:	75 25                	jne    101c73 <mmu_get_phaddr+0xda>
        dbg_error("Page table entry not present");
  101c4e:	83 ec 0c             	sub    $0xc,%sp
  101c51:	68 d5 47             	push   $0x47d5
  101c54:	10 00                	adc    %al,(%bx,%si)
  101c56:	6a 64                	push   $0x64
  101c58:	68 3c 49             	push   $0x493c
  101c5b:	10 00                	adc    %al,(%bx,%si)
  101c5d:	68 45 47             	push   $0x4745
  101c60:	10 00                	adc    %al,(%bx,%si)
  101c62:	6a 01                	push   $0x1
  101c64:	e8 1b 0b             	call   102782 <hlt+0x5>
  101c67:	00 00                	add    %al,(%bx,%si)
  101c69:	83 c4 20             	add    $0x20,%sp
        return -1; 
  101c6c:	b8 ff ff             	mov    $0xffff,%ax
  101c6f:	ff                   	(bad)  
  101c70:	ff                   	(bad)  
  101c71:	eb 31                	jmp    101ca4 <mmu_get_phaddr+0x10b>
    }

    
    ph_addr_t physical_page = page_entry->phy_page_addr << 12;
  101c73:	8b 45 dc             	mov    -0x24(%di),%ax
  101c76:	0f b6 50 01          	movzbw 0x1(%bx,%si),%dx
  101c7a:	c0 ea 04             	shr    $0x4,%dl
  101c7d:	0f b6 ca             	movzbw %dl,%cx
  101c80:	0f b6 50 02          	movzbw 0x2(%bx,%si),%dx
  101c84:	c1 e2 04             	shl    $0x4,%dx
  101c87:	09 ca                	or     %cx,%dx
  101c89:	0f b6 40 03          	movzbw 0x3(%bx,%si),%ax
  101c8d:	c1 e0 0c             	shl    $0xc,%ax
  101c90:	09 d0                	or     %dx,%ax
  101c92:	c1 e0 0c             	shl    $0xc,%ax
  101c95:	89 45 d8             	mov    %ax,-0x28(%di)
    ph_addr_t physical_address = physical_page | page_offset;
  101c98:	8b 45 ec             	mov    -0x14(%di),%ax
  101c9b:	0b 45 d8             	or     -0x28(%di),%ax
  101c9e:	89 45 d4             	mov    %ax,-0x2c(%di)

    return physical_address;
  101ca1:	8b 45 d4             	mov    -0x2c(%di),%ax
}
  101ca4:	c9                   	leave  
  101ca5:	c3                   	ret    

00101ca6 <mmu_create_task_pgd>:
#include "string.h"
/**
 * 创建任务页表，并且拷贝内核页表
 */
ph_addr_t mmu_create_task_pgd(void)
{
  101ca6:	55                   	push   %bp
  101ca7:	89 e5                	mov    %sp,%bp
  101ca9:	53                   	push   %bx
  101caa:	83 ec 24             	sub    $0x24,%sp
    //分配一个页目录表
    ph_addr_t page_dir = mm_alloc_one_page();
  101cad:	e8 e5 05             	call   102295 <mm_free_pages+0x133>
  101cb0:	00 00                	add    %al,(%bx,%si)
  101cb2:	89 45 ec             	mov    %ax,-0x14(%di)
    if(page_dir < 0)
    {
        return  -1;
    }
    //然后就是拷贝内核页表
    pde_t* pde_dest = (pde_t*) page_dir;
  101cb5:	8b 45 ec             	mov    -0x14(%di),%ax
  101cb8:	89 45 e8             	mov    %ax,-0x18(%di)
    pde_t* pde_src = (pde_t*) pgd;
  101cbb:	c7 45 e4 00 f0       	movw   $0xf000,-0x1c(%di)
  101cc0:	12 00                	adc    (%bx,%si),%al
    for (int i = 0; i < 1024; i++)
  101cc2:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
  101cc7:	00 00                	add    %al,(%bx,%si)
  101cc9:	e9 2c 01             	jmp    101df8 <mmu_create_task_pgd+0x152>
  101ccc:	00 00                	add    %al,(%bx,%si)
    {
        if(pde_src[i].present){
  101cce:	8b 45 f4             	mov    -0xc(%di),%ax
  101cd1:	8d 14                	lea    (%si),%dx
  101cd3:	85 00                	test   %ax,(%bx,%si)
  101cd5:	00 00                	add    %al,(%bx,%si)
  101cd7:	00 8b 45 e4          	add    %cl,-0x1bbb(%bp,%di)
  101cdb:	01 d0                	add    %dx,%ax
  101cdd:	0f b6 00             	movzbw (%bx,%si),%ax
  101ce0:	83 e0 01             	and    $0x1,%ax
  101ce3:	84 c0                	test   %al,%al
  101ce5:	0f 84 0b 01          	je     101df4 <mmu_create_task_pgd+0x14e>
  101ce9:	00 00                	add    %al,(%bx,%si)
            pde_dest[i].v = pde_src[i].v;
  101ceb:	8b 45 f4             	mov    -0xc(%di),%ax
  101cee:	8d 14                	lea    (%si),%dx
  101cf0:	85 00                	test   %ax,(%bx,%si)
  101cf2:	00 00                	add    %al,(%bx,%si)
  101cf4:	00 8b 45 e4          	add    %cl,-0x1bbb(%bp,%di)
  101cf8:	01 d0                	add    %dx,%ax
  101cfa:	8b 55 f4             	mov    -0xc(%di),%dx
  101cfd:	8d 0c                	lea    (%si),%cx
  101cff:	95                   	xchg   %ax,%bp
  101d00:	00 00                	add    %al,(%bx,%si)
  101d02:	00 00                	add    %al,(%bx,%si)
  101d04:	8b 55 e8             	mov    -0x18(%di),%dx
  101d07:	01 ca                	add    %cx,%dx
  101d09:	8b 00                	mov    (%bx,%si),%ax
  101d0b:	89 02                	mov    %ax,(%bp,%si)
            ph_addr_t page_table = mm_alloc_one_page();
  101d0d:	e8 85 05             	call   102295 <mm_free_pages+0x133>
  101d10:	00 00                	add    %al,(%bx,%si)
  101d12:	89 45 e0             	mov    %ax,-0x20(%di)
            pde_dest[i].phy_pt_addr = page_table >> 12;
  101d15:	8b 45 e0             	mov    -0x20(%di),%ax
  101d18:	c1 e8 0c             	shr    $0xc,%ax
  101d1b:	89 c2                	mov    %ax,%dx
  101d1d:	8b 45 f4             	mov    -0xc(%di),%ax
  101d20:	8d 0c                	lea    (%si),%cx
  101d22:	85 00                	test   %ax,(%bx,%si)
  101d24:	00 00                	add    %al,(%bx,%si)
  101d26:	00 8b 45 e8          	add    %cl,-0x17bb(%bp,%di)
  101d2a:	01 c8                	add    %cx,%ax
  101d2c:	81 e2 ff ff          	and    $0xffff,%dx
  101d30:	0f 00 89 d1 83       	str    -0x7c2f(%bx,%di)
  101d35:	e1 0f                	loope  101d46 <mmu_create_task_pgd+0xa0>
  101d37:	89 cb                	mov    %cx,%bx
  101d39:	c1 e3 04             	shl    $0x4,%bx
  101d3c:	0f b6 48 01          	movzbw 0x1(%bx,%si),%cx
  101d40:	83 e1 0f             	and    $0xf,%cx
  101d43:	09 d9                	or     %bx,%cx
  101d45:	88 48 01             	mov    %cl,0x1(%bx,%si)
  101d48:	89 d1                	mov    %dx,%cx
  101d4a:	c1 e9 04             	shr    $0x4,%cx
  101d4d:	0f b6 d9             	movzbw %cl,%bx
  101d50:	0f b6 48 02          	movzbw 0x2(%bx,%si),%cx
  101d54:	83 e1 00             	and    $0x0,%cx
  101d57:	09 d9                	or     %bx,%cx
  101d59:	88 48 02             	mov    %cl,0x2(%bx,%si)
  101d5c:	c1 ea 0c             	shr    $0xc,%dx
  101d5f:	0f b6 ca             	movzbw %dl,%cx
  101d62:	0f b6 50 03          	movzbw 0x3(%bx,%si),%dx
  101d66:	83 e2 00             	and    $0x0,%dx
  101d69:	09 ca                	or     %cx,%dx
  101d6b:	88 50 03             	mov    %dl,0x3(%bx,%si)

            pte_t* pte_dest = (pte_t*)page_table;
  101d6e:	8b 45 e0             	mov    -0x20(%di),%ax
  101d71:	89 45 dc             	mov    %ax,-0x24(%di)
            pte_t* pte_src = (pte_t*)(pde_src[i].phy_pt_addr << 12);
  101d74:	8b 45 f4             	mov    -0xc(%di),%ax
  101d77:	8d 14                	lea    (%si),%dx
  101d79:	85 00                	test   %ax,(%bx,%si)
  101d7b:	00 00                	add    %al,(%bx,%si)
  101d7d:	00 8b 45 e4          	add    %cl,-0x1bbb(%bp,%di)
  101d81:	01 d0                	add    %dx,%ax
  101d83:	0f b6 50 01          	movzbw 0x1(%bx,%si),%dx
  101d87:	c0 ea 04             	shr    $0x4,%dl
  101d8a:	0f b6 ca             	movzbw %dl,%cx
  101d8d:	0f b6 50 02          	movzbw 0x2(%bx,%si),%dx
  101d91:	c1 e2 04             	shl    $0x4,%dx
  101d94:	09 ca                	or     %cx,%dx
  101d96:	0f b6 40 03          	movzbw 0x3(%bx,%si),%ax
  101d9a:	c1 e0 0c             	shl    $0xc,%ax
  101d9d:	09 d0                	or     %dx,%ax
  101d9f:	c1 e0 0c             	shl    $0xc,%ax
  101da2:	89 45 d8             	mov    %ax,-0x28(%di)
            for(int i = 0;i<1024;++i)
  101da5:	c7 45 f0 00 00       	movw   $0x0,-0x10(%di)
  101daa:	00 00                	add    %al,(%bx,%si)
  101dac:	eb 3f                	jmp    101ded <mmu_create_task_pgd+0x147>
            {
                if(pte_src[i].present)
  101dae:	8b 45 f0             	mov    -0x10(%di),%ax
  101db1:	8d 14                	lea    (%si),%dx
  101db3:	85 00                	test   %ax,(%bx,%si)
  101db5:	00 00                	add    %al,(%bx,%si)
  101db7:	00 8b 45 d8          	add    %cl,-0x27bb(%bp,%di)
  101dbb:	01 d0                	add    %dx,%ax
  101dbd:	0f b6 00             	movzbw (%bx,%si),%ax
  101dc0:	83 e0 01             	and    $0x1,%ax
  101dc3:	84 c0                	test   %al,%al
  101dc5:	74 22                	je     101de9 <mmu_create_task_pgd+0x143>
                {
                    pte_dest[i].v = pte_src[i].v;
  101dc7:	8b 45 f0             	mov    -0x10(%di),%ax
  101dca:	8d 14                	lea    (%si),%dx
  101dcc:	85 00                	test   %ax,(%bx,%si)
  101dce:	00 00                	add    %al,(%bx,%si)
  101dd0:	00 8b 45 d8          	add    %cl,-0x27bb(%bp,%di)
  101dd4:	01 d0                	add    %dx,%ax
  101dd6:	8b 55 f0             	mov    -0x10(%di),%dx
  101dd9:	8d 0c                	lea    (%si),%cx
  101ddb:	95                   	xchg   %ax,%bp
  101ddc:	00 00                	add    %al,(%bx,%si)
  101dde:	00 00                	add    %al,(%bx,%si)
  101de0:	8b 55 dc             	mov    -0x24(%di),%dx
  101de3:	01 ca                	add    %cx,%dx
  101de5:	8b 00                	mov    (%bx,%si),%ax
  101de7:	89 02                	mov    %ax,(%bp,%si)
            for(int i = 0;i<1024;++i)
  101de9:	83 45 f0 01          	addw   $0x1,-0x10(%di)
  101ded:	81 7d f0 ff 03       	cmpw   $0x3ff,-0x10(%di)
  101df2:	00 00                	add    %al,(%bx,%si)
  101df4:	7e b8                	jle    101dae <mmu_create_task_pgd+0x108>
    for (int i = 0; i < 1024; i++)
  101df6:	83 45 f4 01          	addw   $0x1,-0xc(%di)
  101dfa:	81 7d f4 ff 03       	cmpw   $0x3ff,-0xc(%di)
  101dff:	00 00                	add    %al,(%bx,%si)
  101e01:	0f 8e c7 fe          	jle    101ccc <mmu_create_task_pgd+0x26>
  101e05:	ff                   	(bad)  
  101e06:	ff 8b 45 ec          	decw   -0x13bb(%bp,%di)
                }
            }
        }
    }
    return page_dir;
}
  101e0a:	8b 5d fc             	mov    -0x4(%di),%bx
  101e0d:	c9                   	leave  
  101e0e:	c3                   	ret    

00101e0f <mmu_test>:

void mmu_test(void)
{
  101e0f:	55                   	push   %bp
  101e10:	89 e5                	mov    %sp,%bp
  101e12:	83 ec 18             	sub    $0x18,%sp
    // 测试虚拟地址和物理地址
    ph_addr_t vm1 = 0xFFFCC000; // 虚拟地址
  101e15:	c7 45 f4 00 c0       	movw   $0xc000,-0xc(%di)
  101e1a:	fc                   	cld    
  101e1b:	ff c7                	inc    %di
    ph_addr_t phm1 = 0x200000;  // 物理地址
  101e1d:	45                   	inc    %bp
  101e1e:	f0 00 00             	lock add %al,(%bx,%si)
  101e21:	20 00                	and    %al,(%bx,%si)

    // 建立映射
    int result = mmu_memory_map(vm1, phm1, 1, 0); // 可写，用户模式访问
  101e23:	6a 00                	push   $0x0
  101e25:	6a 01                	push   $0x1
  101e27:	ff 75 f0             	push   -0x10(%di)
  101e2a:	ff 75 f4             	push   -0xc(%di)
  101e2d:	e8 a3 fb             	call   1019d3 <kernel_pgd_create+0xc7>
  101e30:	ff                   	(bad)  
  101e31:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
  101e35:	89 45 ec             	mov    %ax,-0x14(%di)
    if (result == 1) {
  101e38:	83 7d ec 01          	cmpw   $0x1,-0x14(%di)
  101e3c:	75 29                	jne    101e67 <mmu_test+0x58>
        dbg_info("Mapping successful: VM 0x%x -> PM 0x%x\r\n", vm1, phm1);
  101e3e:	83 ec 04             	sub    $0x4,%sp
  101e41:	ff 75 f0             	push   -0x10(%di)
  101e44:	ff 75 f4             	push   -0xc(%di)
  101e47:	68 f4 47             	push   $0x47f4
  101e4a:	10 00                	adc    %al,(%bx,%si)
  101e4c:	68 9b 00             	push   $0x9b
  101e4f:	00 00                	add    %al,(%bx,%si)
  101e51:	68 4c 49             	push   $0x494c
  101e54:	10 00                	adc    %al,(%bx,%si)
  101e56:	68 45 47             	push   $0x4745
  101e59:	10 00                	adc    %al,(%bx,%si)
  101e5b:	6a 03                	push   $0x3
  101e5d:	e8 22 09             	call   102782 <hlt+0x5>
  101e60:	00 00                	add    %al,(%bx,%si)
  101e62:	83 c4 20             	add    $0x20,%sp
  101e65:	eb 27                	jmp    101e8e <mmu_test+0x7f>
    } else {
        dbg_info("Mapping failed for VM 0x%x -> PM 0x%x\r\n", vm1, phm1);
  101e67:	83 ec 04             	sub    $0x4,%sp
  101e6a:	ff 75 f0             	push   -0x10(%di)
  101e6d:	ff 75 f4             	push   -0xc(%di)
  101e70:	68 20 48             	push   $0x4820
  101e73:	10 00                	adc    %al,(%bx,%si)
  101e75:	68 9d 00             	push   $0x9d
  101e78:	00 00                	add    %al,(%bx,%si)
  101e7a:	68 4c 49             	push   $0x494c
  101e7d:	10 00                	adc    %al,(%bx,%si)
  101e7f:	68 45 47             	push   $0x4745
  101e82:	10 00                	adc    %al,(%bx,%si)
  101e84:	6a 03                	push   $0x3
  101e86:	e8 f9 08             	call   102782 <hlt+0x5>
  101e89:	00 00                	add    %al,(%bx,%si)
  101e8b:	83 c4 20             	add    $0x20,%sp
    }

    // 获取物理地址
    ph_addr_t phm1_test = mmu_get_phaddr(vm1);
  101e8e:	83 ec 0c             	sub    $0xc,%sp
  101e91:	ff 75 f4             	push   -0xc(%di)
  101e94:	e8 00 fd             	call   101b97 <mmu_memory_map+0x1c2>
  101e97:	ff                   	(bad)  
  101e98:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
  101e9c:	89 45 e8             	mov    %ax,-0x18(%di)
    if (phm1_test == -1) {
  101e9f:	83 7d e8 ff          	cmpw   $0xffff,-0x18(%di)
  101ea3:	75 26                	jne    101ecb <mmu_test+0xbc>
        dbg_info("Failed to get physical address for VM 0x%x\r\n", vm1);
  101ea5:	83 ec 08             	sub    $0x8,%sp
  101ea8:	ff 75 f4             	push   -0xc(%di)
  101eab:	68 48 48             	push   $0x4848
  101eae:	10 00                	adc    %al,(%bx,%si)
  101eb0:	68 a3 00             	push   $0xa3
  101eb3:	00 00                	add    %al,(%bx,%si)
  101eb5:	68 4c 49             	push   $0x494c
  101eb8:	10 00                	adc    %al,(%bx,%si)
  101eba:	68 45 47             	push   $0x4745
  101ebd:	10 00                	adc    %al,(%bx,%si)
  101ebf:	6a 03                	push   $0x3
  101ec1:	e8 be 08             	call   102782 <hlt+0x5>
  101ec4:	00 00                	add    %al,(%bx,%si)
  101ec6:	83 c4 20             	add    $0x20,%sp
  101ec9:	eb 27                	jmp    101ef2 <mmu_test+0xe3>
    } else {
        dbg_info("Physical address for VM 0x%x: PM 0x%x\r\n", vm1, phm1_test);
  101ecb:	83 ec 04             	sub    $0x4,%sp
  101ece:	ff 75 e8             	push   -0x18(%di)
  101ed1:	ff 75 f4             	push   -0xc(%di)
  101ed4:	68 78 48             	push   $0x4878
  101ed7:	10 00                	adc    %al,(%bx,%si)
  101ed9:	68 a5 00             	push   $0xa5
  101edc:	00 00                	add    %al,(%bx,%si)
  101ede:	68 4c 49             	push   $0x494c
  101ee1:	10 00                	adc    %al,(%bx,%si)
  101ee3:	68 45 47             	push   $0x4745
  101ee6:	10 00                	adc    %al,(%bx,%si)
  101ee8:	6a 03                	push   $0x3
  101eea:	e8 95 08             	call   102782 <hlt+0x5>
  101eed:	00 00                	add    %al,(%bx,%si)
  101eef:	83 c4 20             	add    $0x20,%sp
    }

    // 验证映射是否正确
    if (phm1_test == phm1) {
  101ef2:	8b 45 e8             	mov    -0x18(%di),%ax
  101ef5:	3b 45 f0             	cmp    -0x10(%di),%ax
  101ef8:	75 29                	jne    101f23 <mmu_test+0x114>
        dbg_info("Mapping verification successful: VM 0x%x -> PM 0x%x\r\n", vm1, phm1);
  101efa:	83 ec 04             	sub    $0x4,%sp
  101efd:	ff 75 f0             	push   -0x10(%di)
  101f00:	ff 75 f4             	push   -0xc(%di)
  101f03:	68 a0 48             	push   $0x48a0
  101f06:	10 00                	adc    %al,(%bx,%si)
  101f08:	68 aa 00             	push   $0xaa
  101f0b:	00 00                	add    %al,(%bx,%si)
  101f0d:	68 4c 49             	push   $0x494c
  101f10:	10 00                	adc    %al,(%bx,%si)
  101f12:	68 45 47             	push   $0x4745
  101f15:	10 00                	adc    %al,(%bx,%si)
  101f17:	6a 03                	push   $0x3
  101f19:	e8 66 08             	call   102782 <hlt+0x5>
  101f1c:	00 00                	add    %al,(%bx,%si)
  101f1e:	83 c4 20             	add    $0x20,%sp
    } else {
        dbg_info("Mapping verification failed: Expected PM 0x%x, Got PM 0x%x\r\n", phm1, phm1_test);
    }
  101f21:	eb 27                	jmp    101f4a <mmu_test+0x13b>
        dbg_info("Mapping verification failed: Expected PM 0x%x, Got PM 0x%x\r\n", phm1, phm1_test);
  101f23:	83 ec 04             	sub    $0x4,%sp
  101f26:	ff 75 e8             	push   -0x18(%di)
  101f29:	ff 75 f0             	push   -0x10(%di)
  101f2c:	68 d8 48             	push   $0x48d8
  101f2f:	10 00                	adc    %al,(%bx,%si)
  101f31:	68 ac 00             	push   $0xac
  101f34:	00 00                	add    %al,(%bx,%si)
  101f36:	68 4c 49             	push   $0x494c
  101f39:	10 00                	adc    %al,(%bx,%si)
  101f3b:	68 45 47             	push   $0x4745
  101f3e:	10 00                	adc    %al,(%bx,%si)
  101f40:	6a 03                	push   $0x3
  101f42:	e8 3d 08             	call   102782 <hlt+0x5>
  101f45:	00 00                	add    %al,(%bx,%si)
  101f47:	83 c4 20             	add    $0x20,%sp
  101f4a:	90                   	nop
  101f4b:	c9                   	leave  
  101f4c:	c3                   	ret    

00101f4d <get_region_from>:
static memblock_region_t mm_regions[MEM_MMREGION_MAX_CNT] = {0};
static memblock_region_t rv_regions[MEM_RVREGION_MAX_CNT] = {0};
static memblock_t memblock;

static memblock_region_t* get_region_from(memblock_type_t* mm)
{
  101f4d:	55                   	push   %bp
  101f4e:	89 e5                	mov    %sp,%bp
  101f50:	83 ec 10             	sub    $0x10,%sp
    for (int i = 0; i < mm->max; i++)
  101f53:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
  101f58:	00 00                	add    %al,(%bx,%si)
  101f5a:	eb 35                	jmp    101f91 <get_region_from+0x44>
    {
        if (mm->regions[i].flag == NONE) {
  101f5c:	8b 45 08             	mov    0x8(%di),%ax
  101f5f:	8b 48 08             	mov    0x8(%bx,%si),%cx
  101f62:	8b 55 fc             	mov    -0x4(%di),%dx
  101f65:	89 d0                	mov    %dx,%ax
  101f67:	01 c0                	add    %ax,%ax
  101f69:	01 d0                	add    %dx,%ax
  101f6b:	c1 e0 02             	shl    $0x2,%ax
  101f6e:	01 c8                	add    %cx,%ax
  101f70:	8b 40 08             	mov    0x8(%bx,%si),%ax
  101f73:	85 c0                	test   %ax,%ax
  101f75:	75 16                	jne    101f8d <get_region_from+0x40>
            return &mm->regions[i];
  101f77:	8b 45 08             	mov    0x8(%di),%ax
  101f7a:	8b 48 08             	mov    0x8(%bx,%si),%cx
  101f7d:	8b 55 fc             	mov    -0x4(%di),%dx
  101f80:	89 d0                	mov    %dx,%ax
  101f82:	01 c0                	add    %ax,%ax
  101f84:	01 d0                	add    %dx,%ax
  101f86:	c1 e0 02             	shl    $0x2,%ax
  101f89:	01 c8                	add    %cx,%ax
  101f8b:	eb 16                	jmp    101fa3 <get_region_from+0x56>
    for (int i = 0; i < mm->max; i++)
  101f8d:	83 45 fc 01          	addw   $0x1,-0x4(%di)
  101f91:	8b 45 08             	mov    0x8(%di),%ax
  101f94:	8b 50 04             	mov    0x4(%bx,%si),%dx
  101f97:	8b 45 fc             	mov    -0x4(%di),%ax
  101f9a:	39 c2                	cmp    %ax,%dx
  101f9c:	77 be                	ja     101f5c <get_region_from+0xf>
        }
    }
    return NULL;
  101f9e:	b8 00 00             	mov    $0x0,%ax
  101fa1:	00 00                	add    %al,(%bx,%si)
}
  101fa3:	c9                   	leave  
  101fa4:	c3                   	ret    

00101fa5 <free_region_in>:

static int free_region_in(memblock_region_t* region, memblock_type_t* mm)
{
  101fa5:	55                   	push   %bp
  101fa6:	89 e5                	mov    %sp,%bp
  101fa8:	83 ec 10             	sub    $0x10,%sp
    memblock_region_t* start = mm->regions;
  101fab:	8b 45 0c             	mov    0xc(%di),%ax
  101fae:	8b 40 08             	mov    0x8(%bx,%si),%ax
  101fb1:	89 45 fc             	mov    %ax,-0x4(%di)
    for (int i = 0; i < mm->max; i++, start++)
  101fb4:	c7 45 f8 00 00       	movw   $0x0,-0x8(%di)
  101fb9:	00 00                	add    %al,(%bx,%si)
  101fbb:	eb 21                	jmp    101fde <free_region_in+0x39>
    {
        if (start == region) {
  101fbd:	8b 45 fc             	mov    -0x4(%di),%ax
  101fc0:	3b 45 08             	cmp    0x8(%di),%ax
  101fc3:	75 11                	jne    101fd6 <free_region_in+0x31>
            start->flag = NONE;
  101fc5:	8b 45 fc             	mov    -0x4(%di),%ax
  101fc8:	c7 40 08 00 00       	movw   $0x0,0x8(%bx,%si)
  101fcd:	00 00                	add    %al,(%bx,%si)
            return 0;
  101fcf:	b8 00 00             	mov    $0x0,%ax
  101fd2:	00 00                	add    %al,(%bx,%si)
  101fd4:	eb 1a                	jmp    101ff0 <free_region_in+0x4b>
    for (int i = 0; i < mm->max; i++, start++)
  101fd6:	83 45 f8 01          	addw   $0x1,-0x8(%di)
  101fda:	83 45 fc 0c          	addw   $0xc,-0x4(%di)
  101fde:	8b 45 0c             	mov    0xc(%di),%ax
  101fe1:	8b 50 04             	mov    0x4(%bx,%si),%dx
  101fe4:	8b 45 f8             	mov    -0x8(%di),%ax
  101fe7:	39 c2                	cmp    %ax,%dx
  101fe9:	77 d2                	ja     101fbd <free_region_in+0x18>
        }
    }
    return -1;
  101feb:	b8 ff ff             	mov    $0xffff,%ax
  101fee:	ff                   	(bad)  
  101fef:	ff c9                	dec    %cx
}
  101ff1:	c3                   	ret    

00101ff2 <mm_alloc_pages>:

ph_addr_t mm_alloc_pages(uint32_t n) {
  101ff2:	55                   	push   %bp
  101ff3:	89 e5                	mov    %sp,%bp
  101ff5:	83 ec 28             	sub    $0x28,%sp
    ph_addr_t ret = -1;
  101ff8:	c7 45 f4 ff ff       	movw   $0xffff,-0xc(%di)
  101ffd:	ff                   	(bad)  
  101ffe:	ff c7                	inc    %di
    memblock_region_t* region = NULL;
  102000:	45                   	inc    %bp
  102001:	e4 00                	in     $0x0,%al
  102003:	00 00                	add    %al,(%bx,%si)
  102005:	00 c7                	add    %al,%bh
    memblock_region_t* best_fit = NULL;
  102007:	45                   	inc    %bp
  102008:	f0 00 00             	lock add %al,(%bx,%si)
  10200b:	00 00                	add    %al,(%bx,%si)
    uint32_t best_fit_size = UINT32_MAX;
  10200d:	c7 45 ec ff ff       	movw   $0xffff,-0x14(%di)
  102012:	ff                   	(bad)  
  102013:	ff c7                	inc    %di

    for (int i = 0; i < MEM_MMREGION_MAX_CNT; i++) {
  102015:	45                   	inc    %bp
  102016:	e8 00 00             	call   102019 <mm_alloc_pages+0x27>
  102019:	00 00                	add    %al,(%bx,%si)
  10201b:	eb 6a                	jmp    102087 <mm_alloc_pages+0x95>
        if (mm_regions[i].flag == MEMORY) {
  10201d:	8b 55 e8             	mov    -0x18(%di),%dx
  102020:	89 d0                	mov    %dx,%ax
  102022:	01 c0                	add    %ax,%ax
  102024:	01 d0                	add    %dx,%ax
  102026:	c1 e0 02             	shl    $0x2,%ax
  102029:	05 08 00             	add    $0x8,%ax
  10202c:	13 00                	adc    (%bx,%si),%ax
  10202e:	8b 00                	mov    (%bx,%si),%ax
  102030:	83 f8 01             	cmp    $0x1,%ax
  102033:	75 4e                	jne    102083 <mm_alloc_pages+0x91>
            uint32_t region_size = mm_regions[i].size;
  102035:	8b 55 e8             	mov    -0x18(%di),%dx
  102038:	89 d0                	mov    %dx,%ax
  10203a:	01 c0                	add    %ax,%ax
  10203c:	01 d0                	add    %dx,%ax
  10203e:	c1 e0 02             	shl    $0x2,%ax
  102041:	05 04 00             	add    $0x4,%ax
  102044:	13 00                	adc    (%bx,%si),%ax
  102046:	8b 00                	mov    (%bx,%si),%ax
  102048:	89 45 e0             	mov    %ax,-0x20(%di)

            if (region_size >= n * MEM_PAGE_SIZE && region_size < best_fit_size) {
  10204b:	8b 45 08             	mov    0x8(%di),%ax
  10204e:	c1 e0 0c             	shl    $0xc,%ax
  102051:	39 45 e0             	cmp    %ax,-0x20(%di)
  102054:	72 2d                	jb     102083 <mm_alloc_pages+0x91>
  102056:	8b 45 e0             	mov    -0x20(%di),%ax
  102059:	3b 45 ec             	cmp    -0x14(%di),%ax
  10205c:	73 25                	jae    102083 <mm_alloc_pages+0x91>
                best_fit = &mm_regions[i];
  10205e:	8b 55 e8             	mov    -0x18(%di),%dx
  102061:	89 d0                	mov    %dx,%ax
  102063:	01 c0                	add    %ax,%ax
  102065:	01 d0                	add    %dx,%ax
  102067:	c1 e0 02             	shl    $0x2,%ax
  10206a:	05 00 00             	add    $0x0,%ax
  10206d:	13 00                	adc    (%bx,%si),%ax
  10206f:	89 45 f0             	mov    %ax,-0x10(%di)
                best_fit_size = region_size;
  102072:	8b 45 e0             	mov    -0x20(%di),%ax
  102075:	89 45 ec             	mov    %ax,-0x14(%di)

                if (region_size == n * MEM_PAGE_SIZE) {
  102078:	8b 45 08             	mov    0x8(%di),%ax
  10207b:	c1 e0 0c             	shl    $0xc,%ax
  10207e:	39 45 e0             	cmp    %ax,-0x20(%di)
  102081:	74 0f                	je     102092 <mm_alloc_pages+0xa0>
    for (int i = 0; i < MEM_MMREGION_MAX_CNT; i++) {
  102083:	83 45 e8 01          	addw   $0x1,-0x18(%di)
  102087:	81 7d e8 ff 03       	cmpw   $0x3ff,-0x18(%di)
  10208c:	00 00                	add    %al,(%bx,%si)
  10208e:	7e 8d                	jle    10201d <mm_alloc_pages+0x2b>
  102090:	eb 01                	jmp    102093 <mm_alloc_pages+0xa1>
                    break;
  102092:	90                   	nop
                }
            }
        }
    }

    if (best_fit != NULL) {
  102093:	83 7d f0 00          	cmpw   $0x0,-0x10(%di)
  102097:	0f 84 c0 00          	je     10215b <mm_alloc_pages+0x169>
  10209b:	00 00                	add    %al,(%bx,%si)
        ret = best_fit->base;
  10209d:	8b 45 f0             	mov    -0x10(%di),%ax
  1020a0:	8b 00                	mov    (%bx,%si),%ax
  1020a2:	89 45 f4             	mov    %ax,-0xc(%di)

        if (best_fit_size > n * MEM_PAGE_SIZE) {
  1020a5:	8b 45 08             	mov    0x8(%di),%ax
  1020a8:	c1 e0 0c             	shl    $0xc,%ax
  1020ab:	39 45 ec             	cmp    %ax,-0x14(%di)
  1020ae:	76 2c                	jbe    1020dc <mm_alloc_pages+0xea>
            best_fit->base += n * MEM_PAGE_SIZE;
  1020b0:	8b 45 f0             	mov    -0x10(%di),%ax
  1020b3:	8b 10                	mov    (%bx,%si),%dx
  1020b5:	8b 45 08             	mov    0x8(%di),%ax
  1020b8:	c1 e0 0c             	shl    $0xc,%ax
  1020bb:	01 c2                	add    %ax,%dx
  1020bd:	8b 45 f0             	mov    -0x10(%di),%ax
  1020c0:	89 10                	mov    %dx,(%bx,%si)
            best_fit->size -= n * MEM_PAGE_SIZE;
  1020c2:	8b 45 f0             	mov    -0x10(%di),%ax
  1020c5:	8b 40 04             	mov    0x4(%bx,%si),%ax
  1020c8:	8b 55 08             	mov    0x8(%di),%dx
  1020cb:	89 d1                	mov    %dx,%cx
  1020cd:	c1 e1 0c             	shl    $0xc,%cx
  1020d0:	29 c8                	sub    %cx,%ax
  1020d2:	89 c2                	mov    %ax,%dx
  1020d4:	8b 45 f0             	mov    -0x10(%di),%ax
  1020d7:	89 50 04             	mov    %dx,0x4(%bx,%si)
  1020da:	eb 17                	jmp    1020f3 <mm_alloc_pages+0x101>
        } else {
            best_fit->flag = NONE;
  1020dc:	8b 45 f0             	mov    -0x10(%di),%ax
  1020df:	c7 40 08 00 00       	movw   $0x0,0x8(%bx,%si)
  1020e4:	00 00                	add    %al,(%bx,%si)
            memblock.memory.cnt--;
  1020e6:	a1 00 60             	mov    0x6000,%ax
  1020e9:	13 00                	adc    (%bx,%si),%ax
  1020eb:	83 e8 01             	sub    $0x1,%ax
  1020ee:	a3 00 60             	mov    %ax,0x6000
  1020f1:	13 00                	adc    (%bx,%si),%ax
        }

        region = get_region_from(&memblock.reserved);
  1020f3:	68 0c 60             	push   $0x600c
  1020f6:	13 00                	adc    (%bx,%si),%ax
  1020f8:	e8 50 fe             	call   101f4b <mmu_test+0x13c>
  1020fb:	ff                   	(bad)  
  1020fc:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  102100:	89 45 e4             	mov    %ax,-0x1c(%di)
        if (region != NULL) {
  102103:	83 7d e4 00          	cmpw   $0x0,-0x1c(%di)
  102107:	74 2f                	je     102138 <mm_alloc_pages+0x146>
            memblock.reserved.cnt++;
  102109:	a1 0c 60             	mov    0x600c,%ax
  10210c:	13 00                	adc    (%bx,%si),%ax
  10210e:	83 c0 01             	add    $0x1,%ax
  102111:	a3 0c 60             	mov    %ax,0x600c
  102114:	13 00                	adc    (%bx,%si),%ax
            region->flag = RESERVED;
  102116:	8b 45 e4             	mov    -0x1c(%di),%ax
  102119:	c7 40 08 02 00       	movw   $0x2,0x8(%bx,%si)
  10211e:	00 00                	add    %al,(%bx,%si)
            region->base = ret;
  102120:	8b 45 e4             	mov    -0x1c(%di),%ax
  102123:	8b 55 f4             	mov    -0xc(%di),%dx
  102126:	89 10                	mov    %dx,(%bx,%si)
            region->size = n * MEM_PAGE_SIZE;
  102128:	8b 45 08             	mov    0x8(%di),%ax
  10212b:	c1 e0 0c             	shl    $0xc,%ax
  10212e:	89 c2                	mov    %ax,%dx
  102130:	8b 45 e4             	mov    -0x1c(%di),%ax
  102133:	89 50 04             	mov    %dx,0x4(%bx,%si)
  102136:	eb 25                	jmp    10215d <mm_alloc_pages+0x16b>
        } else {
            // 处理错误，避免空指针访问
            dbg_warning("内存不足，无法在 reserved 中记录分配信息\n");
  102138:	83 ec 0c             	sub    $0xc,%sp
  10213b:	68 58 49             	push   $0x4958
  10213e:	10 00                	adc    %al,(%bx,%si)
  102140:	6a 49                	push   $0x49
  102142:	68 0c 4a             	push   $0x4a0c
  102145:	10 00                	adc    %al,(%bx,%si)
  102147:	68 91 49             	push   $0x4991
  10214a:	10 00                	adc    %al,(%bx,%si)
  10214c:	6a 02                	push   $0x2
  10214e:	e8 31 06             	call   102782 <hlt+0x5>
  102151:	00 00                	add    %al,(%bx,%si)
  102153:	83 c4 20             	add    $0x20,%sp
            return -1;
  102156:	b8 ff ff             	mov    $0xffff,%ax
  102159:	ff                   	(bad)  
  10215a:	ff                   	(bad)  
  10215b:	eb 03                	jmp    102160 <mm_alloc_pages+0x16e>
        }
    }

    return ret;
  10215d:	8b 45 f4             	mov    -0xc(%di),%ax
}
  102160:	c9                   	leave  
  102161:	c3                   	ret    

00102162 <mm_free_pages>:

int mm_free_pages(ph_addr_t addr, uint32_t n)
{
  102162:	55                   	push   %bp
  102163:	89 e5                	mov    %sp,%bp
  102165:	83 ec 18             	sub    $0x18,%sp
    memblock_region_t* region;
    for (int i = 0; i < MEM_RVREGION_MAX_CNT; i++) {
  102168:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
  10216d:	00 00                	add    %al,(%bx,%si)
  10216f:	e9 0f 01             	jmp    102281 <mm_free_pages+0x11f>
  102172:	00 00                	add    %al,(%bx,%si)
        if (rv_regions[i].flag == RESERVED) {
  102174:	8b 55 f4             	mov    -0xc(%di),%dx
  102177:	89 d0                	mov    %dx,%ax
  102179:	01 c0                	add    %ax,%ax
  10217b:	01 d0                	add    %dx,%ax
  10217d:	c1 e0 02             	shl    $0x2,%ax
  102180:	05 08 30             	add    $0x3008,%ax
  102183:	13 00                	adc    (%bx,%si),%ax
  102185:	8b 00                	mov    (%bx,%si),%ax
  102187:	83 f8 02             	cmp    $0x2,%ax
  10218a:	0f 85 ef 00          	jne    10227d <mm_free_pages+0x11b>
  10218e:	00 00                	add    %al,(%bx,%si)
            if (rv_regions[i].base == addr) {
  102190:	8b 55 f4             	mov    -0xc(%di),%dx
  102193:	89 d0                	mov    %dx,%ax
  102195:	01 c0                	add    %ax,%ax
  102197:	01 d0                	add    %dx,%ax
  102199:	c1 e0 02             	shl    $0x2,%ax
  10219c:	05 00 30             	add    $0x3000,%ax
  10219f:	13 00                	adc    (%bx,%si),%ax
  1021a1:	8b 00                	mov    (%bx,%si),%ax
  1021a3:	39 45 08             	cmp    %ax,0x8(%di)
  1021a6:	0f 85 d3 00          	jne    10227d <mm_free_pages+0x11b>
  1021aa:	00 00                	add    %al,(%bx,%si)
                if (n * MEM_PAGE_SIZE != rv_regions[i].size) {
  1021ac:	8b 45 0c             	mov    0xc(%di),%ax
  1021af:	c1 e0 0c             	shl    $0xc,%ax
  1021b2:	89 c1                	mov    %ax,%cx
  1021b4:	8b 55 f4             	mov    -0xc(%di),%dx
  1021b7:	89 d0                	mov    %dx,%ax
  1021b9:	01 c0                	add    %ax,%ax
  1021bb:	01 d0                	add    %dx,%ax
  1021bd:	c1 e0 02             	shl    $0x2,%ax
  1021c0:	05 04 30             	add    $0x3004,%ax
  1021c3:	13 00                	adc    (%bx,%si),%ax
  1021c5:	8b 00                	mov    (%bx,%si),%ax
  1021c7:	39 c1                	cmp    %ax,%cx
  1021c9:	74 1e                	je     1021e9 <mm_free_pages+0x87>
                    dbg_warning("分配和释放的内存不匹配\n");
  1021cb:	83 ec 0c             	sub    $0xc,%sp
  1021ce:	68 a0 49             	push   $0x49a0
  1021d1:	10 00                	adc    %al,(%bx,%si)
  1021d3:	6a 58                	push   $0x58
  1021d5:	68 1c 4a             	push   $0x4a1c
  1021d8:	10 00                	adc    %al,(%bx,%si)
  1021da:	68 91 49             	push   $0x4991
  1021dd:	10 00                	adc    %al,(%bx,%si)
  1021df:	6a 02                	push   $0x2
  1021e1:	e8 9e 05             	call   102782 <hlt+0x5>
  1021e4:	00 00                	add    %al,(%bx,%si)
  1021e6:	83 c4 20             	add    $0x20,%sp
                }
                rv_regions[i].flag = NONE;
  1021e9:	8b 55 f4             	mov    -0xc(%di),%dx
  1021ec:	89 d0                	mov    %dx,%ax
  1021ee:	01 c0                	add    %ax,%ax
  1021f0:	01 d0                	add    %dx,%ax
  1021f2:	c1 e0 02             	shl    $0x2,%ax
  1021f5:	05 08 30             	add    $0x3008,%ax
  1021f8:	13 00                	adc    (%bx,%si),%ax
  1021fa:	c7 00 00 00          	movw   $0x0,(%bx,%si)
  1021fe:	00 00                	add    %al,(%bx,%si)
                memblock.reserved.cnt--;
  102200:	a1 0c 60             	mov    0x600c,%ax
  102203:	13 00                	adc    (%bx,%si),%ax
  102205:	83 e8 01             	sub    $0x1,%ax
  102208:	a3 0c 60             	mov    %ax,0x600c
  10220b:	13 00                	adc    (%bx,%si),%ax

                region = get_region_from(&memblock.memory);
  10220d:	83 ec 0c             	sub    $0xc,%sp
  102210:	68 00 60             	push   $0x6000
  102213:	13 00                	adc    (%bx,%si),%ax
  102215:	e8 33 fd             	call   101f4b <mmu_test+0x13c>
  102218:	ff                   	(bad)  
  102219:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
  10221d:	89 45 f0             	mov    %ax,-0x10(%di)
                if (region != NULL) {
  102220:	83 7d f0 00          	cmpw   $0x0,-0x10(%di)
  102224:	74 34                	je     10225a <mm_free_pages+0xf8>
                    memblock.memory.cnt++;
  102226:	a1 00 60             	mov    0x6000,%ax
  102229:	13 00                	adc    (%bx,%si),%ax
  10222b:	83 c0 01             	add    $0x1,%ax
  10222e:	a3 00 60             	mov    %ax,0x6000
  102231:	13 00                	adc    (%bx,%si),%ax
                    region->flag = MEMORY;
  102233:	8b 45 f0             	mov    -0x10(%di),%ax
  102236:	c7 40 08 01 00       	movw   $0x1,0x8(%bx,%si)
  10223b:	00 00                	add    %al,(%bx,%si)
                    region->base = addr;
  10223d:	8b 45 f0             	mov    -0x10(%di),%ax
  102240:	8b 55 08             	mov    0x8(%di),%dx
  102243:	89 10                	mov    %dx,(%bx,%si)
                    region->size = n * MEM_PAGE_SIZE;
  102245:	8b 45 0c             	mov    0xc(%di),%ax
  102248:	c1 e0 0c             	shl    $0xc,%ax
  10224b:	89 c2                	mov    %ax,%dx
  10224d:	8b 45 f0             	mov    -0x10(%di),%ax
  102250:	89 50 04             	mov    %dx,0x4(%bx,%si)
                    return 0;
  102253:	b8 00 00             	mov    $0x0,%ax
  102256:	00 00                	add    %al,(%bx,%si)
  102258:	eb 3b                	jmp    102295 <mm_free_pages+0x133>
                } else {
                    dbg_warning("无法在 memory 中记录释放的区域\n");
  10225a:	83 ec 0c             	sub    $0xc,%sp
  10225d:	68 c4 49             	push   $0x49c4
  102260:	10 00                	adc    %al,(%bx,%si)
  102262:	6a 65                	push   $0x65
  102264:	68 1c 4a             	push   $0x4a1c
  102267:	10 00                	adc    %al,(%bx,%si)
  102269:	68 91 49             	push   $0x4991
  10226c:	10 00                	adc    %al,(%bx,%si)
  10226e:	6a 02                	push   $0x2
  102270:	e8 0f 05             	call   102782 <hlt+0x5>
  102273:	00 00                	add    %al,(%bx,%si)
  102275:	83 c4 20             	add    $0x20,%sp
                    return -1;
  102278:	b8 ff ff             	mov    $0xffff,%ax
  10227b:	ff                   	(bad)  
  10227c:	ff                   	(bad)  
  10227d:	eb 16                	jmp    102295 <mm_free_pages+0x133>
    for (int i = 0; i < MEM_RVREGION_MAX_CNT; i++) {
  10227f:	83 45 f4 01          	addw   $0x1,-0xc(%di)
  102283:	81 7d f4 ff 03       	cmpw   $0x3ff,-0xc(%di)
  102288:	00 00                	add    %al,(%bx,%si)
  10228a:	0f 8e e4 fe          	jle    102172 <mm_free_pages+0x10>
  10228e:	ff                   	(bad)  
  10228f:	ff                   	(bad)  
                }
            }
        }
    }
    return -1;
  102290:	b8 ff ff             	mov    $0xffff,%ax
  102293:	ff                   	(bad)  
  102294:	ff c9                	dec    %cx
}
  102296:	c3                   	ret    

00102297 <mm_alloc_one_page>:

ph_addr_t mm_alloc_one_page(void)
{
  102297:	55                   	push   %bp
  102298:	89 e5                	mov    %sp,%bp
  10229a:	83 ec 08             	sub    $0x8,%sp
    return mm_alloc_pages(1);
  10229d:	83 ec 0c             	sub    $0xc,%sp
  1022a0:	6a 01                	push   $0x1
  1022a2:	e8 4b fd             	call   101ff0 <free_region_in+0x4b>
  1022a5:	ff                   	(bad)  
  1022a6:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  1022aa:	c9                   	leave  
  1022ab:	c3                   	ret    

001022ac <mm_free_one_page>:

int mm_free_one_page(ph_addr_t addr)
{
  1022ac:	55                   	push   %bp
  1022ad:	89 e5                	mov    %sp,%bp
  1022af:	83 ec 08             	sub    $0x8,%sp
    return mm_free_pages(addr,1);
  1022b2:	83 ec 08             	sub    $0x8,%sp
  1022b5:	6a 01                	push   $0x1
  1022b7:	ff 75 08             	push   0x8(%di)
  1022ba:	e8 a3 fe             	call   102160 <mm_alloc_pages+0x16e>
  1022bd:	ff                   	(bad)  
  1022be:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  1022c2:	c9                   	leave  
  1022c3:	c3                   	ret    

001022c4 <memblock_init>:
void memblock_init(void)
{
  1022c4:	55                   	push   %bp
  1022c5:	89 e5                	mov    %sp,%bp
  1022c7:	83 ec 28             	sub    $0x28,%sp
    for (int i = 0; i < MEM_MMREGION_MAX_CNT; i++) {
  1022ca:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
  1022cf:	00 00                	add    %al,(%bx,%si)
  1022d1:	eb 1b                	jmp    1022ee <memblock_init+0x2a>
        mm_regions[i].flag = NONE;
  1022d3:	8b 55 f4             	mov    -0xc(%di),%dx
  1022d6:	89 d0                	mov    %dx,%ax
  1022d8:	01 c0                	add    %ax,%ax
  1022da:	01 d0                	add    %dx,%ax
  1022dc:	c1 e0 02             	shl    $0x2,%ax
  1022df:	05 08 00             	add    $0x8,%ax
  1022e2:	13 00                	adc    (%bx,%si),%ax
  1022e4:	c7 00 00 00          	movw   $0x0,(%bx,%si)
  1022e8:	00 00                	add    %al,(%bx,%si)
    for (int i = 0; i < MEM_MMREGION_MAX_CNT; i++) {
  1022ea:	83 45 f4 01          	addw   $0x1,-0xc(%di)
  1022ee:	81 7d f4 ff 03       	cmpw   $0x3ff,-0xc(%di)
  1022f3:	00 00                	add    %al,(%bx,%si)
  1022f5:	7e dc                	jle    1022d3 <memblock_init+0xf>
    }
    for (int i = 0; i < MEM_RVREGION_MAX_CNT; i++) {
  1022f7:	c7 45 f0 00 00       	movw   $0x0,-0x10(%di)
  1022fc:	00 00                	add    %al,(%bx,%si)
  1022fe:	eb 1b                	jmp    10231b <memblock_init+0x57>
        rv_regions[i].flag = NONE;
  102300:	8b 55 f0             	mov    -0x10(%di),%dx
  102303:	89 d0                	mov    %dx,%ax
  102305:	01 c0                	add    %ax,%ax
  102307:	01 d0                	add    %dx,%ax
  102309:	c1 e0 02             	shl    $0x2,%ax
  10230c:	05 08 30             	add    $0x3008,%ax
  10230f:	13 00                	adc    (%bx,%si),%ax
  102311:	c7 00 00 00          	movw   $0x0,(%bx,%si)
  102315:	00 00                	add    %al,(%bx,%si)
    for (int i = 0; i < MEM_RVREGION_MAX_CNT; i++) {
  102317:	83 45 f0 01          	addw   $0x1,-0x10(%di)
  10231b:	81 7d f0 ff 03       	cmpw   $0x3ff,-0x10(%di)
  102320:	00 00                	add    %al,(%bx,%si)
  102322:	7e dc                	jle    102300 <memblock_init+0x3c>
    }

    memblock.memory.cnt = 1;
  102324:	c7 05 00 60          	movw   $0x6000,(%di)
  102328:	13 00                	adc    (%bx,%si),%ax
  10232a:	01 00                	add    %ax,(%bx,%si)
  10232c:	00 00                	add    %al,(%bx,%si)
    memblock.memory.max = MEM_MMREGION_MAX_CNT;
  10232e:	c7 05 04 60          	movw   $0x6004,(%di)
  102332:	13 00                	adc    (%bx,%si),%ax
  102334:	00 04                	add    %al,(%si)
  102336:	00 00                	add    %al,(%bx,%si)
    memblock.memory.regions = mm_regions;
  102338:	c7 05 08 60          	movw   $0x6008,(%di)
  10233c:	13 00                	adc    (%bx,%si),%ax
  10233e:	00 00                	add    %al,(%bx,%si)
  102340:	13 00                	adc    (%bx,%si),%ax

    memblock.reserved.cnt = 0;
  102342:	c7 05 0c 60          	movw   $0x600c,(%di)
  102346:	13 00                	adc    (%bx,%si),%ax
  102348:	00 00                	add    %al,(%bx,%si)
  10234a:	00 00                	add    %al,(%bx,%si)
    memblock.reserved.max = MEM_RVREGION_MAX_CNT;
  10234c:	c7 05 10 60          	movw   $0x6010,(%di)
  102350:	13 00                	adc    (%bx,%si),%ax
  102352:	00 04                	add    %al,(%si)
  102354:	00 00                	add    %al,(%bx,%si)
    memblock.reserved.regions = rv_regions;
  102356:	c7 05 14 60          	movw   $0x6014,(%di)
  10235a:	13 00                	adc    (%bx,%si),%ax
  10235c:	00 30                	add    %dh,(%bx,%si)
  10235e:	13 00                	adc    (%bx,%si),%ax

    uint32_t mm_start = KERNEL_START_ADDR_REL + KERNEL_SIZE;
  102360:	c7 45 ec 00 00       	movw   $0x0,-0x14(%di)
  102365:	10 02                	adc    %al,(%bp,%si)
    uint32_t mm_end = boot_inform->ram_region_cfg[1].start + boot_inform->ram_region_cfg[1].size - 1;
  102367:	a1 e0 e1             	mov    0xe1e0,%ax
  10236a:	12 00                	adc    (%bx,%si),%al
  10236c:	8b 50 20             	mov    0x20(%bx,%si),%dx
  10236f:	a1 e0 e1             	mov    0xe1e0,%ax
  102372:	12 00                	adc    (%bx,%si),%al
  102374:	8b 40 24             	mov    0x24(%bx,%si),%ax
  102377:	01 d0                	add    %dx,%ax
  102379:	83 e8 01             	sub    $0x1,%ax
  10237c:	89 45 e8             	mov    %ax,-0x18(%di)

    memblock_region_t* region = get_region_from(&memblock.memory);
  10237f:	68 00 60             	push   $0x6000
  102382:	13 00                	adc    (%bx,%si),%ax
  102384:	e8 c4 fb             	call   101f4b <mmu_test+0x13c>
  102387:	ff                   	(bad)  
  102388:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  10238c:	89 45 e4             	mov    %ax,-0x1c(%di)
    if (region != NULL) {
  10238f:	83 7d e4 00          	cmpw   $0x0,-0x1c(%di)
  102393:	74 30                	je     1023c5 <memblock_init+0x101>
        region->flag = MEMORY;
  102395:	8b 45 e4             	mov    -0x1c(%di),%ax
  102398:	c7 40 08 01 00       	movw   $0x1,0x8(%bx,%si)
  10239d:	00 00                	add    %al,(%bx,%si)
        region->base = mm_start;
  10239f:	8b 45 e4             	mov    -0x1c(%di),%ax
  1023a2:	8b 55 ec             	mov    -0x14(%di),%dx
  1023a5:	89 10                	mov    %dx,(%bx,%si)
        region->size = mm_end - mm_start + 1;
  1023a7:	8b 45 e8             	mov    -0x18(%di),%ax
  1023aa:	2b 45 ec             	sub    -0x14(%di),%ax
  1023ad:	8d 50 01             	lea    0x1(%bx,%si),%dx
  1023b0:	8b 45 e4             	mov    -0x1c(%di),%ax
  1023b3:	89 50 04             	mov    %dx,0x4(%bx,%si)
        memblock.memory.cnt++;
  1023b6:	a1 00 60             	mov    0x6000,%ax
  1023b9:	13 00                	adc    (%bx,%si),%ax
  1023bb:	83 c0 01             	add    $0x1,%ax
  1023be:	a3 00 60             	mov    %ax,0x6000
  1023c1:	13 00                	adc    (%bx,%si),%ax
    } else {
        dbg_warning("内存区域初始化失败\n");
    }
}
  1023c3:	eb 21                	jmp    1023e6 <memblock_init+0x122>
        dbg_warning("内存区域初始化失败\n");
  1023c5:	83 ec 0c             	sub    $0xc,%sp
  1023c8:	68 ef 49             	push   $0x49ef
  1023cb:	10 00                	adc    %al,(%bx,%si)
  1023cd:	68 92 00             	push   $0x92
  1023d0:	00 00                	add    %al,(%bx,%si)
  1023d2:	68 2c 4a             	push   $0x4a2c
  1023d5:	10 00                	adc    %al,(%bx,%si)
  1023d7:	68 91 49             	push   $0x4991
  1023da:	10 00                	adc    %al,(%bx,%si)
  1023dc:	6a 02                	push   $0x2
  1023de:	e8 a1 03             	call   102782 <hlt+0x5>
  1023e1:	00 00                	add    %al,(%bx,%si)
  1023e3:	83 c4 20             	add    $0x20,%sp
}
  1023e6:	90                   	nop
  1023e7:	c9                   	leave  
  1023e8:	c3                   	ret    

001023e9 <outb>:
static inline void outb(uint16_t port, uint8_t data) {
  1023e9:	55                   	push   %bp
  1023ea:	89 e5                	mov    %sp,%bp
  1023ec:	83 ec 08             	sub    $0x8,%sp
  1023ef:	8b 45 08             	mov    0x8(%di),%ax
  1023f2:	8b 55 0c             	mov    0xc(%di),%dx
  1023f5:	66 89 45 fc          	mov    %eax,-0x4(%di)
  1023f9:	89 d0                	mov    %dx,%ax
  1023fb:	88 45 f8             	mov    %al,-0x8(%di)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
  1023fe:	0f b7 55 fc          	movzww -0x4(%di),%dx
  102402:	0f b6 45 f8          	movzbw -0x8(%di),%ax
  102406:	ee                   	out    %al,(%dx)
}
  102407:	90                   	nop
  102408:	c9                   	leave  
  102409:	c3                   	ret    

0010240a <do_handler_timer>:
static uint32_t sys_tick;

/**
 * 定时器中断处理函数
 */
void do_handler_timer (exception_frame_t *frame) {
  10240a:	55                   	push   %bp
  10240b:	89 e5                	mov    %sp,%bp
  10240d:	83 ec 08             	sub    $0x8,%sp
    sys_tick++;
  102410:	a1 18 60             	mov    0x6018,%ax
  102413:	13 00                	adc    (%bx,%si),%ax
  102415:	83 c0 01             	add    $0x1,%ax
  102418:	a3 18 60             	mov    %ax,0x6018
  10241b:	13 00                	adc    (%bx,%si),%ax

    // 发送EOI
    pic_send_eoi(IRQ0_TIMER);
  10241d:	83 ec 0c             	sub    $0xc,%sp
  102420:	6a 20                	push   $0x20
  102422:	e8 29 f0             	call   10144e <init_pic+0x91>
  102425:	ff                   	(bad)  
  102426:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    task_time_tick();
  10242a:	e8 89 e0             	call   1004b6 <schedul+0x64>
  10242d:	ff                   	(bad)  
  10242e:	ff 90 c9 c3          	call   *-0x3c37(%bx,%si)

00102432 <timer_init>:
   
}

void timer_init(void)
{
  102432:	55                   	push   %bp
  102433:	89 e5                	mov    %sp,%bp
  102435:	83 ec 18             	sub    $0x18,%sp
    sys_tick = 0;
  102438:	c7 05 18 60          	movw   $0x6018,(%di)
  10243c:	13 00                	adc    (%bx,%si),%ax
  10243e:	00 00                	add    %al,(%bx,%si)
  102440:	00 00                	add    %al,(%bx,%si)
    uint32_t reload_count = PIT_OSC_FREQ / (1000.0 / OS_TICK_MS);
  102442:	c7 45 f4 9b 2e       	movw   $0x2e9b,-0xc(%di)
  102447:	00 00                	add    %al,(%bx,%si)

    // outb(PIT_COMMAND_MODE_PORT, PIT_CHANNLE0 | PIT_LOAD_LOHI | PIT_MODE0);
    outb(PIT_COMMAND_MODE_PORT, PIT_CHANNLE0 | PIT_LOAD_LOHI | PIT_MODE3);
  102449:	6a 36                	push   $0x36
  10244b:	6a 43                	push   $0x43
  10244d:	e8 97 ff             	call   1023e7 <memblock_init+0x123>
  102450:	ff                   	(bad)  
  102451:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(PIT_CHANNEL0_DATA_PORT, reload_count & 0xFF);        // 加载低8位
  102455:	8b 45 f4             	mov    -0xc(%di),%ax
  102458:	0f b6 c0             	movzbw %al,%ax
  10245b:	50                   	push   %ax
  10245c:	6a 40                	push   $0x40
  10245e:	e8 86 ff             	call   1023e7 <memblock_init+0x123>
  102461:	ff                   	(bad)  
  102462:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(PIT_CHANNEL0_DATA_PORT, (reload_count >> 8) & 0xFF); // 再加载高8位
  102466:	8b 45 f4             	mov    -0xc(%di),%ax
  102469:	c1 e8 08             	shr    $0x8,%ax
  10246c:	0f b6 c0             	movzbw %al,%ax
  10246f:	50                   	push   %ax
  102470:	6a 40                	push   $0x40
  102472:	e8 72 ff             	call   1023e7 <memblock_init+0x123>
  102475:	ff                   	(bad)  
  102476:	ff 83 c4 08          	incw   0x8c4(%bp,%di)

    interupt_install(IRQ0_TIMER, (irq_handler_t)exception_handler_timer);
  10247a:	83 ec 08             	sub    $0x8,%sp
  10247d:	68 7c 02             	push   $0x27c
  102480:	10 00                	adc    %al,(%bx,%si)
  102482:	6a 20                	push   $0x20
  102484:	e8 3f ec             	call   1010c6 <do_handler_virtual_exception+0x1a>
  102487:	ff                   	(bad)  
  102488:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    irq_enable(IRQ0_TIMER);
  10248c:	83 ec 0c             	sub    $0xc,%sp
  10248f:	6a 20                	push   $0x20
  102491:	e8 e5 ef             	call   101479 <pic_send_eoi+0x29>
  102494:	ff                   	(bad)  
  102495:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
  102499:	90                   	nop
  10249a:	c9                   	leave  
  10249b:	c3                   	ret    

0010249c <inb>:
static inline uint8_t inb(uint16_t  port) {
  10249c:	55                   	push   %bp
  10249d:	89 e5                	mov    %sp,%bp
  10249f:	83 ec 14             	sub    $0x14,%sp
  1024a2:	8b 45 08             	mov    0x8(%di),%ax
  1024a5:	66 89 45 ec          	mov    %eax,-0x14(%di)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
  1024a9:	0f b7 45 ec          	movzww -0x14(%di),%ax
  1024ad:	89 c2                	mov    %ax,%dx
  1024af:	ec                   	in     (%dx),%al
  1024b0:	88 45 ff             	mov    %al,-0x1(%di)
	return rv;
  1024b3:	0f b6 45 ff          	movzbw -0x1(%di),%ax
}
  1024b7:	c9                   	leave  
  1024b8:	c3                   	ret    

001024b9 <outb>:
static inline void outb(uint16_t port, uint8_t data) {
  1024b9:	55                   	push   %bp
  1024ba:	89 e5                	mov    %sp,%bp
  1024bc:	83 ec 08             	sub    $0x8,%sp
  1024bf:	8b 45 08             	mov    0x8(%di),%ax
  1024c2:	8b 55 0c             	mov    0xc(%di),%dx
  1024c5:	66 89 45 fc          	mov    %eax,-0x4(%di)
  1024c9:	89 d0                	mov    %dx,%ax
  1024cb:	88 45 f8             	mov    %al,-0x8(%di)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
  1024ce:	0f b7 55 fc          	movzww -0x4(%di),%dx
  1024d2:	0f b6 45 f8          	movzbw -0x8(%di),%ax
  1024d6:	ee                   	out    %al,(%dx)
}
  1024d7:	90                   	nop
  1024d8:	c9                   	leave  
  1024d9:	c3                   	ret    

001024da <read_cmos>:
#include "rtc.h"
#define CMOS_ADDRESS 0x70
#define CMOS_DATA    0x71

// 使用 inb 和 outb 函数从 CMOS 读取指定寄存器的值
static inline uint8_t read_cmos(uint8_t reg) {
  1024da:	55                   	push   %bp
  1024db:	89 e5                	mov    %sp,%bp
  1024dd:	83 ec 04             	sub    $0x4,%sp
  1024e0:	8b 45 08             	mov    0x8(%di),%ax
  1024e3:	88 45 fc             	mov    %al,-0x4(%di)
    outb(CMOS_ADDRESS, reg);          // 设置寄存器地址
  1024e6:	0f b6 45 fc          	movzbw -0x4(%di),%ax
  1024ea:	50                   	push   %ax
  1024eb:	6a 70                	push   $0x70
  1024ed:	e8 c7 ff             	call   1024b7 <inb+0x1b>
  1024f0:	ff                   	(bad)  
  1024f1:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    return inb(CMOS_DATA);            // 从 CMOS 数据端口读取数据
  1024f5:	6a 71                	push   $0x71
  1024f7:	e8 a0 ff             	call   10249a <timer_init+0x68>
  1024fa:	ff                   	(bad)  
  1024fb:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
}
  1024ff:	c9                   	leave  
  102500:	c3                   	ret    

00102501 <rtc_init>:
#define BCD_TO_BIN(val) ((val) = ((val) & 0x0F) + ((val) >> 4) * 10)

time_t startup_time;

void rtc_init(void)
{
  102501:	55                   	push   %bp
  102502:	89 e5                	mov    %sp,%bp
  102504:	53                   	push   %bx
  102505:	83 ec 34             	sub    $0x34,%sp
    tm_t time;

    do {
        time.tm_sec = read_cmos(0x00);    // 秒
  102508:	6a 00                	push   $0x0
  10250a:	e8 cb ff             	call   1024d8 <outb+0x1f>
  10250d:	ff                   	(bad)  
  10250e:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  102512:	0f b6 c0             	movzbw %al,%ax
  102515:	89 45 d4             	mov    %ax,-0x2c(%di)
        time.tm_min = read_cmos(0x02);    // 分钟
  102518:	6a 02                	push   $0x2
  10251a:	e8 bb ff             	call   1024d8 <outb+0x1f>
  10251d:	ff                   	(bad)  
  10251e:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  102522:	0f b6 c0             	movzbw %al,%ax
  102525:	89 45 d8             	mov    %ax,-0x28(%di)
        time.tm_hour = read_cmos(0x04);   // 小时
  102528:	6a 04                	push   $0x4
  10252a:	e8 ab ff             	call   1024d8 <outb+0x1f>
  10252d:	ff                   	(bad)  
  10252e:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  102532:	0f b6 c0             	movzbw %al,%ax
  102535:	89 45 dc             	mov    %ax,-0x24(%di)
        time.tm_mday = read_cmos(0x07);   // 日
  102538:	6a 07                	push   $0x7
  10253a:	e8 9b ff             	call   1024d8 <outb+0x1f>
  10253d:	ff                   	(bad)  
  10253e:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  102542:	0f b6 c0             	movzbw %al,%ax
  102545:	89 45 e0             	mov    %ax,-0x20(%di)
        time.tm_mon = read_cmos(0x08);    // 月
  102548:	6a 08                	push   $0x8
  10254a:	e8 8b ff             	call   1024d8 <outb+0x1f>
  10254d:	ff                   	(bad)  
  10254e:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  102552:	0f b6 c0             	movzbw %al,%ax
  102555:	89 45 e4             	mov    %ax,-0x1c(%di)
        time.tm_year = read_cmos(0x09);   // 年
  102558:	6a 09                	push   $0x9
  10255a:	e8 7b ff             	call   1024d8 <outb+0x1f>
  10255d:	ff                   	(bad)  
  10255e:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  102562:	0f b6 c0             	movzbw %al,%ax
  102565:	89 45 e8             	mov    %ax,-0x18(%di)
    } while (time.tm_sec != read_cmos(0x00));  // 再次读取秒，确保数据一致性
  102568:	8b 5d d4             	mov    -0x2c(%di),%bx
  10256b:	6a 00                	push   $0x0
  10256d:	e8 68 ff             	call   1024d8 <outb+0x1f>
  102570:	ff                   	(bad)  
  102571:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  102575:	0f b6 c0             	movzbw %al,%ax
  102578:	39 c3                	cmp    %ax,%bx
  10257a:	75 8c                	jne    102508 <rtc_init+0x7>

    // 将 BCD 编码转换为二进制
    BCD_TO_BIN(time.tm_sec);
  10257c:	8b 45 d4             	mov    -0x2c(%di),%ax
  10257f:	83 e0 0f             	and    $0xf,%ax
  102582:	89 c1                	mov    %ax,%cx
  102584:	8b 45 d4             	mov    -0x2c(%di),%ax
  102587:	c1 f8 04             	sar    $0x4,%ax
  10258a:	89 c2                	mov    %ax,%dx
  10258c:	89 d0                	mov    %dx,%ax
  10258e:	c1 e0 02             	shl    $0x2,%ax
  102591:	01 d0                	add    %dx,%ax
  102593:	01 c0                	add    %ax,%ax
  102595:	01 c8                	add    %cx,%ax
  102597:	89 45 d4             	mov    %ax,-0x2c(%di)
    BCD_TO_BIN(time.tm_min);
  10259a:	8b 45 d8             	mov    -0x28(%di),%ax
  10259d:	83 e0 0f             	and    $0xf,%ax
  1025a0:	89 c1                	mov    %ax,%cx
  1025a2:	8b 45 d8             	mov    -0x28(%di),%ax
  1025a5:	c1 f8 04             	sar    $0x4,%ax
  1025a8:	89 c2                	mov    %ax,%dx
  1025aa:	89 d0                	mov    %dx,%ax
  1025ac:	c1 e0 02             	shl    $0x2,%ax
  1025af:	01 d0                	add    %dx,%ax
  1025b1:	01 c0                	add    %ax,%ax
  1025b3:	01 c8                	add    %cx,%ax
  1025b5:	89 45 d8             	mov    %ax,-0x28(%di)
    BCD_TO_BIN(time.tm_hour);
  1025b8:	8b 45 dc             	mov    -0x24(%di),%ax
  1025bb:	83 e0 0f             	and    $0xf,%ax
  1025be:	89 c1                	mov    %ax,%cx
  1025c0:	8b 45 dc             	mov    -0x24(%di),%ax
  1025c3:	c1 f8 04             	sar    $0x4,%ax
  1025c6:	89 c2                	mov    %ax,%dx
  1025c8:	89 d0                	mov    %dx,%ax
  1025ca:	c1 e0 02             	shl    $0x2,%ax
  1025cd:	01 d0                	add    %dx,%ax
  1025cf:	01 c0                	add    %ax,%ax
  1025d1:	01 c8                	add    %cx,%ax
  1025d3:	89 45 dc             	mov    %ax,-0x24(%di)
    BCD_TO_BIN(time.tm_mday);
  1025d6:	8b 45 e0             	mov    -0x20(%di),%ax
  1025d9:	83 e0 0f             	and    $0xf,%ax
  1025dc:	89 c1                	mov    %ax,%cx
  1025de:	8b 45 e0             	mov    -0x20(%di),%ax
  1025e1:	c1 f8 04             	sar    $0x4,%ax
  1025e4:	89 c2                	mov    %ax,%dx
  1025e6:	89 d0                	mov    %dx,%ax
  1025e8:	c1 e0 02             	shl    $0x2,%ax
  1025eb:	01 d0                	add    %dx,%ax
  1025ed:	01 c0                	add    %ax,%ax
  1025ef:	01 c8                	add    %cx,%ax
  1025f1:	89 45 e0             	mov    %ax,-0x20(%di)
    BCD_TO_BIN(time.tm_mon);
  1025f4:	8b 45 e4             	mov    -0x1c(%di),%ax
  1025f7:	83 e0 0f             	and    $0xf,%ax
  1025fa:	89 c1                	mov    %ax,%cx
  1025fc:	8b 45 e4             	mov    -0x1c(%di),%ax
  1025ff:	c1 f8 04             	sar    $0x4,%ax
  102602:	89 c2                	mov    %ax,%dx
  102604:	89 d0                	mov    %dx,%ax
  102606:	c1 e0 02             	shl    $0x2,%ax
  102609:	01 d0                	add    %dx,%ax
  10260b:	01 c0                	add    %ax,%ax
  10260d:	01 c8                	add    %cx,%ax
  10260f:	89 45 e4             	mov    %ax,-0x1c(%di)
    BCD_TO_BIN(time.tm_year);
  102612:	8b 45 e8             	mov    -0x18(%di),%ax
  102615:	83 e0 0f             	and    $0xf,%ax
  102618:	89 c1                	mov    %ax,%cx
  10261a:	8b 45 e8             	mov    -0x18(%di),%ax
  10261d:	c1 f8 04             	sar    $0x4,%ax
  102620:	89 c2                	mov    %ax,%dx
  102622:	89 d0                	mov    %dx,%ax
  102624:	c1 e0 02             	shl    $0x2,%ax
  102627:	01 d0                	add    %dx,%ax
  102629:	01 c0                	add    %ax,%ax
  10262b:	01 c8                	add    %cx,%ax
  10262d:	89 45 e8             	mov    %ax,-0x18(%di)

    time.tm_mon--;  // 月份从 0 开始
  102630:	8b 45 e4             	mov    -0x1c(%di),%ax
  102633:	83 e8 01             	sub    $0x1,%ax
  102636:	89 45 e4             	mov    %ax,-0x1c(%di)
    startup_time = kernel_mktime(&time);  // 将时间转换为 UNIX 时间戳
  102639:	83 ec 0c             	sub    $0xc,%sp
  10263c:	8d 45 d4             	lea    -0x2c(%di),%ax
  10263f:	50                   	push   %ax
  102640:	e8 8d 08             	call   102ed0 <is_leap_year+0x62>
  102643:	00 00                	add    %al,(%bx,%si)
  102645:	83 c4 10             	add    $0x10,%sp
  102648:	a3 1c 60             	mov    %ax,0x601c
  10264b:	13 00                	adc    (%bx,%si),%ax
    //localtime(&test,startup_time);
    return;
  10264d:	90                   	nop
    
  10264e:	8b 5d fc             	mov    -0x4(%di),%bx
  102651:	c9                   	leave  
  102652:	c3                   	ret    

00102653 <inb>:
static inline uint8_t inb(uint16_t  port) {
  102653:	55                   	push   %bp
  102654:	89 e5                	mov    %sp,%bp
  102656:	83 ec 14             	sub    $0x14,%sp
  102659:	8b 45 08             	mov    0x8(%di),%ax
  10265c:	66 89 45 ec          	mov    %eax,-0x14(%di)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
  102660:	0f b7 45 ec          	movzww -0x14(%di),%ax
  102664:	89 c2                	mov    %ax,%dx
  102666:	ec                   	in     (%dx),%al
  102667:	88 45 ff             	mov    %al,-0x1(%di)
	return rv;
  10266a:	0f b6 45 ff          	movzbw -0x1(%di),%ax
}
  10266e:	c9                   	leave  
  10266f:	c3                   	ret    

00102670 <outb>:
static inline void outb(uint16_t port, uint8_t data) {
  102670:	55                   	push   %bp
  102671:	89 e5                	mov    %sp,%bp
  102673:	83 ec 08             	sub    $0x8,%sp
  102676:	8b 45 08             	mov    0x8(%di),%ax
  102679:	8b 55 0c             	mov    0xc(%di),%dx
  10267c:	66 89 45 fc          	mov    %eax,-0x4(%di)
  102680:	89 d0                	mov    %dx,%ax
  102682:	88 45 f8             	mov    %al,-0x8(%di)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
  102685:	0f b7 55 fc          	movzww -0x4(%di),%dx
  102689:	0f b6 45 f8          	movzbw -0x8(%di),%ax
  10268d:	ee                   	out    %al,(%dx)
}
  10268e:	90                   	nop
  10268f:	c9                   	leave  
  102690:	c3                   	ret    

00102691 <rs232_init>:
#include "serial.h"

#define COM1_PORT           0x3F8       // RS232端口0初始化

static void rs232_init(void)
{
  102691:	55                   	push   %bp
  102692:	89 e5                	mov    %sp,%bp
    outb(COM1_PORT + 1, 0x00);    // Disable all interrupts
  102694:	6a 00                	push   $0x0
  102696:	68 f9 03             	push   $0x3f9
  102699:	00 00                	add    %al,(%bx,%si)
  10269b:	e8 d0 ff             	call   10266e <inb+0x1b>
  10269e:	ff                   	(bad)  
  10269f:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(COM1_PORT + 3, 0x80);    // Enable DLAB (set baud rate divisor)
  1026a3:	68 80 00             	push   $0x80
  1026a6:	00 00                	add    %al,(%bx,%si)
  1026a8:	68 fb 03             	push   $0x3fb
  1026ab:	00 00                	add    %al,(%bx,%si)
  1026ad:	e8 be ff             	call   10266e <inb+0x1b>
  1026b0:	ff                   	(bad)  
  1026b1:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(COM1_PORT + 0, 0x03);    // Set divisor to 3 (lo byte) 38400 baud
  1026b5:	6a 03                	push   $0x3
  1026b7:	68 f8 03             	push   $0x3f8
  1026ba:	00 00                	add    %al,(%bx,%si)
  1026bc:	e8 af ff             	call   10266e <inb+0x1b>
  1026bf:	ff                   	(bad)  
  1026c0:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(COM1_PORT + 1, 0x00);    //                  (hi byte)
  1026c4:	6a 00                	push   $0x0
  1026c6:	68 f9 03             	push   $0x3f9
  1026c9:	00 00                	add    %al,(%bx,%si)
  1026cb:	e8 a0 ff             	call   10266e <inb+0x1b>
  1026ce:	ff                   	(bad)  
  1026cf:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(COM1_PORT + 3, 0x03);    // 8 bits, no parity, one stop bit
  1026d3:	6a 03                	push   $0x3
  1026d5:	68 fb 03             	push   $0x3fb
  1026d8:	00 00                	add    %al,(%bx,%si)
  1026da:	e8 91 ff             	call   10266e <inb+0x1b>
  1026dd:	ff                   	(bad)  
  1026de:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(COM1_PORT + 2, 0xC7);    // Enable FIFO, clear them, with 14-byte threshold
  1026e2:	68 c7 00             	push   $0xc7
  1026e5:	00 00                	add    %al,(%bx,%si)
  1026e7:	68 fa 03             	push   $0x3fa
  1026ea:	00 00                	add    %al,(%bx,%si)
  1026ec:	e8 7f ff             	call   10266e <inb+0x1b>
  1026ef:	ff                   	(bad)  
  1026f0:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
  
    // If serial is not faulty set it in normal operation mode
    // (not-loopback with IRQs enabled and OUT#1 and OUT#2 bits enabled)
    outb(COM1_PORT + 4, 0x0F);
  1026f4:	6a 0f                	push   $0xf
  1026f6:	68 fc 03             	push   $0x3fc
  1026f9:	00 00                	add    %al,(%bx,%si)
  1026fb:	e8 70 ff             	call   10266e <inb+0x1b>
  1026fe:	ff                   	(bad)  
  1026ff:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
}
  102703:	90                   	nop
  102704:	c9                   	leave  
  102705:	c3                   	ret    

00102706 <serial_init>:

void serial_init(void)
{
  102706:	55                   	push   %bp
  102707:	89 e5                	mov    %sp,%bp
    rs232_init();
  102709:	e8 83 ff             	call   10268f <outb+0x1f>
  10270c:	ff                   	(bad)  
  10270d:	ff 90 5d c3          	call   *-0x3ca3(%bx,%si)

00102711 <serial_printf>:
}

/**
 * @brief 日志打印
 */
void serial_printf(const char * str_buf) {
  102711:	55                   	push   %bp
  102712:	89 e5                	mov    %sp,%bp
  102714:	83 ec 18             	sub    $0x18,%sp
    const char * p = str_buf;   
  102717:	8b 45 08             	mov    0x8(%di),%ax
  10271a:	89 45 f4             	mov    %ax,-0xc(%di)
    irq_state_t state =  irq_enter_protection(); 
  10271d:	e8 0b f0             	call   10172b <irq_enable_global+0x9>
  102720:	ff                   	(bad)  
  102721:	ff 89 45 f0          	decw   -0xfbb(%bx,%di)
    while (*p != '\0') {
  102725:	eb 3b                	jmp    102762 <serial_printf+0x51>
        while ((inb(COM1_PORT + 5) & (1 << 6)) == 0);
  102727:	90                   	nop
  102728:	83 ec 0c             	sub    $0xc,%sp
  10272b:	68 fd 03             	push   $0x3fd
  10272e:	00 00                	add    %al,(%bx,%si)
  102730:	e8 1e ff             	call   102651 <rtc_init+0x150>
  102733:	ff                   	(bad)  
  102734:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
  102738:	0f b6 c0             	movzbw %al,%ax
  10273b:	83 e0 40             	and    $0x40,%ax
  10273e:	85 c0                	test   %ax,%ax
  102740:	74 e6                	je     102728 <serial_printf+0x17>
        outb(COM1_PORT, *p++);
  102742:	8b 45 f4             	mov    -0xc(%di),%ax
  102745:	8d 50 01             	lea    0x1(%bx,%si),%dx
  102748:	89 55 f4             	mov    %dx,-0xc(%di)
  10274b:	0f b6 00             	movzbw (%bx,%si),%ax
  10274e:	0f b6 c0             	movzbw %al,%ax
  102751:	83 ec 08             	sub    $0x8,%sp
  102754:	50                   	push   %ax
  102755:	68 f8 03             	push   $0x3f8
  102758:	00 00                	add    %al,(%bx,%si)
  10275a:	e8 11 ff             	call   10266e <inb+0x1b>
  10275d:	ff                   	(bad)  
  10275e:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    while (*p != '\0') {
  102762:	8b 45 f4             	mov    -0xc(%di),%ax
  102765:	0f b6 00             	movzbw (%bx,%si),%ax
  102768:	84 c0                	test   %al,%al
  10276a:	75 bb                	jne    102727 <serial_printf+0x16>
    }
    irq_leave_protection(state);
  10276c:	83 ec 0c             	sub    $0xc,%sp
  10276f:	ff 75 f0             	push   -0x10(%di)
  102772:	e8 ce ef             	call   101743 <irq_enter_protection+0x16>
  102775:	ff                   	(bad)  
  102776:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
  10277a:	90                   	nop
  10277b:	c9                   	leave  
  10277c:	c3                   	ret    

0010277d <hlt>:
static inline void hlt(void) {
  10277d:	55                   	push   %bp
  10277e:	89 e5                	mov    %sp,%bp
    __asm__ __volatile__("hlt");
  102780:	f4                   	hlt    
}
  102781:	90                   	nop
  102782:	5d                   	pop    %bp
  102783:	c3                   	ret    

00102784 <dbg_print>:
#define MAX_STR_BUF_SIZE 256
/**
 * @brief 格式化日志并打印到串口（使用 sprintf 和 vsprintf）
 */
void dbg_print(int level, const char *file, const char *func, int line, const char *fmt, ...)
{
  102784:	55                   	push   %bp
  102785:	89 e5                	mov    %sp,%bp
  102787:	81 ec 18 01          	sub    $0x118,%sp
  10278b:	00 00                	add    %al,(%bx,%si)
    if (level > DBG_LEVEL_CTL_SET)
  10278d:	83 7d 08 03          	cmpw   $0x3,0x8(%di)
  102791:	0f 8f a4 00          	jg     102839 <dbg_print+0xb5>
  102795:	00 00                	add    %al,(%bx,%si)
        [DBG_LEVEL_INFO] = "info",
        [DBG_LEVEL_NONE] = "none"};

    char str_buf[MAX_STR_BUF_SIZE];
    va_list args;
    int offset=0;
  102797:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
  10279c:	00 00                	add    %al,(%bx,%si)
    // 清空缓冲区
    memset(str_buf, '\0', sizeof(str_buf));
  10279e:	83 ec 04             	sub    $0x4,%sp
  1027a1:	68 00 01             	push   $0x100
  1027a4:	00 00                	add    %al,(%bx,%si)
  1027a6:	6a 00                	push   $0x0
  1027a8:	8d 85 f4 fe          	lea    -0x10c(%di),%ax
  1027ac:	ff                   	(bad)  
  1027ad:	ff 50 e8             	call   *-0x18(%bx,%si)
  1027b0:	22 04                	and    (%si),%al
  1027b2:	00 00                	add    %al,(%bx,%si)
  1027b4:	83 c4 10             	add    $0x10,%sp

    // 组装文件、函数和行号信息
    if (level != DBG_LEVEL_INFO)
  1027b7:	83 7d 08 03          	cmpw   $0x3,0x8(%di)
  1027bb:	74 40                	je     1027fd <dbg_print+0x79>
    {
        sprintf(str_buf, "[%s] in file:%s, func:%s, line:%d: \r\n", title[level], file, func, line);
  1027bd:	8b 45 08             	mov    0x8(%di),%ax
  1027c0:	8b 04                	mov    (%si),%ax
  1027c2:	85 00                	test   %ax,(%bx,%si)
  1027c4:	70 10                	jo     1027d6 <dbg_print+0x52>
  1027c6:	00 83 ec 08          	add    %al,0x8ec(%bp,%di)
  1027ca:	ff 75 14             	push   0x14(%di)
  1027cd:	ff 75 10             	push   0x10(%di)
  1027d0:	ff 75 0c             	push   0xc(%di)
  1027d3:	50                   	push   %ax
  1027d4:	68 3c 4a             	push   $0x4a3c
  1027d7:	10 00                	adc    %al,(%bx,%si)
  1027d9:	8d 85 f4 fe          	lea    -0x10c(%di),%ax
  1027dd:	ff                   	(bad)  
  1027de:	ff 50 e8             	call   *-0x18(%bx,%si)
  1027e1:	3b 05                	cmp    (%di),%ax
  1027e3:	00 00                	add    %al,(%bx,%si)
  1027e5:	83 c4 20             	add    $0x20,%sp
        offset = strlen(str_buf);
  1027e8:	83 ec 0c             	sub    $0xc,%sp
  1027eb:	8d 85 f4 fe          	lea    -0x10c(%di),%ax
  1027ef:	ff                   	(bad)  
  1027f0:	ff 50 e8             	call   *-0x18(%bx,%si)
  1027f3:	78 03                	js     1027f8 <dbg_print+0x74>
  1027f5:	00 00                	add    %al,(%bx,%si)
  1027f7:	83 c4 10             	add    $0x10,%sp
  1027fa:	89 45 f4             	mov    %ax,-0xc(%di)
    }

    // 格式化日志信息
    va_start(args, fmt);
  1027fd:	8d 45 1c             	lea    0x1c(%di),%ax
  102800:	89 85 f0 fe          	mov    %ax,-0x110(%di)
  102804:	ff                   	(bad)  
  102805:	ff 8b 85 f0          	decw   -0xf7b(%bp,%di)
    vsprintf(str_buf + offset, fmt, args);
  102809:	fe                   	(bad)  
  10280a:	ff                   	(bad)  
  10280b:	ff 8b 55 f4          	decw   -0xbab(%bp,%di)
  10280f:	8d 8d f4 fe          	lea    -0x10c(%di),%cx
  102813:	ff                   	(bad)  
  102814:	ff 01                	incw   (%bx,%di)
  102816:	ca 83 ec             	lret   $0xec83
  102819:	04 50                	add    $0x50,%al
  10281b:	ff 75 18             	push   0x18(%di)
  10281e:	52                   	push   %dx
  10281f:	e8 20 05             	call   102d42 <sprintf+0x22>
  102822:	00 00                	add    %al,(%bx,%si)
  102824:	83 c4 10             	add    $0x10,%sp
    va_end(args);

// 检查调试输出标志是否启用
#ifdef DBG_OUTPUT_SERIAL
    serial_printf(str_buf);
  102827:	83 ec 0c             	sub    $0xc,%sp
  10282a:	8d 85 f4 fe          	lea    -0x10c(%di),%ax
  10282e:	ff                   	(bad)  
  10282f:	ff 50 e8             	call   *-0x18(%bx,%si)
  102832:	db fe                	(bad)  
  102834:	ff                   	(bad)  
  102835:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
  102839:	eb 01                	jmp    10283c <dbg_print+0xb8>
        return;
  10283b:	90                   	nop
#elif DBG_OUTPUT_TTY

#else

#endif
}
  10283c:	c9                   	leave  
  10283d:	c3                   	ret    

0010283e <panic>:

void panic(const char *file, int line, const char *func, const char *cond)
{
  10283e:	55                   	push   %bp
  10283f:	89 e5                	mov    %sp,%bp
  102841:	81 ec 08 01          	sub    $0x108,%sp
  102845:	00 00                	add    %al,(%bx,%si)
    char str_buf[MAX_STR_BUF_SIZE];

    sprintf(str_buf, "[assert] in file:%s, func:%s, line:%d: %s", file, func, line, cond);
  102847:	83 ec 08             	sub    $0x8,%sp
  10284a:	ff 75 14             	push   0x14(%di)
  10284d:	ff 75 0c             	push   0xc(%di)
  102850:	ff 75 10             	push   0x10(%di)
  102853:	ff 75 08             	push   0x8(%di)
  102856:	68 64 4a             	push   $0x4a64
  102859:	10 00                	adc    %al,(%bx,%si)
  10285b:	8d 85 f8 fe          	lea    -0x108(%di),%ax
  10285f:	ff                   	(bad)  
  102860:	ff 50 e8             	call   *-0x18(%bx,%si)
  102863:	b9 04 00             	mov    $0x4,%cx
  102866:	00 83 c4 20          	add    %al,0x20c4(%bp,%di)
// 检查调试输出标志是否启用
#ifdef DBG_OUTPUT_SERIAL
    serial_printf(str_buf);
  10286a:	83 ec 0c             	sub    $0xc,%sp
  10286d:	8d 85 f8 fe          	lea    -0x108(%di),%ax
  102871:	ff                   	(bad)  
  102872:	ff 50 e8             	call   *-0x18(%bx,%si)
  102875:	98                   	cbtw   
  102876:	fe                   	(bad)  
  102877:	ff                   	(bad)  
  102878:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
#else

#endif
    for (;;)
    {
        hlt();
  10287c:	e8 fc fe             	call   10277b <serial_printf+0x6a>
  10287f:	ff                   	(bad)  
  102880:	ff                   	(bad)  
  102881:	eb f9                	jmp    10287c <panic+0x3e>

00102883 <list_is_empty>:
/**
 * 判断链表是否为空
 * @param list 判断的链表
 * @return 1 - 空，0 - 非空
 */
static inline int list_is_empty(list_t *list) {
  102883:	55                   	push   %bp
  102884:	89 e5                	mov    %sp,%bp
    return list->count == 0;
  102886:	8b 45 08             	mov    0x8(%di),%ax
  102889:	8b 40 08             	mov    0x8(%bx,%si),%ax
  10288c:	85 c0                	test   %ax,%ax
  10288e:	0f 94 c0             	sete   %al
  102891:	0f b6 c0             	movzbw %al,%ax
}
  102894:	5d                   	pop    %bp
  102895:	c3                   	ret    

00102896 <list_init>:

/**
 * 初始化链表
 * @param list 待初始化的链表
 */
void list_init(list_t *list) {
  102896:	55                   	push   %bp
  102897:	89 e5                	mov    %sp,%bp
    list->first = list->last = (list_node_t *)0;
  102899:	8b 45 08             	mov    0x8(%di),%ax
  10289c:	c7 40 04 00 00       	movw   $0x0,0x4(%bx,%si)
  1028a1:	00 00                	add    %al,(%bx,%si)
  1028a3:	8b 45 08             	mov    0x8(%di),%ax
  1028a6:	8b 50 04             	mov    0x4(%bx,%si),%dx
  1028a9:	8b 45 08             	mov    0x8(%di),%ax
  1028ac:	89 10                	mov    %dx,(%bx,%si)
    list->count = 0;
  1028ae:	8b 45 08             	mov    0x8(%di),%ax
  1028b1:	c7 40 08 00 00       	movw   $0x0,0x8(%bx,%si)
  1028b6:	00 00                	add    %al,(%bx,%si)
}
  1028b8:	90                   	nop
  1028b9:	5d                   	pop    %bp
  1028ba:	c3                   	ret    

001028bb <list_insert_first>:
/**
 * 将指定表项插入到指定链表的头部
 * @param list 待插入的链表
 * @param node 待插入的结点
 */
void list_insert_first(list_t *list, list_node_t *node) {
  1028bb:	55                   	push   %bp
  1028bc:	89 e5                	mov    %sp,%bp
    // 设置好待插入结点的前后，前面为空
    node->next = list->first;
  1028be:	8b 45 08             	mov    0x8(%di),%ax
  1028c1:	8b 10                	mov    (%bx,%si),%dx
  1028c3:	8b 45 0c             	mov    0xc(%di),%ax
  1028c6:	89 50 04             	mov    %dx,0x4(%bx,%si)
    node->pre = (list_node_t *)0;
  1028c9:	8b 45 0c             	mov    0xc(%di),%ax
  1028cc:	c7 00 00 00          	movw   $0x0,(%bx,%si)
  1028d0:	00 00                	add    %al,(%bx,%si)

    // 如果为空，需要同时设置first和last指向自己
    if (list_is_empty(list)) {
  1028d2:	ff 75 08             	push   0x8(%di)
  1028d5:	e8 a9 ff             	call   102881 <panic+0x43>
  1028d8:	ff                   	(bad)  
  1028d9:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  1028dd:	85 c0                	test   %ax,%ax
  1028df:	74 15                	je     1028f6 <list_insert_first+0x3b>
        list->last = list->first = node;
  1028e1:	8b 45 08             	mov    0x8(%di),%ax
  1028e4:	8b 55 0c             	mov    0xc(%di),%dx
  1028e7:	89 10                	mov    %dx,(%bx,%si)
  1028e9:	8b 45 08             	mov    0x8(%di),%ax
  1028ec:	8b 10                	mov    (%bx,%si),%dx
  1028ee:	8b 45 08             	mov    0x8(%di),%ax
  1028f1:	89 50 04             	mov    %dx,0x4(%bx,%si)
  1028f4:	eb 12                	jmp    102908 <list_insert_first+0x4d>
    } else {
        // 否则，设置好原本第一个结点的pre
        list->first->pre = node;
  1028f6:	8b 45 08             	mov    0x8(%di),%ax
  1028f9:	8b 00                	mov    (%bx,%si),%ax
  1028fb:	8b 55 0c             	mov    0xc(%di),%dx
  1028fe:	89 10                	mov    %dx,(%bx,%si)

        // 调整first指向
        list->first = node;
  102900:	8b 45 08             	mov    0x8(%di),%ax
  102903:	8b 55 0c             	mov    0xc(%di),%dx
  102906:	89 10                	mov    %dx,(%bx,%si)
    }

    list->count++;
  102908:	8b 45 08             	mov    0x8(%di),%ax
  10290b:	8b 40 08             	mov    0x8(%bx,%si),%ax
  10290e:	8d 50 01             	lea    0x1(%bx,%si),%dx
  102911:	8b 45 08             	mov    0x8(%di),%ax
  102914:	89 50 08             	mov    %dx,0x8(%bx,%si)
}
  102917:	90                   	nop
  102918:	c9                   	leave  
  102919:	c3                   	ret    

0010291a <list_insert_last>:
/**
 * 将指定表项插入到指定链表的尾部
 * @param list 操作的链表
 * @param node 待插入的结点
 */
void list_insert_last(list_t *list, list_node_t *node) {
  10291a:	55                   	push   %bp
  10291b:	89 e5                	mov    %sp,%bp
    // 设置好结点本身
    node->pre = list->last;
  10291d:	8b 45 08             	mov    0x8(%di),%ax
  102920:	8b 50 04             	mov    0x4(%bx,%si),%dx
  102923:	8b 45 0c             	mov    0xc(%di),%ax
  102926:	89 10                	mov    %dx,(%bx,%si)
    node->next = (list_node_t*)0;
  102928:	8b 45 0c             	mov    0xc(%di),%ax
  10292b:	c7 40 04 00 00       	movw   $0x0,0x4(%bx,%si)
  102930:	00 00                	add    %al,(%bx,%si)

    // 表空，则first/last都指向唯一的node
    if (list_is_empty(list)) {
  102932:	ff 75 08             	push   0x8(%di)
  102935:	e8 49 ff             	call   102881 <panic+0x43>
  102938:	ff                   	(bad)  
  102939:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  10293d:	85 c0                	test   %ax,%ax
  10293f:	74 16                	je     102957 <list_insert_last+0x3d>
        list->first = list->last = node;
  102941:	8b 45 08             	mov    0x8(%di),%ax
  102944:	8b 55 0c             	mov    0xc(%di),%dx
  102947:	89 50 04             	mov    %dx,0x4(%bx,%si)
  10294a:	8b 45 08             	mov    0x8(%di),%ax
  10294d:	8b 50 04             	mov    0x4(%bx,%si),%dx
  102950:	8b 45 08             	mov    0x8(%di),%ax
  102953:	89 10                	mov    %dx,(%bx,%si)
  102955:	eb 15                	jmp    10296c <list_insert_last+0x52>
    } else {
        // 否则，调整last结点的向一指向为node
        list->last->next = node;
  102957:	8b 45 08             	mov    0x8(%di),%ax
  10295a:	8b 40 04             	mov    0x4(%bx,%si),%ax
  10295d:	8b 55 0c             	mov    0xc(%di),%dx
  102960:	89 50 04             	mov    %dx,0x4(%bx,%si)

        // node变成了新的后继结点
        list->last = node;
  102963:	8b 45 08             	mov    0x8(%di),%ax
  102966:	8b 55 0c             	mov    0xc(%di),%dx
  102969:	89 50 04             	mov    %dx,0x4(%bx,%si)
    }

    list->count++;
  10296c:	8b 45 08             	mov    0x8(%di),%ax
  10296f:	8b 40 08             	mov    0x8(%bx,%si),%ax
  102972:	8d 50 01             	lea    0x1(%bx,%si),%dx
  102975:	8b 45 08             	mov    0x8(%di),%ax
  102978:	89 50 08             	mov    %dx,0x8(%bx,%si)
}
  10297b:	90                   	nop
  10297c:	c9                   	leave  
  10297d:	c3                   	ret    

0010297e <list_remove_first>:
/**
 * 移除指定链表的头部
 * @param list 操作的链表
 * @return 链表的第一个结点
 */
list_node_t* list_remove_first(list_t *list) {
  10297e:	55                   	push   %bp
  10297f:	89 e5                	mov    %sp,%bp
  102981:	83 ec 10             	sub    $0x10,%sp
    // 表项为空，返回空
    if (list_is_empty(list)) {
  102984:	ff 75 08             	push   0x8(%di)
  102987:	e8 f7 fe             	call   102881 <panic+0x43>
  10298a:	ff                   	(bad)  
  10298b:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  10298f:	85 c0                	test   %ax,%ax
  102991:	74 07                	je     10299a <list_remove_first+0x1c>
        return (list_node_t*)0;
  102993:	b8 00 00             	mov    $0x0,%ax
  102996:	00 00                	add    %al,(%bx,%si)
  102998:	eb 5a                	jmp    1029f4 <list_remove_first+0x76>
    }

    // 取第一个结点
    list_node_t * remove_node = list->first;
  10299a:	8b 45 08             	mov    0x8(%di),%ax
  10299d:	8b 00                	mov    (%bx,%si),%ax
  10299f:	89 45 fc             	mov    %ax,-0x4(%di)

    // 将first往表尾移1个，跳过刚才移过的那个，如果没有后继，则first=0
    list->first = remove_node->next;
  1029a2:	8b 45 fc             	mov    -0x4(%di),%ax
  1029a5:	8b 50 04             	mov    0x4(%bx,%si),%dx
  1029a8:	8b 45 08             	mov    0x8(%di),%ax
  1029ab:	89 10                	mov    %dx,(%bx,%si)
    if (list->first == (list_node_t *)0) {
  1029ad:	8b 45 08             	mov    0x8(%di),%ax
  1029b0:	8b 00                	mov    (%bx,%si),%ax
  1029b2:	85 c0                	test   %ax,%ax
  1029b4:	75 0c                	jne    1029c2 <list_remove_first+0x44>
        // node为最后一个结点
        list->last = (list_node_t*)0;
  1029b6:	8b 45 08             	mov    0x8(%di),%ax
  1029b9:	c7 40 04 00 00       	movw   $0x0,0x4(%bx,%si)
  1029be:	00 00                	add    %al,(%bx,%si)
  1029c0:	eb 0c                	jmp    1029ce <list_remove_first+0x50>
    } else {
        // 非最后一结点，将后继的前驱清0
        remove_node->next->pre = (list_node_t *)0;
  1029c2:	8b 45 fc             	mov    -0x4(%di),%ax
  1029c5:	8b 40 04             	mov    0x4(%bx,%si),%ax
  1029c8:	c7 00 00 00          	movw   $0x0,(%bx,%si)
  1029cc:	00 00                	add    %al,(%bx,%si)
    }

    // 调整node自己，置0，因为没有后继结点
    remove_node->next = remove_node->pre = (list_node_t*)0;
  1029ce:	8b 45 fc             	mov    -0x4(%di),%ax
  1029d1:	c7 00 00 00          	movw   $0x0,(%bx,%si)
  1029d5:	00 00                	add    %al,(%bx,%si)
  1029d7:	8b 45 fc             	mov    -0x4(%di),%ax
  1029da:	8b 10                	mov    (%bx,%si),%dx
  1029dc:	8b 45 fc             	mov    -0x4(%di),%ax
  1029df:	89 50 04             	mov    %dx,0x4(%bx,%si)

    // 同时调整计数值
    list->count--;
  1029e2:	8b 45 08             	mov    0x8(%di),%ax
  1029e5:	8b 40 08             	mov    0x8(%bx,%si),%ax
  1029e8:	8d 50 ff             	lea    -0x1(%bx,%si),%dx
  1029eb:	8b 45 08             	mov    0x8(%di),%ax
  1029ee:	89 50 08             	mov    %dx,0x8(%bx,%si)
    return remove_node;
  1029f1:	8b 45 fc             	mov    -0x4(%di),%ax
}
  1029f4:	c9                   	leave  
  1029f5:	c3                   	ret    

001029f6 <list_remove>:

/**
 * 移除指定链表的中的表项
 * 不检查node是否在结点中
 */
list_node_t * list_remove(list_t *list, list_node_t *remove_node) {
  1029f6:	55                   	push   %bp
  1029f7:	89 e5                	mov    %sp,%bp
    // 如果是头，头往前移
    if (remove_node == list->first) {
  1029f9:	8b 45 08             	mov    0x8(%di),%ax
  1029fc:	8b 00                	mov    (%bx,%si),%ax
  1029fe:	39 45 0c             	cmp    %ax,0xc(%di)
  102a01:	75 0b                	jne    102a0e <list_remove+0x18>
        list->first = remove_node->next;
  102a03:	8b 45 0c             	mov    0xc(%di),%ax
  102a06:	8b 50 04             	mov    0x4(%bx,%si),%dx
  102a09:	8b 45 08             	mov    0x8(%di),%ax
  102a0c:	89 10                	mov    %dx,(%bx,%si)
    }

    // 如果是尾，则尾往回移
    if (remove_node == list->last) {
  102a0e:	8b 45 08             	mov    0x8(%di),%ax
  102a11:	8b 40 04             	mov    0x4(%bx,%si),%ax
  102a14:	39 45 0c             	cmp    %ax,0xc(%di)
  102a17:	75 0b                	jne    102a24 <list_remove+0x2e>
        list->last = remove_node->pre;
  102a19:	8b 45 0c             	mov    0xc(%di),%ax
  102a1c:	8b 10                	mov    (%bx,%si),%dx
  102a1e:	8b 45 08             	mov    0x8(%di),%ax
  102a21:	89 50 04             	mov    %dx,0x4(%bx,%si)
    }

    // 如果有前，则调整前的后继
    if (remove_node->pre) {
  102a24:	8b 45 0c             	mov    0xc(%di),%ax
  102a27:	8b 00                	mov    (%bx,%si),%ax
  102a29:	85 c0                	test   %ax,%ax
  102a2b:	74 0e                	je     102a3b <list_remove+0x45>
        remove_node->pre->next = remove_node->next;
  102a2d:	8b 45 0c             	mov    0xc(%di),%ax
  102a30:	8b 00                	mov    (%bx,%si),%ax
  102a32:	8b 55 0c             	mov    0xc(%di),%dx
  102a35:	8b 52 04             	mov    0x4(%bp,%si),%dx
  102a38:	89 50 04             	mov    %dx,0x4(%bx,%si)
    }

    // 如果有后，则调整后往前的
    if (remove_node->next) {
  102a3b:	8b 45 0c             	mov    0xc(%di),%ax
  102a3e:	8b 40 04             	mov    0x4(%bx,%si),%ax
  102a41:	85 c0                	test   %ax,%ax
  102a43:	74 0d                	je     102a52 <list_remove+0x5c>
        remove_node->next->pre = remove_node->pre;
  102a45:	8b 45 0c             	mov    0xc(%di),%ax
  102a48:	8b 40 04             	mov    0x4(%bx,%si),%ax
  102a4b:	8b 55 0c             	mov    0xc(%di),%dx
  102a4e:	8b 12                	mov    (%bp,%si),%dx
  102a50:	89 10                	mov    %dx,(%bx,%si)
    }

    // 清空node指向
    remove_node->pre = remove_node->next = (list_node_t*)0;
  102a52:	8b 45 0c             	mov    0xc(%di),%ax
  102a55:	c7 40 04 00 00       	movw   $0x0,0x4(%bx,%si)
  102a5a:	00 00                	add    %al,(%bx,%si)
  102a5c:	8b 45 0c             	mov    0xc(%di),%ax
  102a5f:	8b 50 04             	mov    0x4(%bx,%si),%dx
  102a62:	8b 45 0c             	mov    0xc(%di),%ax
  102a65:	89 10                	mov    %dx,(%bx,%si)
    --list->count;
  102a67:	8b 45 08             	mov    0x8(%di),%ax
  102a6a:	8b 40 08             	mov    0x8(%bx,%si),%ax
  102a6d:	8d 50 ff             	lea    -0x1(%bx,%si),%dx
  102a70:	8b 45 08             	mov    0x8(%di),%ax
  102a73:	89 50 08             	mov    %dx,0x8(%bx,%si)
    return remove_node;
  102a76:	8b 45 0c             	mov    0xc(%di),%ax
}
  102a79:	5d                   	pop    %bp
  102a7a:	c3                   	ret    

00102a7b <strcpy>:
#include "string.h"
#include "types.h"
#include <stdarg.h>

// 字符串拷贝函数 strcpy
void strcpy(char *dest, const char *src) {
  102a7b:	55                   	push   %bp
  102a7c:	89 e5                	mov    %sp,%bp
    while ((*dest++ = *src++));
  102a7e:	90                   	nop
  102a7f:	8b 55 0c             	mov    0xc(%di),%dx
  102a82:	8d 42 01             	lea    0x1(%bp,%si),%ax
  102a85:	89 45 0c             	mov    %ax,0xc(%di)
  102a88:	8b 45 08             	mov    0x8(%di),%ax
  102a8b:	8d 48 01             	lea    0x1(%bx,%si),%cx
  102a8e:	89 4d 08             	mov    %cx,0x8(%di)
  102a91:	0f b6 12             	movzbw (%bp,%si),%dx
  102a94:	88 10                	mov    %dl,(%bx,%si)
  102a96:	0f b6 00             	movzbw (%bx,%si),%ax
  102a99:	84 c0                	test   %al,%al
  102a9b:	75 e2                	jne    102a7f <strcpy+0x4>
}
  102a9d:	90                   	nop
  102a9e:	90                   	nop
  102a9f:	5d                   	pop    %bp
  102aa0:	c3                   	ret    

00102aa1 <strncpy>:

// 有限长度字符串拷贝函数 strncpy
void strncpy(char *dest, const char *src, int size) {
  102aa1:	55                   	push   %bp
  102aa2:	89 e5                	mov    %sp,%bp
  102aa4:	83 ec 10             	sub    $0x10,%sp
    int i;
    for (i = 0; i < size && src[i] != '\0'; i++) {
  102aa7:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
  102aac:	00 00                	add    %al,(%bx,%si)
  102aae:	eb 19                	jmp    102ac9 <strncpy+0x28>
        dest[i] = src[i];
  102ab0:	8b 55 fc             	mov    -0x4(%di),%dx
  102ab3:	8b 45 0c             	mov    0xc(%di),%ax
  102ab6:	01 d0                	add    %dx,%ax
  102ab8:	8b 4d fc             	mov    -0x4(%di),%cx
  102abb:	8b 55 08             	mov    0x8(%di),%dx
  102abe:	01 ca                	add    %cx,%dx
  102ac0:	0f b6 00             	movzbw (%bx,%si),%ax
  102ac3:	88 02                	mov    %al,(%bp,%si)
    for (i = 0; i < size && src[i] != '\0'; i++) {
  102ac5:	83 45 fc 01          	addw   $0x1,-0x4(%di)
  102ac9:	8b 45 fc             	mov    -0x4(%di),%ax
  102acc:	3b 45 10             	cmp    0x10(%di),%ax
  102acf:	7d 20                	jge    102af1 <strncpy+0x50>
  102ad1:	8b 55 fc             	mov    -0x4(%di),%dx
  102ad4:	8b 45 0c             	mov    0xc(%di),%ax
  102ad7:	01 d0                	add    %dx,%ax
  102ad9:	0f b6 00             	movzbw (%bx,%si),%ax
  102adc:	84 c0                	test   %al,%al
  102ade:	75 d0                	jne    102ab0 <strncpy+0xf>
    }
    for (; i < size; i++) {
  102ae0:	eb 0f                	jmp    102af1 <strncpy+0x50>
        dest[i] = '\0';
  102ae2:	8b 55 fc             	mov    -0x4(%di),%dx
  102ae5:	8b 45 08             	mov    0x8(%di),%ax
  102ae8:	01 d0                	add    %dx,%ax
  102aea:	c6 00 00             	movb   $0x0,(%bx,%si)
    for (; i < size; i++) {
  102aed:	83 45 fc 01          	addw   $0x1,-0x4(%di)
  102af1:	8b 45 fc             	mov    -0x4(%di),%ax
  102af4:	3b 45 10             	cmp    0x10(%di),%ax
  102af7:	7c e9                	jl     102ae2 <strncpy+0x41>
    }
}
  102af9:	90                   	nop
  102afa:	90                   	nop
  102afb:	c9                   	leave  
  102afc:	c3                   	ret    

00102afd <strncmp>:

// 有限长度字符串比较函数 strncmp
int strncmp(const char *s1, const char *s2, int size) {
  102afd:	55                   	push   %bp
  102afe:	89 e5                	mov    %sp,%bp
  102b00:	83 ec 10             	sub    $0x10,%sp
    for (int i = 0; i < size; i++) {
  102b03:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
  102b08:	00 00                	add    %al,(%bx,%si)
  102b0a:	eb 54                	jmp    102b60 <strncmp+0x63>
        if (s1[i] != s2[i]) {
  102b0c:	8b 55 fc             	mov    -0x4(%di),%dx
  102b0f:	8b 45 08             	mov    0x8(%di),%ax
  102b12:	01 d0                	add    %dx,%ax
  102b14:	0f b6 10             	movzbw (%bx,%si),%dx
  102b17:	8b 4d fc             	mov    -0x4(%di),%cx
  102b1a:	8b 45 0c             	mov    0xc(%di),%ax
  102b1d:	01 c8                	add    %cx,%ax
  102b1f:	0f b6 00             	movzbw (%bx,%si),%ax
  102b22:	38 c2                	cmp    %al,%dl
  102b24:	74 20                	je     102b46 <strncmp+0x49>
            return (unsigned char)s1[i] - (unsigned char)s2[i];
  102b26:	8b 55 fc             	mov    -0x4(%di),%dx
  102b29:	8b 45 08             	mov    0x8(%di),%ax
  102b2c:	01 d0                	add    %dx,%ax
  102b2e:	0f b6 00             	movzbw (%bx,%si),%ax
  102b31:	0f b6 c0             	movzbw %al,%ax
  102b34:	8b 4d fc             	mov    -0x4(%di),%cx
  102b37:	8b 55 0c             	mov    0xc(%di),%dx
  102b3a:	01 ca                	add    %cx,%dx
  102b3c:	0f b6 12             	movzbw (%bp,%si),%dx
  102b3f:	0f b6 d2             	movzbw %dl,%dx
  102b42:	29 d0                	sub    %dx,%ax
  102b44:	eb 27                	jmp    102b6d <strncmp+0x70>
        }
        if (s1[i] == '\0') {
  102b46:	8b 55 fc             	mov    -0x4(%di),%dx
  102b49:	8b 45 08             	mov    0x8(%di),%ax
  102b4c:	01 d0                	add    %dx,%ax
  102b4e:	0f b6 00             	movzbw (%bx,%si),%ax
  102b51:	84 c0                	test   %al,%al
  102b53:	75 07                	jne    102b5c <strncmp+0x5f>
            return 0;
  102b55:	b8 00 00             	mov    $0x0,%ax
  102b58:	00 00                	add    %al,(%bx,%si)
  102b5a:	eb 11                	jmp    102b6d <strncmp+0x70>
    for (int i = 0; i < size; i++) {
  102b5c:	83 45 fc 01          	addw   $0x1,-0x4(%di)
  102b60:	8b 45 fc             	mov    -0x4(%di),%ax
  102b63:	3b 45 10             	cmp    0x10(%di),%ax
  102b66:	7c a4                	jl     102b0c <strncmp+0xf>
        }
    }
    return 0;
  102b68:	b8 00 00             	mov    $0x0,%ax
  102b6b:	00 00                	add    %al,(%bx,%si)
}
  102b6d:	c9                   	leave  
  102b6e:	c3                   	ret    

00102b6f <strlen>:

// 字符串长度函数 strlen
int strlen(const char *str) {
  102b6f:	55                   	push   %bp
  102b70:	89 e5                	mov    %sp,%bp
  102b72:	83 ec 10             	sub    $0x10,%sp
    int len = 0;
  102b75:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
  102b7a:	00 00                	add    %al,(%bx,%si)
    while (str[len] != '\0') {
  102b7c:	eb 04                	jmp    102b82 <strlen+0x13>
        len++;
  102b7e:	83 45 fc 01          	addw   $0x1,-0x4(%di)
    while (str[len] != '\0') {
  102b82:	8b 55 fc             	mov    -0x4(%di),%dx
  102b85:	8b 45 08             	mov    0x8(%di),%ax
  102b88:	01 d0                	add    %dx,%ax
  102b8a:	0f b6 00             	movzbw (%bx,%si),%ax
  102b8d:	84 c0                	test   %al,%al
  102b8f:	75 ed                	jne    102b7e <strlen+0xf>
    }
    return len;
  102b91:	8b 45 fc             	mov    -0x4(%di),%ax
}
  102b94:	c9                   	leave  
  102b95:	c3                   	ret    

00102b96 <memcpy>:

// 内存拷贝函数 memcpy
void memcpy(void *dest, const void *src, int size) {
  102b96:	55                   	push   %bp
  102b97:	89 e5                	mov    %sp,%bp
  102b99:	83 ec 10             	sub    $0x10,%sp
    uint8_t *d = dest;
  102b9c:	8b 45 08             	mov    0x8(%di),%ax
  102b9f:	89 45 f8             	mov    %ax,-0x8(%di)
    const uint8_t *s = src;
  102ba2:	8b 45 0c             	mov    0xc(%di),%ax
  102ba5:	89 45 f4             	mov    %ax,-0xc(%di)
    for (int i = 0; i < size; i++) {
  102ba8:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
  102bad:	00 00                	add    %al,(%bx,%si)
  102baf:	eb 19                	jmp    102bca <memcpy+0x34>
        d[i] = s[i];
  102bb1:	8b 55 fc             	mov    -0x4(%di),%dx
  102bb4:	8b 45 f4             	mov    -0xc(%di),%ax
  102bb7:	01 d0                	add    %dx,%ax
  102bb9:	8b 4d fc             	mov    -0x4(%di),%cx
  102bbc:	8b 55 f8             	mov    -0x8(%di),%dx
  102bbf:	01 ca                	add    %cx,%dx
  102bc1:	0f b6 00             	movzbw (%bx,%si),%ax
  102bc4:	88 02                	mov    %al,(%bp,%si)
    for (int i = 0; i < size; i++) {
  102bc6:	83 45 fc 01          	addw   $0x1,-0x4(%di)
  102bca:	8b 45 fc             	mov    -0x4(%di),%ax
  102bcd:	3b 45 10             	cmp    0x10(%di),%ax
  102bd0:	7c df                	jl     102bb1 <memcpy+0x1b>
    }
}
  102bd2:	90                   	nop
  102bd3:	90                   	nop
  102bd4:	c9                   	leave  
  102bd5:	c3                   	ret    

00102bd6 <memset>:

// 内存填充函数 memset
void memset(void *dest, uint8_t v, int size) {
  102bd6:	55                   	push   %bp
  102bd7:	89 e5                	mov    %sp,%bp
  102bd9:	83 ec 14             	sub    $0x14,%sp
  102bdc:	8b 45 0c             	mov    0xc(%di),%ax
  102bdf:	88 45 ec             	mov    %al,-0x14(%di)
    uint8_t *d = dest;
  102be2:	8b 45 08             	mov    0x8(%di),%ax
  102be5:	89 45 f8             	mov    %ax,-0x8(%di)
    for (int i = 0; i < size; i++) {
  102be8:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
  102bed:	00 00                	add    %al,(%bx,%si)
  102bef:	eb 12                	jmp    102c03 <memset+0x2d>
        d[i] = v;
  102bf1:	8b 55 fc             	mov    -0x4(%di),%dx
  102bf4:	8b 45 f8             	mov    -0x8(%di),%ax
  102bf7:	01 c2                	add    %ax,%dx
  102bf9:	0f b6 45 ec          	movzbw -0x14(%di),%ax
  102bfd:	88 02                	mov    %al,(%bp,%si)
    for (int i = 0; i < size; i++) {
  102bff:	83 45 fc 01          	addw   $0x1,-0x4(%di)
  102c03:	8b 45 fc             	mov    -0x4(%di),%ax
  102c06:	3b 45 10             	cmp    0x10(%di),%ax
  102c09:	7c e6                	jl     102bf1 <memset+0x1b>
    }
}
  102c0b:	90                   	nop
  102c0c:	90                   	nop
  102c0d:	c9                   	leave  
  102c0e:	c3                   	ret    

00102c0f <memcmp>:

// 内存比较函数 memcmp
int memcmp(const void *d1, const void *d2, int size) {
  102c0f:	55                   	push   %bp
  102c10:	89 e5                	mov    %sp,%bp
  102c12:	83 ec 10             	sub    $0x10,%sp
    const uint8_t *s1 = d1;
  102c15:	8b 45 08             	mov    0x8(%di),%ax
  102c18:	89 45 f8             	mov    %ax,-0x8(%di)
    const uint8_t *s2 = d2;
  102c1b:	8b 45 0c             	mov    0xc(%di),%ax
  102c1e:	89 45 f4             	mov    %ax,-0xc(%di)
    for (int i = 0; i < size; i++) {
  102c21:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
  102c26:	00 00                	add    %al,(%bx,%si)
  102c28:	eb 3e                	jmp    102c68 <memcmp+0x59>
        if (s1[i] != s2[i]) {
  102c2a:	8b 55 fc             	mov    -0x4(%di),%dx
  102c2d:	8b 45 f8             	mov    -0x8(%di),%ax
  102c30:	01 d0                	add    %dx,%ax
  102c32:	0f b6 10             	movzbw (%bx,%si),%dx
  102c35:	8b 4d fc             	mov    -0x4(%di),%cx
  102c38:	8b 45 f4             	mov    -0xc(%di),%ax
  102c3b:	01 c8                	add    %cx,%ax
  102c3d:	0f b6 00             	movzbw (%bx,%si),%ax
  102c40:	38 c2                	cmp    %al,%dl
  102c42:	74 20                	je     102c64 <memcmp+0x55>
            return s1[i] - s2[i];
  102c44:	8b 55 fc             	mov    -0x4(%di),%dx
  102c47:	8b 45 f8             	mov    -0x8(%di),%ax
  102c4a:	01 d0                	add    %dx,%ax
  102c4c:	0f b6 00             	movzbw (%bx,%si),%ax
  102c4f:	0f b6 c0             	movzbw %al,%ax
  102c52:	8b 4d fc             	mov    -0x4(%di),%cx
  102c55:	8b 55 f4             	mov    -0xc(%di),%dx
  102c58:	01 ca                	add    %cx,%dx
  102c5a:	0f b6 12             	movzbw (%bp,%si),%dx
  102c5d:	0f b6 d2             	movzbw %dl,%dx
  102c60:	29 d0                	sub    %dx,%ax
  102c62:	eb 11                	jmp    102c75 <memcmp+0x66>
    for (int i = 0; i < size; i++) {
  102c64:	83 45 fc 01          	addw   $0x1,-0x4(%di)
  102c68:	8b 45 fc             	mov    -0x4(%di),%ax
  102c6b:	3b 45 10             	cmp    0x10(%di),%ax
  102c6e:	7c ba                	jl     102c2a <memcmp+0x1b>
        }
    }
    return 0;
  102c70:	b8 00 00             	mov    $0x0,%ax
  102c73:	00 00                	add    %al,(%bx,%si)
}
  102c75:	c9                   	leave  
  102c76:	c3                   	ret    

00102c77 <itoa>:

void itoa(char *buf, uint32_t num, int base) {
  102c77:	55                   	push   %bp
  102c78:	89 e5                	mov    %sp,%bp
  102c7a:	83 ec 20             	sub    $0x20,%sp
    char *ptr = buf;
  102c7d:	8b 45 08             	mov    0x8(%di),%ax
  102c80:	89 45 fc             	mov    %ax,-0x4(%di)

    // 临时变量
    uint32_t temp = num;
  102c83:	8b 45 0c             	mov    0xc(%di),%ax
  102c86:	89 45 f8             	mov    %ax,-0x8(%di)

    // 转换为字符串（低位在前）
    do {
        int remainder = temp % base;
  102c89:	8b 4d 10             	mov    0x10(%di),%cx
  102c8c:	8b 45 f8             	mov    -0x8(%di),%ax
  102c8f:	ba 00 00             	mov    $0x0,%dx
  102c92:	00 00                	add    %al,(%bx,%si)
  102c94:	f7 f1                	div    %cx
  102c96:	89 d0                	mov    %dx,%ax
  102c98:	89 45 ec             	mov    %ax,-0x14(%di)
        *ptr++ = (remainder > 9) ? (remainder - 10) + 'a' : remainder + '0';
  102c9b:	83 7d ec 09          	cmpw   $0x9,-0x14(%di)
  102c9f:	7e 0a                	jle    102cab <itoa+0x34>
  102ca1:	8b 45 ec             	mov    -0x14(%di),%ax
  102ca4:	83 c0 57             	add    $0x57,%ax
  102ca7:	89 c1                	mov    %ax,%cx
  102ca9:	eb 08                	jmp    102cb3 <itoa+0x3c>
  102cab:	8b 45 ec             	mov    -0x14(%di),%ax
  102cae:	83 c0 30             	add    $0x30,%ax
  102cb1:	89 c1                	mov    %ax,%cx
  102cb3:	8b 45 fc             	mov    -0x4(%di),%ax
  102cb6:	8d 50 01             	lea    0x1(%bx,%si),%dx
  102cb9:	89 55 fc             	mov    %dx,-0x4(%di)
  102cbc:	88 08                	mov    %cl,(%bx,%si)
    } while (temp /= base);
  102cbe:	8b 4d 10             	mov    0x10(%di),%cx
  102cc1:	8b 45 f8             	mov    -0x8(%di),%ax
  102cc4:	ba 00 00             	mov    $0x0,%dx
  102cc7:	00 00                	add    %al,(%bx,%si)
  102cc9:	f7 f1                	div    %cx
  102ccb:	89 45 f8             	mov    %ax,-0x8(%di)
  102cce:	83 7d f8 00          	cmpw   $0x0,-0x8(%di)
  102cd2:	75 b5                	jne    102c89 <itoa+0x12>

    // 添加字符串结束符
    *ptr = '\0';
  102cd4:	8b 45 fc             	mov    -0x4(%di),%ax
  102cd7:	c6 00 00             	movb   $0x0,(%bx,%si)

    // 反转字符串
    char *start = buf;
  102cda:	8b 45 08             	mov    0x8(%di),%ax
  102cdd:	89 45 f4             	mov    %ax,-0xc(%di)
    char *end = ptr - 1;
  102ce0:	8b 45 fc             	mov    -0x4(%di),%ax
  102ce3:	83 e8 01             	sub    $0x1,%ax
  102ce6:	89 45 f0             	mov    %ax,-0x10(%di)
    while (start < end) {
  102ce9:	eb 29                	jmp    102d14 <itoa+0x9d>
        char tmp = *start;
  102ceb:	8b 45 f4             	mov    -0xc(%di),%ax
  102cee:	0f b6 00             	movzbw (%bx,%si),%ax
  102cf1:	88 45 eb             	mov    %al,-0x15(%di)
        *start++ = *end;
  102cf4:	8b 45 f4             	mov    -0xc(%di),%ax
  102cf7:	8d 50 01             	lea    0x1(%bx,%si),%dx
  102cfa:	89 55 f4             	mov    %dx,-0xc(%di)
  102cfd:	8b 55 f0             	mov    -0x10(%di),%dx
  102d00:	0f b6 12             	movzbw (%bp,%si),%dx
  102d03:	88 10                	mov    %dl,(%bx,%si)
        *end-- = tmp;
  102d05:	8b 45 f0             	mov    -0x10(%di),%ax
  102d08:	8d 50 ff             	lea    -0x1(%bx,%si),%dx
  102d0b:	89 55 f0             	mov    %dx,-0x10(%di)
  102d0e:	0f b6 55 eb          	movzbw -0x15(%di),%dx
  102d12:	88 10                	mov    %dl,(%bx,%si)
    while (start < end) {
  102d14:	8b 45 f4             	mov    -0xc(%di),%ax
  102d17:	3b 45 f0             	cmp    -0x10(%di),%ax
  102d1a:	72 cf                	jb     102ceb <itoa+0x74>
    }
}
  102d1c:	90                   	nop
  102d1d:	90                   	nop
  102d1e:	c9                   	leave  
  102d1f:	c3                   	ret    

00102d20 <sprintf>:


// 格式化字符串输出函数 sprintf
void sprintf(char *buffer, const char *fmt, ...) {
  102d20:	55                   	push   %bp
  102d21:	89 e5                	mov    %sp,%bp
  102d23:	83 ec 18             	sub    $0x18,%sp
    va_list args;
    va_start(args, fmt);
  102d26:	8d 45 10             	lea    0x10(%di),%ax
  102d29:	89 45 f4             	mov    %ax,-0xc(%di)
    vsprintf(buffer, fmt, args);
  102d2c:	8b 45 f4             	mov    -0xc(%di),%ax
  102d2f:	83 ec 04             	sub    $0x4,%sp
  102d32:	50                   	push   %ax
  102d33:	ff 75 0c             	push   0xc(%di)
  102d36:	ff 75 08             	push   0x8(%di)
  102d39:	e8 06 00             	call   102d42 <sprintf+0x22>
  102d3c:	00 00                	add    %al,(%bx,%si)
  102d3e:	83 c4 10             	add    $0x10,%sp
    va_end(args);
}
  102d41:	90                   	nop
  102d42:	c9                   	leave  
  102d43:	c3                   	ret    

00102d44 <vsprintf>:

// 格式化字符串输出函数 vsprintf
void vsprintf(char *buffer, const char *fmt, va_list args) {
  102d44:	55                   	push   %bp
  102d45:	89 e5                	mov    %sp,%bp
  102d47:	83 ec 20             	sub    $0x20,%sp
    char *buf_ptr = buffer;
  102d4a:	8b 45 08             	mov    0x8(%di),%ax
  102d4d:	89 45 fc             	mov    %ax,-0x4(%di)
    const char *fmt_ptr = fmt;
  102d50:	8b 45 0c             	mov    0xc(%di),%ax
  102d53:	89 45 f8             	mov    %ax,-0x8(%di)
    while (*fmt_ptr) {
  102d56:	e9 fc 00             	jmp    102e55 <vsprintf+0x111>
  102d59:	00 00                	add    %al,(%bx,%si)
        if (*fmt_ptr == '%' && *(fmt_ptr + 1) != '%') {
  102d5b:	8b 45 f8             	mov    -0x8(%di),%ax
  102d5e:	0f b6 00             	movzbw (%bx,%si),%ax
  102d61:	3c 25                	cmp    $0x25,%al
  102d63:	0f 85 d9 00          	jne    102e40 <vsprintf+0xfc>
  102d67:	00 00                	add    %al,(%bx,%si)
  102d69:	8b 45 f8             	mov    -0x8(%di),%ax
  102d6c:	83 c0 01             	add    $0x1,%ax
  102d6f:	0f b6 00             	movzbw (%bx,%si),%ax
  102d72:	3c 25                	cmp    $0x25,%al
  102d74:	0f 84 c8 00          	je     102e40 <vsprintf+0xfc>
  102d78:	00 00                	add    %al,(%bx,%si)
            fmt_ptr++;
  102d7a:	83 45 f8 01          	addw   $0x1,-0x8(%di)
            switch (*fmt_ptr) {
  102d7e:	8b 45 f8             	mov    -0x8(%di),%ax
  102d81:	0f b6 00             	movzbw (%bx,%si),%ax
  102d84:	0f be c0             	movsbw %al,%ax
  102d87:	83 f8 78             	cmp    $0x78,%ax
  102d8a:	74 47                	je     102dd3 <vsprintf+0x8f>
  102d8c:	83 f8 78             	cmp    $0x78,%ax
  102d8f:	0f 8f 99 00          	jg     102e2c <vsprintf+0xe8>
  102d93:	00 00                	add    %al,(%bx,%si)
  102d95:	83 f8 64             	cmp    $0x64,%ax
  102d98:	74 0a                	je     102da4 <vsprintf+0x60>
  102d9a:	83 f8 73             	cmp    $0x73,%ax
  102d9d:	74 63                	je     102e02 <vsprintf+0xbe>
  102d9f:	e9 8a 00             	jmp    102e2c <vsprintf+0xe8>
  102da2:	00 00                	add    %al,(%bx,%si)
                case 'd': {
                    int num = va_arg(args, int);
  102da4:	8b 45 10             	mov    0x10(%di),%ax
  102da7:	8d 50 04             	lea    0x4(%bx,%si),%dx
  102daa:	89 55 10             	mov    %dx,0x10(%di)
  102dad:	8b 00                	mov    (%bx,%si),%ax
  102daf:	89 45 ec             	mov    %ax,-0x14(%di)
                    itoa(buf_ptr, num, 10);
  102db2:	8b 45 ec             	mov    -0x14(%di),%ax
  102db5:	6a 0a                	push   $0xa
  102db7:	50                   	push   %ax
  102db8:	ff 75 fc             	push   -0x4(%di)
  102dbb:	e8 b7 fe             	call   102c75 <memcmp+0x66>
  102dbe:	ff                   	(bad)  
  102dbf:	ff 83 c4 0c          	incw   0xcc4(%bp,%di)
                    buf_ptr += strlen(buf_ptr);
  102dc3:	ff 75 fc             	push   -0x4(%di)
  102dc6:	e8 a4 fd             	call   102b6d <strncmp+0x70>
  102dc9:	ff                   	(bad)  
  102dca:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  102dce:	01 45 fc             	add    %ax,-0x4(%di)
                    break;
  102dd1:	eb 6d                	jmp    102e40 <vsprintf+0xfc>
                }
                case 'x': {
                    int num = va_arg(args, int);
  102dd3:	8b 45 10             	mov    0x10(%di),%ax
  102dd6:	8d 50 04             	lea    0x4(%bx,%si),%dx
  102dd9:	89 55 10             	mov    %dx,0x10(%di)
  102ddc:	8b 00                	mov    (%bx,%si),%ax
  102dde:	89 45 f4             	mov    %ax,-0xc(%di)
                    itoa(buf_ptr, num, 16);
  102de1:	8b 45 f4             	mov    -0xc(%di),%ax
  102de4:	6a 10                	push   $0x10
  102de6:	50                   	push   %ax
  102de7:	ff 75 fc             	push   -0x4(%di)
  102dea:	e8 88 fe             	call   102c75 <memcmp+0x66>
  102ded:	ff                   	(bad)  
  102dee:	ff 83 c4 0c          	incw   0xcc4(%bp,%di)
                    buf_ptr += strlen(buf_ptr);
  102df2:	ff 75 fc             	push   -0x4(%di)
  102df5:	e8 75 fd             	call   102b6d <strncmp+0x70>
  102df8:	ff                   	(bad)  
  102df9:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  102dfd:	01 45 fc             	add    %ax,-0x4(%di)
                    break;
  102e00:	eb 3e                	jmp    102e40 <vsprintf+0xfc>
                }
                case 's': {
                    const char *str = va_arg(args, const char *);
  102e02:	8b 45 10             	mov    0x10(%di),%ax
  102e05:	8d 50 04             	lea    0x4(%bx,%si),%dx
  102e08:	89 55 10             	mov    %dx,0x10(%di)
  102e0b:	8b 00                	mov    (%bx,%si),%ax
  102e0d:	89 45 f0             	mov    %ax,-0x10(%di)
                    strcpy(buf_ptr, str);
  102e10:	ff 75 f0             	push   -0x10(%di)
  102e13:	ff 75 fc             	push   -0x4(%di)
  102e16:	e8 60 fc             	call   102a79 <list_remove+0x83>
  102e19:	ff                   	(bad)  
  102e1a:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
                    buf_ptr += strlen(str);
  102e1e:	ff 75 f0             	push   -0x10(%di)
  102e21:	e8 49 fd             	call   102b6d <strncmp+0x70>
  102e24:	ff                   	(bad)  
  102e25:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  102e29:	01 45 fc             	add    %ax,-0x4(%di)
                    break;
  102e2c:	eb 12                	jmp    102e40 <vsprintf+0xfc>
                }
                default:
                    *buf_ptr++ = *fmt_ptr;
  102e2e:	8b 45 fc             	mov    -0x4(%di),%ax
  102e31:	8d 50 01             	lea    0x1(%bx,%si),%dx
  102e34:	89 55 fc             	mov    %dx,-0x4(%di)
  102e37:	8b 55 f8             	mov    -0x8(%di),%dx
  102e3a:	0f b6 12             	movzbw (%bp,%si),%dx
  102e3d:	88 10                	mov    %dl,(%bx,%si)
                    break;
  102e3f:	90                   	nop
            switch (*fmt_ptr) {
  102e40:	eb 11                	jmp    102e53 <vsprintf+0x10f>
            }
        } else {
            *buf_ptr++ = *fmt_ptr;
  102e42:	8b 45 fc             	mov    -0x4(%di),%ax
  102e45:	8d 50 01             	lea    0x1(%bx,%si),%dx
  102e48:	89 55 fc             	mov    %dx,-0x4(%di)
  102e4b:	8b 55 f8             	mov    -0x8(%di),%dx
  102e4e:	0f b6 12             	movzbw (%bp,%si),%dx
  102e51:	88 10                	mov    %dl,(%bx,%si)
        }
        fmt_ptr++;
  102e53:	83 45 f8 01          	addw   $0x1,-0x8(%di)
    while (*fmt_ptr) {
  102e57:	8b 45 f8             	mov    -0x8(%di),%ax
  102e5a:	0f b6 00             	movzbw (%bx,%si),%ax
  102e5d:	84 c0                	test   %al,%al
  102e5f:	0f 85 f6 fe          	jne    102d59 <vsprintf+0x15>
  102e63:	ff                   	(bad)  
  102e64:	ff 8b 45 fc          	decw   -0x3bb(%bp,%di)
    }
    *buf_ptr = '\0';
  102e68:	c6 00 00             	movb   $0x0,(%bx,%si)
}
  102e6b:	90                   	nop
  102e6c:	c9                   	leave  
  102e6d:	c3                   	ret    

00102e6e <is_leap_year>:
// 每月天数定义（默认 2 月为 28 天）
static const int days_in_month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

// 判断是否为闰年
static int is_leap_year(int year)
{
  102e6e:	55                   	push   %bp
  102e6f:	89 e5                	mov    %sp,%bp
    return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));
  102e71:	8b 45 08             	mov    0x8(%di),%ax
  102e74:	83 e0 03             	and    $0x3,%ax
  102e77:	85 c0                	test   %ax,%ax
  102e79:	75 50                	jne    102ecb <is_leap_year+0x5d>
  102e7b:	8b 4d 08             	mov    0x8(%di),%cx
  102e7e:	ba 1f 85             	mov    $0x851f,%dx
  102e81:	eb 51                	jmp    102ed4 <kernel_mktime+0x2>
  102e83:	89 c8                	mov    %cx,%ax
  102e85:	f7 ea                	imul   %dx
  102e87:	89 d0                	mov    %dx,%ax
  102e89:	c1 f8 05             	sar    $0x5,%ax
  102e8c:	89 ca                	mov    %cx,%dx
  102e8e:	c1 fa 1f             	sar    $0x1f,%dx
  102e91:	29 d0                	sub    %dx,%ax
  102e93:	6b d0 64             	imul   $0x64,%ax,%dx
  102e96:	89 c8                	mov    %cx,%ax
  102e98:	29 d0                	sub    %dx,%ax
  102e9a:	85 c0                	test   %ax,%ax
  102e9c:	75 26                	jne    102ec4 <is_leap_year+0x56>
  102e9e:	8b 4d 08             	mov    0x8(%di),%cx
  102ea1:	ba 1f 85             	mov    $0x851f,%dx
  102ea4:	eb 51                	jmp    102ef7 <kernel_mktime+0x25>
  102ea6:	89 c8                	mov    %cx,%ax
  102ea8:	f7 ea                	imul   %dx
  102eaa:	89 d0                	mov    %dx,%ax
  102eac:	c1 f8 07             	sar    $0x7,%ax
  102eaf:	89 ca                	mov    %cx,%dx
  102eb1:	c1 fa 1f             	sar    $0x1f,%dx
  102eb4:	29 d0                	sub    %dx,%ax
  102eb6:	69 d0 90 01          	imul   $0x190,%ax,%dx
  102eba:	00 00                	add    %al,(%bx,%si)
  102ebc:	89 c8                	mov    %cx,%ax
  102ebe:	29 d0                	sub    %dx,%ax
  102ec0:	85 c0                	test   %ax,%ax
  102ec2:	75 07                	jne    102ecb <is_leap_year+0x5d>
  102ec4:	b8 01 00             	mov    $0x1,%ax
  102ec7:	00 00                	add    %al,(%bx,%si)
  102ec9:	eb 05                	jmp    102ed0 <is_leap_year+0x62>
  102ecb:	b8 00 00             	mov    $0x0,%ax
  102ece:	00 00                	add    %al,(%bx,%si)
}
  102ed0:	5d                   	pop    %bp
  102ed1:	c3                   	ret    

00102ed2 <kernel_mktime>:

/**
 * 将本地时间转换为时间戳
 */
time_t kernel_mktime(tm_t *tm)
{
  102ed2:	55                   	push   %bp
  102ed3:	89 e5                	mov    %sp,%bp
  102ed5:	83 ec 10             	sub    $0x10,%sp
    int year = tm->tm_year;
  102ed8:	8b 45 08             	mov    0x8(%di),%ax
  102edb:	8b 40 14             	mov    0x14(%bx,%si),%ax
  102ede:	89 45 fc             	mov    %ax,-0x4(%di)
    long days = 0;
  102ee1:	c7 45 f8 00 00       	movw   $0x0,-0x8(%di)
  102ee6:	00 00                	add    %al,(%bx,%si)

    // 处理 Y2K 问题
    if (year < 70)
  102ee8:	83 7d fc 45          	cmpw   $0x45,-0x4(%di)
  102eec:	7f 04                	jg     102ef2 <kernel_mktime+0x20>
        year += 100; // 把 00-69 解析为 2000-2069
  102eee:	83 45 fc 64          	addw   $0x64,-0x4(%di)
    year += 1900;    // 得到实际年份
  102ef2:	81 45 fc 6c 07       	addw   $0x76c,-0x4(%di)
  102ef7:	00 00                	add    %al,(%bx,%si)

    // 累加从 1970 年到指定年份的天数
    for (int y = 1970; y < year; y++)
  102ef9:	c7 45 f4 b2 07       	movw   $0x7b2,-0xc(%di)
  102efe:	00 00                	add    %al,(%bx,%si)
  102f00:	eb 22                	jmp    102f24 <kernel_mktime+0x52>
    {
        days += is_leap_year(y) ? 366 : 365;
  102f02:	ff 75 f4             	push   -0xc(%di)
  102f05:	e8 64 ff             	call   102e6c <vsprintf+0x128>
  102f08:	ff                   	(bad)  
  102f09:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  102f0d:	85 c0                	test   %ax,%ax
  102f0f:	74 07                	je     102f18 <kernel_mktime+0x46>
  102f11:	b8 6e 01             	mov    $0x16e,%ax
  102f14:	00 00                	add    %al,(%bx,%si)
  102f16:	eb 05                	jmp    102f1d <kernel_mktime+0x4b>
  102f18:	b8 6d 01             	mov    $0x16d,%ax
  102f1b:	00 00                	add    %al,(%bx,%si)
  102f1d:	01 45 f8             	add    %ax,-0x8(%di)
    for (int y = 1970; y < year; y++)
  102f20:	83 45 f4 01          	addw   $0x1,-0xc(%di)
  102f24:	8b 45 f4             	mov    -0xc(%di),%ax
  102f27:	3b 45 fc             	cmp    -0x4(%di),%ax
  102f2a:	7c d6                	jl     102f02 <kernel_mktime+0x30>
    }

    // 累加当年月份的天数
    for (int m = 0; m < tm->tm_mon; m++)
  102f2c:	c7 45 f0 00 00       	movw   $0x0,-0x10(%di)
  102f31:	00 00                	add    %al,(%bx,%si)
  102f33:	eb 2a                	jmp    102f5f <kernel_mktime+0x8d>
    {
        days += days_in_month[m];
  102f35:	8b 45 f0             	mov    -0x10(%di),%ax
  102f38:	8b 04                	mov    (%si),%ax
  102f3a:	85 c0                	test   %ax,%ax
  102f3c:	4a                   	dec    %dx
  102f3d:	10 00                	adc    %al,(%bx,%si)
  102f3f:	01 45 f8             	add    %ax,-0x8(%di)
        if (m == 1 && is_leap_year(year))
  102f42:	83 7d f0 01          	cmpw   $0x1,-0x10(%di)
  102f46:	75 13                	jne    102f5b <kernel_mktime+0x89>
  102f48:	ff 75 fc             	push   -0x4(%di)
  102f4b:	e8 1e ff             	call   102e6c <vsprintf+0x128>
  102f4e:	ff                   	(bad)  
  102f4f:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  102f53:	85 c0                	test   %ax,%ax
  102f55:	74 04                	je     102f5b <kernel_mktime+0x89>
        { // 2 月在闰年多 1 天
            days += 1;
  102f57:	83 45 f8 01          	addw   $0x1,-0x8(%di)
    for (int m = 0; m < tm->tm_mon; m++)
  102f5b:	83 45 f0 01          	addw   $0x1,-0x10(%di)
  102f5f:	8b 45 08             	mov    0x8(%di),%ax
  102f62:	8b 40 10             	mov    0x10(%bx,%si),%ax
  102f65:	39 45 f0             	cmp    %ax,-0x10(%di)
  102f68:	7c cb                	jl     102f35 <kernel_mktime+0x63>
        }
    }

    // 累加当月天数
    days += tm->tm_mday - 1;
  102f6a:	8b 45 08             	mov    0x8(%di),%ax
  102f6d:	8b 40 0c             	mov    0xc(%bx,%si),%ax
  102f70:	83 e8 01             	sub    $0x1,%ax
  102f73:	01 45 f8             	add    %ax,-0x8(%di)

    // 计算总秒数
    return days * DAY + tm->tm_hour * HOUR + tm->tm_min * MINUTE + tm->tm_sec;
  102f76:	8b 45 f8             	mov    -0x8(%di),%ax
  102f79:	69 d0 80 51          	imul   $0x5180,%ax,%dx
  102f7d:	01 00                	add    %ax,(%bx,%si)
  102f7f:	8b 45 08             	mov    0x8(%di),%ax
  102f82:	8b 40 08             	mov    0x8(%bx,%si),%ax
  102f85:	69 c0 10 0e          	imul   $0xe10,%ax,%ax
  102f89:	00 00                	add    %al,(%bx,%si)
  102f8b:	01 c2                	add    %ax,%dx
  102f8d:	8b 45 08             	mov    0x8(%di),%ax
  102f90:	8b 40 04             	mov    0x4(%bx,%si),%ax
  102f93:	6b c0 3c             	imul   $0x3c,%ax,%ax
  102f96:	01 c2                	add    %ax,%dx
  102f98:	8b 45 08             	mov    0x8(%di),%ax
  102f9b:	8b 00                	mov    (%bx,%si),%ax
  102f9d:	01 d0                	add    %dx,%ax
}
  102f9f:	c9                   	leave  
  102fa0:	c3                   	ret    

00102fa1 <localtime>:

/**
 * 计算时间戳对应的本地时间
 */
int localtime(tm_t *tm, time_t time)
{
  102fa1:	55                   	push   %bp
  102fa2:	89 e5                	mov    %sp,%bp
  102fa4:	53                   	push   %bx
  102fa5:	83 ec 10             	sub    $0x10,%sp
    if (tm == NULL)
  102fa8:	83 7d 08 00          	cmpw   $0x0,0x8(%di)
  102fac:	75 0a                	jne    102fb8 <localtime+0x17>
        return -1;
  102fae:	b8 ff ff             	mov    $0xffff,%ax
  102fb1:	ff                   	(bad)  
  102fb2:	ff                   	(bad)  
  102fb3:	e9 0a 02             	jmp    1031c0 <localtime+0x21f>
  102fb6:	00 00                	add    %al,(%bx,%si)

    int year = 1970;
  102fb8:	c7 45 f8 b2 07       	movw   $0x7b2,-0x8(%di)
  102fbd:	00 00                	add    %al,(%bx,%si)
    int days = time / DAY;
  102fbf:	8b 45 0c             	mov    0xc(%di),%ax
  102fc2:	ba 07 45             	mov    $0x4507,%dx
  102fc5:	2e c2 f7 e2          	cs ret $0xe2f7
  102fc9:	89 d0                	mov    %dx,%ax
  102fcb:	c1 e8 10             	shr    $0x10,%ax
  102fce:	89 45 f4             	mov    %ax,-0xc(%di)
    int remaining_secs = time % DAY;
  102fd1:	8b 4d 0c             	mov    0xc(%di),%cx
  102fd4:	ba 07 45             	mov    $0x4507,%dx
  102fd7:	2e c2 89 c8          	cs ret $0xc889
  102fdb:	f7 e2                	mul    %dx
  102fdd:	89 d0                	mov    %dx,%ax
  102fdf:	c1 e8 10             	shr    $0x10,%ax
  102fe2:	69 d0 80 51          	imul   $0x5180,%ax,%dx
  102fe6:	01 00                	add    %ax,(%bx,%si)
  102fe8:	89 c8                	mov    %cx,%ax
  102fea:	29 d0                	sub    %dx,%ax
  102fec:	89 45 ec             	mov    %ax,-0x14(%di)

    // 解析小时、分钟、秒
    tm->tm_hour = remaining_secs / HOUR;
  102fef:	8b 4d ec             	mov    -0x14(%di),%cx
  102ff2:	ba c5 b3             	mov    $0xb3c5,%dx
  102ff5:	a2 91 89             	mov    %al,0x8991
  102ff8:	c8 f7 ea 8d          	enter  $0xeaf7,$0x8d
  102ffc:	04 0a                	add    $0xa,%al
  102ffe:	c1 f8 0b             	sar    $0xb,%ax
  103001:	c1 f9 1f             	sar    $0x1f,%cx
  103004:	29 c8                	sub    %cx,%ax
  103006:	89 c2                	mov    %ax,%dx
  103008:	8b 45 08             	mov    0x8(%di),%ax
  10300b:	89 50 08             	mov    %dx,0x8(%bx,%si)
    remaining_secs %= HOUR;
  10300e:	8b 4d ec             	mov    -0x14(%di),%cx
  103011:	ba c5 b3             	mov    $0xb3c5,%dx
  103014:	a2 91 89             	mov    %al,0x8991
  103017:	c8 f7 ea 8d          	enter  $0xeaf7,$0x8d
  10301b:	04 0a                	add    $0xa,%al
  10301d:	c1 f8 0b             	sar    $0xb,%ax
  103020:	89 ca                	mov    %cx,%dx
  103022:	c1 fa 1f             	sar    $0x1f,%dx
  103025:	29 d0                	sub    %dx,%ax
  103027:	69 d0 10 0e          	imul   $0xe10,%ax,%dx
  10302b:	00 00                	add    %al,(%bx,%si)
  10302d:	89 c8                	mov    %cx,%ax
  10302f:	29 d0                	sub    %dx,%ax
  103031:	89 45 ec             	mov    %ax,-0x14(%di)
    tm->tm_min = remaining_secs / MINUTE;
  103034:	8b 4d ec             	mov    -0x14(%di),%cx
  103037:	ba 89 88             	mov    $0x8889,%dx
  10303a:	88 88 89 c8          	mov    %cl,-0x3777(%bx,%si)
  10303e:	f7 ea                	imul   %dx
  103040:	8d 04                	lea    (%si),%ax
  103042:	0a c1                	or     %cl,%al
  103044:	f8                   	clc    
  103045:	05 c1 f9             	add    $0xf9c1,%ax
  103048:	1f                   	pop    %ds
  103049:	29 c8                	sub    %cx,%ax
  10304b:	89 c2                	mov    %ax,%dx
  10304d:	8b 45 08             	mov    0x8(%di),%ax
  103050:	89 50 04             	mov    %dx,0x4(%bx,%si)
    tm->tm_sec = remaining_secs % MINUTE;
  103053:	8b 4d ec             	mov    -0x14(%di),%cx
  103056:	ba 89 88             	mov    $0x8889,%dx
  103059:	88 88 89 c8          	mov    %cl,-0x3777(%bx,%si)
  10305d:	f7 ea                	imul   %dx
  10305f:	8d 04                	lea    (%si),%ax
  103061:	0a c1                	or     %cl,%al
  103063:	f8                   	clc    
  103064:	05 89 ca             	add    $0xca89,%ax
  103067:	c1 fa 1f             	sar    $0x1f,%dx
  10306a:	29 d0                	sub    %dx,%ax
  10306c:	6b d0 3c             	imul   $0x3c,%ax,%dx
  10306f:	89 c8                	mov    %cx,%ax
  103071:	29 d0                	sub    %dx,%ax
  103073:	8b 55 08             	mov    0x8(%di),%dx
  103076:	89 02                	mov    %ax,(%bp,%si)

    // 计算年份
    while (days >= (is_leap_year(year) ? 366 : 365))
  103078:	eb 22                	jmp    10309c <localtime+0xfb>
    {
        days -= is_leap_year(year) ? 366 : 365;
  10307a:	ff 75 f8             	push   -0x8(%di)
  10307d:	e8 ec fd             	call   102e6c <vsprintf+0x128>
  103080:	ff                   	(bad)  
  103081:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  103085:	85 c0                	test   %ax,%ax
  103087:	74 07                	je     103090 <localtime+0xef>
  103089:	b8 6e 01             	mov    $0x16e,%ax
  10308c:	00 00                	add    %al,(%bx,%si)
  10308e:	eb 05                	jmp    103095 <localtime+0xf4>
  103090:	b8 6d 01             	mov    $0x16d,%ax
  103093:	00 00                	add    %al,(%bx,%si)
  103095:	29 45 f4             	sub    %ax,-0xc(%di)
        year++;
  103098:	83 45 f8 01          	addw   $0x1,-0x8(%di)
    while (days >= (is_leap_year(year) ? 366 : 365))
  10309c:	ff 75 f8             	push   -0x8(%di)
  10309f:	e8 ca fd             	call   102e6c <vsprintf+0x128>
  1030a2:	ff                   	(bad)  
  1030a3:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  1030a7:	85 c0                	test   %ax,%ax
  1030a9:	74 07                	je     1030b2 <localtime+0x111>
  1030ab:	b8 6e 01             	mov    $0x16e,%ax
  1030ae:	00 00                	add    %al,(%bx,%si)
  1030b0:	eb 05                	jmp    1030b7 <localtime+0x116>
  1030b2:	b8 6d 01             	mov    $0x16d,%ax
  1030b5:	00 00                	add    %al,(%bx,%si)
  1030b7:	3b 45 f4             	cmp    -0xc(%di),%ax
  1030ba:	7e be                	jle    10307a <localtime+0xd9>
    }
    tm->tm_year = year - 1900; // 转换为 1900 年的偏移
  1030bc:	8b 45 f8             	mov    -0x8(%di),%ax
  1030bf:	8d 90 94 f8          	lea    -0x76c(%bx,%si),%dx
  1030c3:	ff                   	(bad)  
  1030c4:	ff 8b 45 08          	decw   0x845(%bp,%di)
  1030c8:	89 50 14             	mov    %dx,0x14(%bx,%si)
    tm->tm_year = tm->tm_year >= 100 ? tm->tm_year - 100 : tm->tm_year;
  1030cb:	8b 45 08             	mov    0x8(%di),%ax
  1030ce:	8b 40 14             	mov    0x14(%bx,%si),%ax
  1030d1:	83 f8 63             	cmp    $0x63,%ax
  1030d4:	7e 0b                	jle    1030e1 <localtime+0x140>
  1030d6:	8b 45 08             	mov    0x8(%di),%ax
  1030d9:	8b 40 14             	mov    0x14(%bx,%si),%ax
  1030dc:	83 e8 64             	sub    $0x64,%ax
  1030df:	eb 06                	jmp    1030e7 <localtime+0x146>
  1030e1:	8b 45 08             	mov    0x8(%di),%ax
  1030e4:	8b 40 14             	mov    0x14(%bx,%si),%ax
  1030e7:	8b 55 08             	mov    0x8(%di),%dx
  1030ea:	89 42 14             	mov    %ax,0x14(%bp,%si)
    // 计算一年中的第几天
    tm->tm_yday = days;
  1030ed:	8b 45 08             	mov    0x8(%di),%ax
  1030f0:	8b 55 f4             	mov    -0xc(%di),%dx
  1030f3:	89 50 1c             	mov    %dx,0x1c(%bx,%si)

    // 计算月份和日期
    int month = 0;
  1030f6:	c7 45 f0 00 00       	movw   $0x0,-0x10(%di)
  1030fb:	00 00                	add    %al,(%bx,%si)
    while (days >= days_in_month[month] + (month == 1 && is_leap_year(year) ? 1 : 0))
  1030fd:	eb 34                	jmp    103133 <localtime+0x192>
    {
        days -= days_in_month[month] + (month == 1 && is_leap_year(year) ? 1 : 0);
  1030ff:	8b 45 f0             	mov    -0x10(%di),%ax
  103102:	8b 1c                	mov    (%si),%bx
  103104:	85 c0                	test   %ax,%ax
  103106:	4a                   	dec    %dx
  103107:	10 00                	adc    %al,(%bx,%si)
  103109:	83 7d f0 01          	cmpw   $0x1,-0x10(%di)
  10310d:	75 16                	jne    103125 <localtime+0x184>
  10310f:	ff 75 f8             	push   -0x8(%di)
  103112:	e8 57 fd             	call   102e6c <vsprintf+0x128>
  103115:	ff                   	(bad)  
  103116:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  10311a:	85 c0                	test   %ax,%ax
  10311c:	74 07                	je     103125 <localtime+0x184>
  10311e:	b8 01 00             	mov    $0x1,%ax
  103121:	00 00                	add    %al,(%bx,%si)
  103123:	eb 05                	jmp    10312a <localtime+0x189>
  103125:	b8 00 00             	mov    $0x0,%ax
  103128:	00 00                	add    %al,(%bx,%si)
  10312a:	01 d8                	add    %bx,%ax
  10312c:	29 45 f4             	sub    %ax,-0xc(%di)
        month++;
  10312f:	83 45 f0 01          	addw   $0x1,-0x10(%di)
    while (days >= days_in_month[month] + (month == 1 && is_leap_year(year) ? 1 : 0))
  103133:	8b 45 f0             	mov    -0x10(%di),%ax
  103136:	8b 1c                	mov    (%si),%bx
  103138:	85 c0                	test   %ax,%ax
  10313a:	4a                   	dec    %dx
  10313b:	10 00                	adc    %al,(%bx,%si)
  10313d:	83 7d f0 01          	cmpw   $0x1,-0x10(%di)
  103141:	75 16                	jne    103159 <localtime+0x1b8>
  103143:	ff 75 f8             	push   -0x8(%di)
  103146:	e8 23 fd             	call   102e6c <vsprintf+0x128>
  103149:	ff                   	(bad)  
  10314a:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
  10314e:	85 c0                	test   %ax,%ax
  103150:	74 07                	je     103159 <localtime+0x1b8>
  103152:	b8 01 00             	mov    $0x1,%ax
  103155:	00 00                	add    %al,(%bx,%si)
  103157:	eb 05                	jmp    10315e <localtime+0x1bd>
  103159:	b8 00 00             	mov    $0x0,%ax
  10315c:	00 00                	add    %al,(%bx,%si)
  10315e:	01 d8                	add    %bx,%ax
  103160:	39 45 f4             	cmp    %ax,-0xc(%di)
  103163:	7d 9a                	jge    1030ff <localtime+0x15e>
    }
    tm->tm_mon = month;
  103165:	8b 45 08             	mov    0x8(%di),%ax
  103168:	8b 55 f0             	mov    -0x10(%di),%dx
  10316b:	89 50 10             	mov    %dx,0x10(%bx,%si)
    tm->tm_mday = days + 1;
  10316e:	8b 45 f4             	mov    -0xc(%di),%ax
  103171:	8d 50 01             	lea    0x1(%bx,%si),%dx
  103174:	8b 45 08             	mov    0x8(%di),%ax
  103177:	89 50 0c             	mov    %dx,0xc(%bx,%si)

    // 计算星期几（1970-01-01 是星期四）
    tm->tm_wday = (time / DAY + 4) % 7;
  10317a:	8b 45 0c             	mov    0xc(%di),%ax
  10317d:	ba 07 45             	mov    $0x4507,%dx
  103180:	2e c2 f7 e2          	cs ret $0xe2f7
  103184:	89 d0                	mov    %dx,%ax
  103186:	c1 e8 10             	shr    $0x10,%ax
  103189:	8d 48 04             	lea    0x4(%bx,%si),%cx
  10318c:	ba 25 49             	mov    $0x4925,%dx
  10318f:	92                   	xchg   %ax,%dx
  103190:	24 89                	and    $0x89,%al
  103192:	c8 f7 e2 89          	enter  $0xe2f7,$0x89
  103196:	c8 29 d0 d1          	enter  $0xd029,$0xd1
  10319a:	e8 01 d0             	call   10019e <exception_handler_stack_segment_fault+0x12>
  10319d:	c1 e8 02             	shr    $0x2,%ax
  1031a0:	89 c2                	mov    %ax,%dx
  1031a2:	c1 e2 03             	shl    $0x3,%dx
  1031a5:	29 c2                	sub    %ax,%dx
  1031a7:	89 c8                	mov    %cx,%ax
  1031a9:	29 d0                	sub    %dx,%ax
  1031ab:	89 c2                	mov    %ax,%dx
  1031ad:	8b 45 08             	mov    0x8(%di),%ax
  1031b0:	89 50 18             	mov    %dx,0x18(%bx,%si)

    // 假设不使用夏令时
    tm->tm_isdst = 0;
  1031b3:	8b 45 08             	mov    0x8(%di),%ax
  1031b6:	c7 40 20 00 00       	movw   $0x0,0x20(%bx,%si)
  1031bb:	00 00                	add    %al,(%bx,%si)

    return 0;
  1031bd:	b8 00 00             	mov    $0x0,%ax
  1031c0:	00 00                	add    %al,(%bx,%si)
  1031c2:	8b 5d fc             	mov    -0x4(%di),%bx
  1031c5:	c9                   	leave  
  1031c6:	c3                   	ret    
